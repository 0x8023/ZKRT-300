C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE 8023
OBJECT MODULE PLACED IN .\output\8023.obj
COMPILER INVOKED BY: H:\Program\keil\C51\BIN\C51.EXE program\8023.c DEBUG OBJECTEXTEND PRINT(.\8023.lst) OBJECT(.\output
                    -\8023.obj)

line level    source

   1          #include "./output/8023.h"
   2          xdata struct str_state str_begin,str_now,str_next;//分别为:起始状态/当前状态/目标状态
   3          xdata struct str_parameter str_cod={
   4              /*ui str_cod.mlinerqd*/25000,//默认主函数巡线软起动路程为25000
   5              /*ui str_cod.mlineqc*/200,//默认主函数巡线前冲时间为500毫秒
   6          
   7              /*ui str_cod.sj1bzw*/58,//升降标准位延时
   8              /*ui str_cod.sj1zjw*/800,//升降中间位延时
   9          
  10              /*ui str_cod.py1qkq*/666,
  11              /*ui str_cod.py1kqz*/684,
  12              /*ui str_cod.py1zkh*/684,
  13              /*ui str_cod.py1khh*/666,
  14              /*ui str_cod.py1qz*/500,
  15              /*ui str_cod.py1zh*/500,
  16              /*ui str_cod.py1kqkh*/1480,
  17              /*ui str_cod.py1qkh*/2122,
  18              /*ui str_cod.py1kqh*/2122,
  19          };
  20          ui var_timer0=0;
  21          void fun_delay(ui par_value,enum varENU_del par_model){
  22   1          ui loc_con=par_value;
  23   1          switch(par_model){
  24   2              case del_us://微秒级延时
  25   2                  while(loc_con-->0){
  26   3                      _nop_();
  27   3                      _nop_();
  28   3                  }
  29   2                  return;
  30   2              case del_ms://毫秒级延时
  31   2                  while(loc_con-->0){
  32   3                      uc loc_i, loc_j;
  33   3                      _nop_();
  34   3                      _nop_();
  35   3                      loc_i=12;
  36   3                      loc_j=168;
  37   3                      do{
  38   4                          while(--loc_j);
  39   4                      }while(--loc_i);
  40   3                  }
  41   2                  return;
  42   2              case del_s://秒级延时
  43   2                  while(loc_con-->0){
  44   3                      uc loc_i, loc_j, loc_k;
  45   3                      loc_i=46;
  46   3                      loc_j=153;
  47   3                      loc_k=245;
  48   3                      do{
  49   4                          do{
  50   5                              while(--loc_k);
  51   5                          }while(--loc_j);
  52   4                      }while(--loc_i);
  53   3                  }
  54   2                  return;
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 2   

  55   2              default:return;
  56   2          }
  57   1      }//延时
  58          void fun_timer0init(){
  59   1          AUXR|=0x80;       //定时器时钟1T模式
  60   1          TMOD&=0xF0;       //设置定时器模式
  61   1          TMOD|=0x01;       //设置定时器模式
  62   1          TL0=0x20;     //设置定时初值
  63   1          TH0=0xD1;     //设置定时初值
  64   1          TF0=0;        //清除TF0标志
  65   1          ET0=1;
  66   1          EA=1;
  67   1      }//1毫秒定时器0初始化
  68          void fun_timer1init(){
  69   1          AUXR&=0xBF;
  70   1          TMOD&=0x0F;
  71   1          TMOD|=0x10;
  72   1          TL1=0xE0;
  73   1          TH1=0xB1;
  74   1          TF1=0;
  75   1          ET1=1;
  76   1          EA=1;
  77   1      }//20毫秒定时器1初始化
  78          void fun_timer0(){
  79   1          TL0=0x20;
  80   1          TH0=0xD1;
  81   1          _nop_();
  82   1          var_timer0++;
  83   1      }//1毫秒定时器0处理函数
  84          void fun_timer1(){
  85   1          TL1=0xE0;
  86   1          TH1=0xB1;
  87   1          _nop_();
  88   1      }//20毫秒定时器1处理函数
  89          void fun_wait(){
  90   1          while(in_start==1);
  91   1          fun_delay(20,del_ms);
  92   1          while(in_start==0);
  93   1          fun_delay(256,del_ms);
  94   1      }//等待按键
  95          void fun_select(enum varENU_sel par_model){
  96   1          if(par_model==sel_58)
  97   1              out_switchselect=0;
  98   1          else if(par_model==sel_912)
  99   1              out_switchselect=1;
 100   1      }//传感器片选
 101          void fun_initialization(){
 102   1          CLK_DIV=0x00;//不分频
 103   1      
 104   1          P0M1=0xff;//P0用于输入
 105   1          P0M0=0x00;//P0不能输出
 106   1          
 107   1          P1M1=0x00;//P1口0-1双向，2中断输入，3-6输入，7输出
 108   1          P1M0=0xfc;//P1口2-7输出
 109   1      
 110   1          P2M1=0xf0;//P2口4-7输入
 111   1          P2M0=0x0f;//P2口0-3输出
 112   1      
 113   1          //PS_2=1;//手抓松传感器置1 $?$
 114   1          //PS_11=1;//升降位置3传感器置1 $?$
 115   1      
 116   1          out_en1=1;//电机1/3使能 $?$
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 3   

 117   1          out_en2=1;//电机2/4使能 $?$
 118   1          //out_motorselect=1;//电机片选为1 $?$
 119   1          //fun_delay(del_ms,1);//延时1毫秒 $?$
 120   1          out_motorselect=0;//电机片选为0 $?$
 121   1          //PS_5=PS_1;// $?$
 122   1      
 123   1          fun_pwminit();//PWM的初始化设置
 124   1          fun_timer0init();//初始化定时器0
 125   1          fun_timer1init();//初始化定时器1
 126   1          fun_port();//初始化串口
 127   1          in_start=1;//按键置1
 128   1      
 129   1          fun_wait();
 130   1      }//初始化
 131          void fun_pwminit(){
 132   1          CCON=0x00;
 133   1          CH=0;
 134   1          CL=0;
 135   1          CMOD=0x00;
 136   1      }//PWM初始化
 137          void fun_pwmr(uc par_value){
 138   1          CCAP0H=CCAP0L=par_value*2.5;//控制输出的占空比
 139   1          CCAPM0=0X42;//8位PWM输出，无中断
 140   1          PCA_PWM0=0x00;
 141   1      }//右路PWM输出
 142          void fun_pwml(uc par_value){
 143   1          CCAP1H=CCAP1L=par_value*2.5;//控制输出的占空比
 144   1          CCAPM1=0X42;//8位PWM输出，无中断
 145   1          PCA_PWM1=0x00;
 146   1      }//左路PWM输出
 147          void fun_startdj(enum varENU_mot par_model,char par_speed){
 148   1          if(par_speed==0)
 149   1              return;
 150   1          else if(par_speed>100)
 151   1              par_speed=100;
 152   1          else if(par_speed<-100)
 153   1              par_speed=-100;
 154   1          switch(par_model){
 155   2              case mot_l://左轮电机
 156   2                  CR=1;
 157   2                  if(par_speed>0){
 158   3                      fun_pwml(par_speed);out_pwml=0;
 159   3                  }
 160   2                  else if(par_speed<0){
 161   3                      fun_pwml(cabs(par_speed));out_pwml=1;
 162   3                  }
 163   2                  break;
 164   2              case mot_r://右轮电机
 165   2                  CR=1;
 166   2                  if(par_speed>0){
 167   3                      fun_pwmr(par_speed);out_pwmr=0;
 168   3                  }
 169   2                  else if(par_speed<0){
 170   3                      fun_pwmr(cabs(par_speed));out_pwmr=1;
 171   3                  }
 172   2                  break;
 173   2              case mot_rl://左右轮同步
 174   2                  CR=1;
 175   2                  if(par_speed>0){
 176   3                      fun_pwml(par_speed);out_pwml=0;
 177   3                      fun_pwmr(par_speed);out_pwmr=0;
 178   3                  }
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 4   

 179   2                  else if(par_speed<0){
 180   3                      fun_pwml(cabs(par_speed));out_pwml=1;
 181   3                      fun_pwmr(cabs(par_speed));out_pwmr=1;
 182   3                  }
 183   2                  break;
 184   2              case mot_dj1://正转为抓紧，反转为松开
 185   2                  out_motorselect=1;
 186   2                  if(par_speed>0)
 187   2                      out_dir1=1;
 188   2                  else if(par_speed<0)
 189   2                      out_dir1=0;
 190   2                  out_en1=0;
 191   2                  break;
 192   2              case mot_dj2://正转是向无电机一方转,反转为向有电机一方转
 193   2                  out_motorselect=1;
 194   2                  if(par_speed>0)
 195   2                      out_dir2=1;
 196   2                  else if(par_speed<0)
 197   2                      out_dir2=0;
 198   2                  out_en2=0;
 199   2                  break;
 200   2              case mot_dj3://向上为正转,向下为反转
 201   2                  out_motorselect=0;
 202   2                  if(par_speed>0)
 203   2                      out_dir1=0;
 204   2                  else if(par_speed<0)
 205   2                      out_dir1=1;
 206   2                  out_en1=0;
 207   2                  break;
 208   2              case mot_dj4://顺时针为正转,逆时针为反转
 209   2                  out_motorselect=0;
 210   2                  if(par_speed>0)
 211   2                      out_dir2=0;
 212   2                  else if(par_speed<0)
 213   2                      out_dir2=1;
 214   2                  out_en2=0;
 215   2                  break;
 216   2              default:
 217   2                  break;
 218   2          }
 219   1      }//启动电机
 220          void fun_stop(enum varENU_mot par_model){
 221   1          switch(par_model){
 222   2              case mot_l:
 223   2                  fun_pwml(0);out_pwml=0;break;
 224   2              case mot_r:
 225   2                  fun_pwmr(0);out_pwmr=0;break;
 226   2              case mot_rl:
 227   2                  CR=0;
 228   2                  fun_pwmr(0);out_pwmr=0;
 229   2                  fun_pwml(0);out_pwml=0;
 230   2                  break;
 231   2              case mot_dj1:
 232   2                  out_motorselect=1;out_dir1=0;out_en1=1;break;
 233   2              case mot_dj2:
 234   2                  out_motorselect=1;out_dir2=0;out_en2=1;break;
 235   2              case mot_dj3:
 236   2                  out_motorselect=0;out_dir1=0;out_en1=1;break;
 237   2              case mot_dj4:
 238   2                  out_motorselect=0;out_dir2=0;out_en2=1;break;
 239   2              default:
 240   2                  break;
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 5   

 241   2          }
 242   1      }//停止电机
 243          void fun_sz1(enum varENU_han par_model){
 244   1          if(str_begin.szzt==par_model)
 245   1              return;
 246   1          if(par_model==han_s){//手抓松
 247   2              while(1){
 248   3                  fun_startdj(mot_dj1,-100);
 249   3                  while(in_s==1);
 250   3                  fun_delay(20,del_ms);
 251   3                  if(in_s==0)
 252   3                      break;
 253   3              }
 254   2          }
 255   1          else{//手抓紧
 256   2              while(1){
 257   3                  fun_startdj(mot_dj1,100);
 258   3                  while(in_j==1);
 259   3                  fun_delay(20,del_ms);
 260   3                  if(in_j==0)
 261   3                      break;
 262   3              }
 263   2          }
 264   1          fun_stop(mot_dj1);
 265   1          str_begin.szzt=par_model;//存储运行结果
 266   1      }//手抓单步运动
 267          void fun_sj1(enum varENU_sjp par_model){
 268   1          if(par_model==str_begin.sjwz)
 269   1             return;
 270   1          switch(par_model){
 271   2              case sjp_wz1://升降位置1(最上位)
 272   2                  fun_startdj(mot_dj3,100);
 273   2                  fun_select(sel_58);
 274   2                  fun_delay(50,del_ms);
 275   2                  while(1){//只有向上
 276   3                      while(in_wz1==1);
 277   3                      fun_delay(20,del_ms);
 278   3                      if(in_wz1==0){
 279   4                          fun_delay(20,del_ms);
 280   4                          break;                    
 281   4                      }
 282   3                  }
 283   2                  break;
 284   2              case sjp_wz12:
 285   2                  if(par_model>str_begin.sjwz){
 286   3                      fun_startdj(mot_dj3,-100);
 287   3                      fun_delay(str_cod.sj1zjw,del_ms);
 288   3                  }
 289   2                  else{//要去的地方在上面，向上走
 290   3                      fun_sj1(sjp_wz2);
 291   3                      fun_startdj(mot_dj3,100);
 292   3                      fun_delay(str_cod.sj1zjw,del_ms);
 293   3                  }
 294   2                  break;
 295   2              case sjp_wz2://升降位置2
 296   2                  if(par_model>str_begin.sjwz)
 297   2                      fun_startdj(mot_dj3,-100);
 298   2                  else
 299   2                      fun_startdj(mot_dj3,100);
 300   2                  fun_select(sel_58);
 301   2                  fun_delay(50,del_ms);
 302   2                  while(1){//要去的地方比较靠下,向下走                    
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 6   

 303   3                      while(in_wz2==1);
 304   3                      fun_delay(20,del_ms);
 305   3                      if(in_wz2==0){
 306   4                          fun_delay(str_cod.sj1bzw,del_ms);
 307   4                          break;
 308   4                      }
 309   3                  }
 310   2                  break;
 311   2              case sjp_wz23:
 312   2                  if(par_model>str_begin.sjwz){
 313   3                      fun_sj1(sjp_wz2);
 314   3                      fun_startdj(mot_dj3,-100);
 315   3                      fun_delay(str_cod.sj1zjw,del_ms);
 316   3                  }
 317   2                  else{//要去的地方在上面，向上走
 318   3                      fun_sj1(sjp_wz3);
 319   3                      fun_startdj(mot_dj3,100);
 320   3                      fun_delay(str_cod.sj1zjw,del_ms);
 321   3                  }
 322   2                  break;
 323   2              case sjp_wz3://升降位置3
 324   2                  if(par_model>str_begin.sjwz)
 325   2                      fun_startdj(mot_dj3,-100);
 326   2                  else
 327   2                      fun_startdj(mot_dj3,100);
 328   2                  fun_select(sel_58);
 329   2                  fun_delay(50,del_ms);
 330   2                  while(1){
 331   3                      while(in_wz3==1);
 332   3                      fun_delay(str_cod.sj1bzw,del_ms);
 333   3                      if(in_wz3==0)
 334   3                          break;
 335   3                  }
 336   2                  break;
 337   2              case sjp_wz34:
 338   2                  if(par_model>str_begin.sjwz){
 339   3                      fun_sj1(sjp_wz3);
 340   3                      fun_startdj(mot_dj3,-100);
 341   3                      fun_delay(str_cod.sj1zjw,del_ms);
 342   3                  }
 343   2                  else{//要去的地方在上面，向上走
 344   3                      fun_sj1(sjp_wz4);
 345   3                      fun_startdj(mot_dj3,100);
 346   3                      fun_delay(str_cod.sj1zjw,del_ms);
 347   3                  }
 348   2                  break;
 349   2              case sjp_wz4://升降位置4
 350   2                  if(par_model>str_begin.sjwz)
 351   2                      fun_startdj(mot_dj3,-100);
 352   2                  else
 353   2                      fun_startdj(mot_dj3,100);
 354   2                  fun_select(sel_58);
 355   2                  fun_delay(50,del_ms);
 356   2                  while(1){
 357   3                      while(in_wz4==1);
 358   3                      fun_delay(str_cod.sj1bzw,del_ms);
 359   3                      if(in_wz4==0)
 360   3                          break;
 361   3                  }
 362   2                  break;
 363   2              case sjp_wz45:
 364   2                  if(par_model>str_begin.sjwz){
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 7   

 365   3                      fun_sj1(sjp_wz4);
 366   3                      fun_startdj(mot_dj3,-100);
 367   3                      fun_delay(str_cod.sj1zjw,del_ms);
 368   3                  }
 369   2                  else{//要去的地方在上面，向上走
 370   3                      fun_startdj(mot_dj3,100);
 371   3                      fun_delay(str_cod.sj1zjw,del_ms);
 372   3                  }
 373   2                  break;
 374   2              case sjp_wz5://升降位置5
 375   2                  fun_startdj(mot_dj3,-100);
 376   2                  fun_select(sel_912);
 377   2                  fun_delay(50,del_ms);
 378   2                  while(1){//要去的地方比较靠下,向下走                
 379   3                      while(in_wz5==1);
 380   3                      fun_delay(20,del_ms);
 381   3                      if(in_wz5==0){
 382   4                          fun_delay(str_cod.sj1bzw,del_ms);
 383   4                          break;
 384   4                      }
 385   3                  }
 386   2                  break;
 387   2              default:
 388   2                  break;
 389   2          }
 390   1          fun_stop(mot_dj3);
 391   1          str_begin.sjwz=par_model;//存储运行结果
 392   1      }//升降单步运动
 393          void fun_py1(enum varENU_tra par_model){
 394   1          if(str_begin.pywz==par_model)
 395   1              return;
 396   1          switch(par_model){
 397   2              case tra_q://前平移(没有电机的呢个方向)
 398   2                  while(1){
 399   3                      fun_startdj(mot_dj2,100);
 400   3                      while(in_qpy==1);
 401   3                      fun_delay(20,del_ms);
 402   3                      if(in_qpy==0){
 403   4                          fun_delay(20,del_ms);
 404   4                          break;
 405   4                      }
 406   3                  }
 407   2                  break;
 408   2              case tra_kq:
 409   2                  switch(str_begin.pywz){
 410   3                      case tra_q:
 411   3                          fun_startdj(mot_dj2,-100);
 412   3                          fun_delay(str_cod.py1qkq,del_ms);
 413   3                          break;
 414   3                      case tra_z:
 415   3                          fun_startdj(mot_dj2,100);
 416   3                          fun_delay(str_cod.py1kqz,del_ms);
 417   3                          break;
 418   3                      case tra_kh:
 419   3                          fun_startdj(mot_dj2,100);
 420   3                          fun_delay(str_cod.py1kqkh,del_ms);
 421   3                          break;
 422   3                      case tra_h:
 423   3                          fun_startdj(mot_dj2,100);
 424   3                          fun_delay(str_cod.py1kqh,del_ms);
 425   3                          break;
 426   3                  }
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 8   

 427   2                  break;
 428   2              case tra_z:
 429   2                  switch(str_begin.pywz){
 430   3                      case tra_q:
 431   3                          fun_startdj(mot_dj2,-100);
 432   3                          fun_delay(str_cod.py1qz,del_ms);
 433   3                          break;
 434   3                      case tra_kq:
 435   3                          fun_startdj(mot_dj2,-100);
 436   3                          fun_delay(str_cod.py1kqz,del_ms);
 437   3                          break;
 438   3                      case tra_kh:
 439   3                          fun_startdj(mot_dj2,100);
 440   3                          fun_delay(str_cod.py1zkh,del_ms);
 441   3                          break;
 442   3                      case tra_h:
 443   3                          fun_startdj(mot_dj2,100);
 444   3                          fun_delay(str_cod.py1zh,del_ms);
 445   3                          break;
 446   3                  }
 447   2                  break;
 448   2              case tra_kh:
 449   2                  switch(str_begin.pywz){
 450   3                      case tra_q:
 451   3                          fun_startdj(mot_dj2,-100);
 452   3                          fun_delay(str_cod.py1qkh,del_ms);
 453   3                          break;
 454   3                      case tra_kq:
 455   3                          fun_startdj(mot_dj2,-100);
 456   3                          fun_delay(str_cod.py1kqkh,del_ms);
 457   3                          break;
 458   3                      case tra_z:
 459   3                          fun_startdj(mot_dj2,-100);
 460   3                          fun_delay(str_cod.py1zkh,del_ms);
 461   3                          break;
 462   3                      case tra_h:
 463   3                          fun_startdj(mot_dj2,100);
 464   3                          fun_delay(str_cod.py1khh,del_ms);
 465   3                          break;
 466   3                  }
 467   2                  break;
 468   2              case tra_h://后平移(有电机的呢个方向)
 469   2                  while(1){
 470   3                      fun_startdj(mot_dj2,-100);
 471   3                      while(in_hpy==1);
 472   3                      fun_delay(20,del_ms);
 473   3                      if(in_hpy==0){
 474   4                          fun_delay(20,del_ms);
 475   4                          break;
 476   4                      }
 477   3                  }
 478   2                  break;
 479   2              default:
 480   2                  break;
 481   2          }
 482   1          fun_stop(mot_dj2);
 483   1          str_begin.pywz=par_model;//存储运行结果
 484   1      }//平移单步运动
 485          void fun_hz1(enum varENU_dir par_model){
 486   1          fun_select(sel_912);
 487   1          switch(par_model){
 488   2              case dir_up://回转至前方
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 9   

 489   2                  switch(str_begin.hzfx){
 490   3                      case dir_down://现在在下方
 491   3                          fun_startdj(mot_dj4,-100);
 492   3                          fun_delay(1,del_s);
 493   3                          while(1){
 494   4                              while(in_hz==1);
 495   4                              fun_delay(25,del_ms);
 496   4                              if(in_hz==0)
 497   4                                  break;
 498   4                          }
 499   3                          while(1){
 500   4                              while(in_hz==0);
 501   4                              fun_delay(25,del_ms);
 502   4                              if(in_hz==1)
 503   4                                  break;
 504   4                          }
 505   3                          while(1){
 506   4                              while(in_hz==1);
 507   4                              fun_delay(25,del_ms);
 508   4                              if(in_hz==0)
 509   4                                  break;
 510   4                          }
 511   3                          break;
 512   3                      case dir_left://现在在左边
 513   3                          fun_startdj(mot_dj4,100);
 514   3                          fun_delay(1,del_s);
 515   3                          while(1){
 516   4                              while(in_hz==1);
 517   4                              fun_delay(25,del_ms);
 518   4                              if(in_hz==0)
 519   4                                  break;
 520   4                          }
 521   3                          break;
 522   3                      case dir_right://现在在右边
 523   3                          fun_startdj(mot_dj4,-100);
 524   3                          fun_delay(1,del_s);
 525   3                          while(1){
 526   4                              while(in_hz==1);
 527   4                              fun_delay(25,del_ms);
 528   4                              if(in_hz==0)
 529   4                                  break;
 530   4                          }
 531   3                          break;
 532   3                      default:
 533   3                          break;
 534   3                  }
 535   2                  break;
 536   2              case dir_down://要去下面
 537   2                  switch(str_begin.hzfx){
 538   3                      case dir_up://现在在上面
 539   3                          fun_startdj(mot_dj4,100);
 540   3                          fun_delay(1,del_s);
 541   3                          while(1){
 542   4                              while(in_hz==1);
 543   4                              fun_delay(25,del_ms);
 544   4                              if(in_hz==0)
 545   4                                  break;
 546   4                          }
 547   3                          while(1){
 548   4                              while(in_hz==0);
 549   4                              fun_delay(25,del_ms);
 550   4                              if(in_hz==1)
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 10  

 551   4                                  break;
 552   4                          }
 553   3                          while(1){
 554   4                              while(in_hz==1);
 555   4                              fun_delay(25,del_ms);
 556   4                              if(in_hz==0)
 557   4                                  break;
 558   4                          }
 559   3                          break;
 560   3                      case dir_left://现在在左面
 561   3                          fun_startdj(mot_dj4,-100);
 562   3                          fun_delay(1,del_s);
 563   3                          while(1){
 564   4                              while(in_hz==1);
 565   4                              fun_delay(25,del_ms);
 566   4                              if(in_hz==0)
 567   4                                  break;
 568   4                          }
 569   3                          break;
 570   3                      case dir_right://现在在右面
 571   3                          fun_startdj(mot_dj4,100);
 572   3                          fun_delay(1,del_s);
 573   3                          while(1){
 574   4                              while(in_hz==1);
 575   4                              fun_delay(25,del_ms);
 576   4                              if(in_hz==0)
 577   4                                  break;
 578   4                          }
 579   3                          break;
 580   3                      default:
 581   3                          break;
 582   3                  }
 583   2                  break;
 584   2              case dir_left://要去左边
 585   2                  switch(str_begin.hzfx){
 586   3                      case dir_up://现在在上面
 587   3                          fun_startdj(mot_dj4,-100);
 588   3                          fun_delay(1,del_s);
 589   3                          while(1){
 590   4                              while(in_hz==1);
 591   4                              fun_delay(25,del_ms);
 592   4                              if(in_hz==0)
 593   4                                  break;
 594   4                          }
 595   3                          break;
 596   3                      case dir_down://现在在下面
 597   3                          fun_startdj(mot_dj4,100);
 598   3                          fun_delay(1,del_s);
 599   3                          while(1){
 600   4                              while(in_hz==1);
 601   4                              fun_delay(25,del_ms);
 602   4                              if(in_hz==0)
 603   4                                  break;
 604   4                          }
 605   3                          break;
 606   3                      case dir_right://现在在右面
 607   3                          fun_startdj(mot_dj4,-100);
 608   3                          fun_delay(1,del_s);
 609   3                          while(1){
 610   4                              while(in_hz==1);
 611   4                              fun_delay(25,del_ms);
 612   4                              if(in_hz==0)
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 11  

 613   4                                  break;
 614   4                          }
 615   3                          while(1){
 616   4                              while(in_hz==0);
 617   4                              fun_delay(25,del_ms);
 618   4                              if(in_hz==1)
 619   4                                  break;
 620   4                          }
 621   3                          while(1){
 622   4                              while(in_hz==1);
 623   4                              fun_delay(25,del_ms);
 624   4                              if(in_hz==0){
 625   5                                  break;
 626   5                              }
 627   4                          }
 628   3                          break;
 629   3                      default:
 630   3                          break;
 631   3                  }
 632   2                  break;
 633   2              case dir_right://要去右面
 634   2                  switch(str_begin.hzfx){
 635   3                      case dir_up://现在在前面
 636   3                          fun_startdj(mot_dj4,100);
 637   3                          fun_delay(1,del_s);
 638   3                          while(1){
 639   4                              while(in_hz==1);
 640   4                              fun_delay(25,del_ms);
 641   4                              if(in_hz==0)
 642   4                                  break;
 643   4                          }
 644   3                          break;
 645   3                      case dir_down://现在在下面
 646   3                          fun_startdj(mot_dj4,-100);
 647   3                          fun_delay(1,del_s);
 648   3                          while(1){
 649   4                              while(in_hz==1);
 650   4                              fun_delay(25,del_ms);
 651   4                              if(in_hz==0)
 652   4                                  break;
 653   4                          }
 654   3                          break;
 655   3                      case dir_left://现在在左面
 656   3                          fun_startdj(mot_dj4,100);
 657   3                          fun_delay(1,del_s);
 658   3                          while(1){
 659   4                              while(in_hz==1);
 660   4                              fun_delay(25,del_ms);
 661   4                              if(in_hz==0)
 662   4                                  break;
 663   4                          }
 664   3                          while(1){
 665   4                              while(in_hz==0);
 666   4                              fun_delay(25,del_ms);
 667   4                              if(in_hz==1)
 668   4                                  break;
 669   4                          }
 670   3                          while(1){
 671   4                              while(in_hz==1);
 672   4                              fun_delay(25,del_ms);
 673   4                              if(in_hz==0){
 674   5                                  break;
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 12  

 675   5                              }
 676   4                          }
 677   3                          break;
 678   3                      default:
 679   3                          break;
 680   3                  }
 681   2                  break;
 682   2              default:
 683   2                  break;
 684   2          }
 685   1          fun_stop(mot_dj4);
 686   1          str_begin.hzfx=par_model;//存储运行结果
 687   1      }//回转单步运动
 688          void fun_sj2(char par_value){
 689   1          switch(par_value){
 690   2              case 1:
 691   2                  fun_sj1(sjp_wz2);
 692   2                  break;
 693   2              case 2:
 694   2                  fun_sj1(sjp_wz3);
 695   2                  break;
 696   2              case 3:
 697   2                  fun_sj1(sjp_wz4);
 698   2                  break;
 699   2              case 4:
 700   2                  fun_sj1(sjp_wz5);
 701   2                  break;
 702   2              default:
 703   2                  fun_sj1(sjp_wz1);
 704   2                  break;
 705   2          }
 706   1      }//状态的升降单步,用来配合自动抓件
 707          void fun_pyhz2(enum varENU_tra par_py,enum varENU_dir par_hz){
 708   1          if(str_begin.hzfx!=par_hz){
 709   2              // fun_py1(tra_z);
 710   2              switch(par_hz){//启动回转,在位则不启动
 711   3                  case dir_up://回转至前方
 712   3                      switch(str_begin.hzfx){
 713   4                          case dir_down://现在在下方
 714   4                              fun_startdj(mot_dj4,-100);
 715   4                              break;
 716   4                          case dir_left://现在在左边
 717   4                              fun_startdj(mot_dj4,100);
 718   4                              break;
 719   4                          case dir_right://现在在右边
 720   4                              fun_startdj(mot_dj4,-100);
 721   4                              break;
 722   4                          default:
 723   4                              break;
 724   4                      }
 725   3                      break;
 726   3                  case dir_down://要去下面
 727   3                      switch(str_begin.hzfx){
 728   4                          case dir_up://现在在上面
 729   4                              fun_startdj(mot_dj4,100);
 730   4                              break;
 731   4                          case dir_left://现在在左面
 732   4                              fun_startdj(mot_dj4,-100);
 733   4                              break;
 734   4                          case dir_right://现在在右面
 735   4                              fun_startdj(mot_dj4,100);
 736   4                              break;
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 13  

 737   4                          default:
 738   4                              break;
 739   4                      }
 740   3                      break;
 741   3                  case dir_left://要去左边
 742   3                      switch(str_begin.hzfx){
 743   4                          case dir_up://现在在上面
 744   4                              fun_startdj(mot_dj4,-100);
 745   4                              break;
 746   4                          case dir_down://现在在下面
 747   4                              fun_startdj(mot_dj4,100);
 748   4                              break;
 749   4                          case dir_right://现在在右面
 750   4                              fun_startdj(mot_dj4,-100);
 751   4                              break;
 752   4                          default:
 753   4                              break;
 754   4                      }
 755   3                      break;
 756   3                  case dir_right://要去右面
 757   3                      switch(str_begin.hzfx){
 758   4                          case dir_up://现在在前面
 759   4                              fun_startdj(mot_dj4,100);
 760   4                              break;
 761   4                          case dir_down://现在在下面
 762   4                              fun_startdj(mot_dj4,-100);
 763   4                              break;
 764   4                          case dir_left://现在在左面
 765   4                              fun_startdj(mot_dj4,100);
 766   4                              break;
 767   4                          default:
 768   4                              break;
 769   4                      }
 770   3                      break;
 771   3                  default:
 772   3                      break;
 773   3              }
 774   2              fun_delay(1,del_s);
 775   2              fun_py1(par_py);
 776   2              fun_select(sel_912);
 777   2              switch(par_hz){
 778   3                  case dir_up://回转至前方
 779   3                      switch(str_begin.hzfx){
 780   4                          case dir_down://现在在下方
 781   4                              while(1){
 782   5                                  while(in_hz==1);
 783   5                                  fun_delay(25,del_ms);
 784   5                                  if(in_hz==0)
 785   5                                      break;
 786   5                              }
 787   4                              while(1){
 788   5                                  while(in_hz==0);
 789   5                                  fun_delay(1,del_s);
 790   5                                  if(in_hz==1)
 791   5                                      break;
 792   5                              }
 793   4                              while(1){
 794   5                                  while(in_hz==1);
 795   5                                  fun_delay(25,del_ms);
 796   5                                  if(in_hz==0)
 797   5                                      break;
 798   5                              }
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 14  

 799   4                              break;
 800   4                          case dir_left://现在在左边
 801   4                              while(1){
 802   5                                  while(in_hz==1);
 803   5                                  fun_delay(25,del_ms);
 804   5                                  if(in_hz==0)
 805   5                                      break;
 806   5                              }
 807   4                              break;
 808   4                          case dir_right://现在在右边
 809   4                              while(1){
 810   5                                  while(in_hz==1);
 811   5                                  fun_delay(25,del_ms);
 812   5                                  if(in_hz==0)
 813   5                                      break;
 814   5                              }
 815   4                              break;
 816   4                          default:
 817   4                              break;
 818   4                      }
 819   3                      break;
 820   3                  case dir_down://要去下面
 821   3                      switch(str_begin.hzfx){
 822   4                          case dir_up://现在在上面
 823   4                              while(1){
 824   5                                  while(in_hz==1);
 825   5                                  fun_delay(25,del_ms);
 826   5                                  if(in_hz==0)
 827   5                                      break;
 828   5                              }
 829   4                              while(1){
 830   5                                  while(in_hz==0);
 831   5                                  fun_delay(1,del_s);
 832   5                                  if(in_hz==1)
 833   5                                      break;
 834   5                              }
 835   4                              while(1){
 836   5                                  while(in_hz==1);
 837   5                                  fun_delay(25,del_ms);
 838   5                                  if(in_hz==0)
 839   5                                      break;
 840   5                              }
 841   4                              break;
 842   4                          case dir_left://现在在左面
 843   4                              while(1){
 844   5                                  while(in_hz==1);
 845   5                                  fun_delay(25,del_ms);
 846   5                                  if(in_hz==0)
 847   5                                      break;
 848   5                              }
 849   4                              break;
 850   4                          case dir_right://现在在右面
 851   4                              while(1){
 852   5                                  while(in_hz==1);
 853   5                                  fun_delay(25,del_ms);
 854   5                                  if(in_hz==0)
 855   5                                      break;
 856   5                              }
 857   4                              break;
 858   4                          default:
 859   4                              break;
 860   4                      }
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 15  

 861   3                      break;
 862   3                  case dir_left://要去左边
 863   3                      switch(str_begin.hzfx){
 864   4                          case dir_up://现在在上面
 865   4                              while(1){
 866   5                                  while(in_hz==1);
 867   5                                  fun_delay(25,del_ms);
 868   5                                  if(in_hz==0)
 869   5                                      break;
 870   5                              }
 871   4                              break;
 872   4                          case dir_down://现在在下面
 873   4                              while(1){
 874   5                                  while(in_hz==1);
 875   5                                  fun_delay(25,del_ms);
 876   5                                  if(in_hz==0)
 877   5                                      break;
 878   5                              }
 879   4                              break;
 880   4                          case dir_right://现在在右面
 881   4                              while(1){
 882   5                                  while(in_hz==1);
 883   5                                  fun_delay(25,del_ms);
 884   5                                  if(in_hz==0)
 885   5                                      break;
 886   5                              }
 887   4                              while(1){
 888   5                                  while(in_hz==0);
 889   5                                  fun_delay(1,del_s);
 890   5                                  if(in_hz==1)
 891   5                                      break;
 892   5                              }
 893   4                              while(1){
 894   5                                  while(in_hz==1);
 895   5                                  fun_delay(25,del_ms);
 896   5                                  if(in_hz==0){
 897   6                                      break;
 898   6                                  }
 899   5                              }
 900   4                              break;
 901   4                          default:
 902   4                              break;
 903   4                      }
 904   3                      break;
 905   3                  case dir_right://要去右面
 906   3                      switch(str_begin.hzfx){
 907   4                          case dir_up://现在在前面
 908   4                              while(1){
 909   5                                  while(in_hz==1);
 910   5                                  fun_delay(25,del_ms);
 911   5                                  if(in_hz==0)
 912   5                                      break;
 913   5                              }
 914   4                              break;
 915   4                          case dir_down://现在在下面
 916   4                              while(1){
 917   5                                  while(in_hz==1);
 918   5                                  fun_delay(25,del_ms);
 919   5                                  if(in_hz==0)
 920   5                                      break;
 921   5                              }
 922   4                              break;
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 16  

 923   4                          case dir_left://现在在左面
 924   4                              while(1){
 925   5                                  while(in_hz==1);
 926   5                                  fun_delay(25,del_ms);
 927   5                                  if(in_hz==0)
 928   5                                      break;
 929   5                              }
 930   4                              while(1){
 931   5                                  while(in_hz==0);
 932   5                                  fun_delay(1,del_s);
 933   5                                  if(in_hz==1)
 934   5                                      break;
 935   5                              }
 936   4                              while(1){
 937   5                                  while(in_hz==1);
 938   5                                  fun_delay(25,del_ms);
 939   5                                  if(in_hz==0){
 940   6                                      break;
 941   6                                  }
 942   5                              }
 943   4                              break;
 944   4                          default:
 945   4                              break;
 946   4                      }
 947   3                      break;
 948   3                  default:
 949   3                      break;
 950   3              }
 951   2              fun_stop(mot_dj4);
 952   2              str_begin.hzfx=par_hz;//存储回转位置
 953   2          }
 954   1          else
 955   1              fun_py1(par_py);
 956   1      }//回转单步运动,用来配合自动抓件
 957          void fun_planezt(uc par_model){
 958   1          switch(par_model){
 959   2              case 0:
 960   2                  fun_pyhz2(tra_h,dir_left);
 961   2                  break;
 962   2              case 1:
 963   2                  fun_pyhz2(tra_kh,dir_left);
 964   2                  break;
 965   2              case 2:
 966   2                  fun_pyhz2(tra_kq,dir_left);
 967   2                  break;
 968   2              case 3:
 969   2                  fun_pyhz2(tra_q,dir_left);
 970   2                  break;
 971   2              case 4:
 972   2                  fun_pyhz2(tra_q,dir_right);
 973   2                  break;
 974   2              case 5:
 975   2                  fun_pyhz2(tra_kq,dir_right);
 976   2                  break;
 977   2              case 6:
 978   2                  fun_pyhz2(tra_kh,dir_right);
 979   2                  break;
 980   2              case 7:
 981   2                  fun_pyhz2(tra_h,dir_right);
 982   2                  break;
 983   2          }
 984   1      }//水平面位置状态,用来配合自动抓件
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 17  

 985          void fun_mptline(uc par_num,uc par_sd,enum varENU_dir par_model){
 986   1          bit loc_flag=0;
 987   1          ui loc_xh=str_cod.mlinerqd/(0.5*(par_sd*par_sd+par_sd));
 988   1          uc loc_con;
 989   1          uc loc_l=par_sd,loc_r=par_sd;
 990   1          for(loc_con=1;loc_con<par_sd;fun_delay(loc_xh,del_ms)){//确定路程的软启动程序
 991   2              loc_r=loc_l=loc_con++;//恢复默认参数
 992   2              if(in_ls3){//纠偏
 993   3                  loc_l*=0.9;
 994   3                  loc_r*=1.1;
 995   3              }
 996   2              if(in_ls6){
 997   3                  loc_l*=1.1;
 998   3                  loc_r*=0.9;
 999   3              }  
1000   2              if(in_ls2){
1001   3                  loc_l*=0.8;
1002   3                  loc_r*=1.2;
1003   3              }
1004   2              if(in_ls7){
1005   3                  loc_l*=1.2;
1006   3                  loc_r*=0.8;
1007   3              }
1008   2              if(in_ls1){
1009   3                  loc_l*=0.7;
1010   3                  loc_r*=1.3;
1011   3              }
1012   2              if(in_ls8){
1013   3                  loc_l*=1.3;
1014   3                  loc_r*=0.7;
1015   3              }
1016   2              fun_startdj(mot_r,loc_r);
1017   2              fun_startdj(mot_l,loc_l);
1018   2          }
1019   1          loc_con=0;
1020   1          while(1){
1021   2              if(((in_ls1)&&(in_ls7))||((in_ls2)&&(in_ls8)))
1022   2                  loc_flag=1;
1023   2              else if(loc_flag==1){
1024   3                  loc_con++;
1025   3                  loc_flag=0;
1026   3                  if(loc_con>=par_num){
1027   4                      if(par_model!=dir_up){
1028   5                          if(par_model==dir_left){//左转
1029   6                              fun_startdj(mot_r,par_sd);
1030   6                              fun_startdj(mot_l,-10);
1031   6                              fun_delay(500,del_ms);
1032   6                              while(1){
1033   7                                  while(!in_ls4||!in_ls5);
1034   7                                  fun_delay(100,del_us);
1035   7                                  if(in_ls4&&in_ls5){
1036   8                                      fun_stop(mot_rl);
1037   8                                      return;
1038   8                                  }
1039   7                              }
1040   6                          }
1041   5                          else if(par_model==dir_right){
1042   6                              fun_startdj(mot_l,par_sd);
1043   6                              fun_startdj(mot_r,-10);
1044   6                              fun_delay(500,del_ms);
1045   6                              while(1){
1046   7                                  while(!in_ls4||!in_ls5);
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 18  

1047   7                                  fun_delay(100,del_us);
1048   7                                  if(in_ls4&&in_ls5){
1049   8                                      fun_stop(mot_rl);
1050   8                                      return;
1051   8                                  }
1052   7                              }
1053   6                          }
1054   5                      }
1055   4                      else{
1056   5                          for(loc_con=par_sd;loc_con>0;fun_delay(loc_xh,del_ms)){//确定路程的软启动程
             -
1057   6                              loc_r=loc_l=loc_con--;//恢复默认参数
1058   6                              if(in_ls3){//纠偏
1059   7                                  loc_l*=0.9;
1060   7                                  loc_r*=1.1;
1061   7                              }
1062   6                              if(in_ls6){
1063   7                                  loc_l*=1.1;
1064   7                                  loc_r*=0.9;
1065   7                              }  
1066   6                              if(in_ls2){
1067   7                                  loc_l*=0.8;
1068   7                                  loc_r*=1.2;
1069   7                              }
1070   6                              if(in_ls7){
1071   7                                  loc_l*=1.2;
1072   7                                  loc_r*=0.8;
1073   7                              }
1074   6                              if(in_ls1){
1075   7                                  loc_l*=0.7;
1076   7                                  loc_r*=1.3;
1077   7                              }
1078   6                              if(in_ls8){
1079   7                                  loc_l*=1.3;
1080   7                                  loc_r*=0.7;
1081   7                              }
1082   6                              fun_startdj(mot_r,loc_r);
1083   6                              fun_startdj(mot_l,loc_l);
1084   6                          }
1085   5                          fun_stop(mot_rl);
1086   5                          return;
1087   5                      }
1088   4                  }
1089   3              }
1090   2              loc_r=loc_l=par_sd;
1091   2              if(in_ls3){//纠偏
1092   3                  loc_l*=0.9;
1093   3                  loc_r*=1.1;
1094   3              }
1095   2              if(in_ls6){
1096   3                  loc_l*=1.1;
1097   3                  loc_r*=0.9;
1098   3              }  
1099   2              if(in_ls2){
1100   3                  loc_l*=0.8;
1101   3                  loc_r*=1.2;
1102   3              }
1103   2              if(in_ls7){
1104   3                  loc_l*=1.2;
1105   3                  loc_r*=0.8;
1106   3              }
1107   2              if(in_ls1){
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 19  

1108   3                  loc_l*=0.7;
1109   3                  loc_r*=1.3;
1110   3              }
1111   2              if(in_ls8){
1112   3                  loc_l*=1.3;
1113   3                  loc_r*=0.7;
1114   3              }
1115   2              fun_startdj(mot_l,loc_l);//更新电机参数
1116   2              fun_startdj(mot_r,loc_r);
1117   2          }
1118   1      }//主函数普通巡线
1119          void fun_stope2prom(){
1120   1          IAP_CONTR = 0;                  //关闭IAP功能
1121   1          IAP_CMD = 0;                    //清除命令
1122   1          IAP_TRIG = 0;                   //清除触发寄存器
1123   1          IAP_ADDRH = 0x80;               //数据指针指向非EEPROM区
1124   1          IAP_ADDRL = 0;                  //清除IAP地址
1125   1      }//关闭EEPROM功能(IapIdle)
1126          uc fun_reade2prom(ui par_add){
1127   1          uc loc_dat;                     //数据缓冲区
1128   1          IAP_CONTR = 0x83;               //打开EEPROM功能,设置等待时间
1129   1          IAP_CMD = 1;                    //设置EEPROM读命令
1130   1          IAP_ADDRL = par_add;            //设置EEPROM地址低八位
1131   1          IAP_ADDRH = par_add >> 8;       //设置EEPROM地址高八位
1132   1          IAP_TRIG = 0x5a;                //触发
1133   1          IAP_TRIG = 0xa5;                //再次触发
1134   1          fun_delay(10,del_us);           //稍等一会儿
1135   1          loc_dat = IAP_DATA;             //读出EEPROM中的数据
1136   1          fun_stope2prom();               //关闭EEPROM功能
1137   1          return loc_dat;                 //返回读取结果
1138   1      }//读取EEPROM数据
1139          void fun_writee2prom(ui par_add,uc par_dat){
1140   1          IAP_CONTR = 0x83;               //打开EEPROM功能,设置等待时间
1141   1          IAP_CMD = 2;                    //设置EEPROM写入命令
1142   1          IAP_ADDRL = par_add;            //设置EEPROM地址低八位
1143   1          IAP_ADDRH = par_add >> 8;       //设置EEPROM地址高八位
1144   1          IAP_DATA = par_dat;             //写入数据
1145   1          IAP_TRIG = 0x5a;                //触发
1146   1          IAP_TRIG = 0xa5;                //再次触发
1147   1          fun_delay(10,del_us);           //稍等一会儿
1148   1          fun_stope2prom();               //关闭EEPROM功能
1149   1      }//写EEPROM数据
1150          void fun_cleane2prom(ui par_add){
1151   1          IAP_CONTR = 0x83;               //打开EEPROM功能,设置等待时间
1152   1          IAP_CMD = 3;                    //设置EEPROM擦除命令
1153   1          IAP_ADDRL = par_add;            //设置EEPROM地址低八位
1154   1          IAP_ADDRH = par_add >> 8;       //设置EEPROM地址高八位
1155   1          IAP_TRIG = 0x5a;                //触发
1156   1          IAP_TRIG = 0xa5;                //再次触发
1157   1          fun_delay(10,del_us);           //稍等一会儿
1158   1          fun_stope2prom();               //关闭EEPROM功能
1159   1      }//清除EEPROM数据
1160          void fun_calibration(){
1161   1          // fun_sj1(sjp_wz1);//升到最上位
1162   1          fun_py1(tra_q);//移动到最前端
1163   1          fun_py1(tra_h);//移动到最后端
1164   1          def_timer0start//开始定时器
1165   1          fun_py1(tra_q);//移动到前端并计时
1166   1          fun_py1(tra_h);//移动到后端
1167   1          def_timer0stop//停止定时器
1168   1          var_timer0*=0.39;
1169   1          str_cod.py1zh=str_cod.py1qz=var_timer0*0.5;
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 20  

1170   1          str_cod.py1qkh=str_cod.py1kqh=var_timer0*0.75;
1171   1          str_cod.py1qkq=str_cod.py1khh=var_timer0*0.25;
1172   1          str_cod.py1kqz=str_cod.py1zkh=var_timer0*0.25;
1173   1          str_cod.py1kqkh=var_timer0*0.5;
1174   1          var_timer0=0;
1175   1      }//自动校准参数
1176          void fun_port(){
1177   1          PCON|=0x80;       //使能波特率倍速位SMOD
1178   1          SCON=0x50;        //8位数据,可变波特率
1179   1          AUXR|=0x04;       //独立波特率发生器时钟为Fosc,即1T
1180   1          BRT=0xD9;     //设定独立波特率发生器重装值
1181   1          AUXR|=0x01;       //串口1选择独立波特率发生器为波特率发生器
1182   1          AUXR|=0x10;       //启动独立波特率发生器
1183   1          TI=1;//打开串口传输功能
1184   1      }//串口初始化
1185          void fun_zhuajian(ul par_04,ul par_37){
1186   1          xdata uc loc_data[8][5][2];//三维数组,8个区,5个高度
1187   1          xdata uc loc_high[8];//8个高度
1188   1          xdata uc loc_xh1=0,loc_xh2=0;//两个循环
1189   1      
1190   1          memset(loc_data,0,sizeof(loc_data));//清空数组
1191   1          memset(loc_high,0,sizeof(loc_high));//清空数组
1192   1          //起始区件号
1193   1          loc_data[0][1][0]=(par_04/10000000)%10;//传入形参:区0的第1号件件号(最高位)
1194   1          loc_data[0][2][0]=(par_04/1000000)%10;//传入形参:区0的第2号件件号
1195   1          loc_data[0][3][0]=(par_04/100000)%10;//传入形参:区0的第3号件件号
1196   1          loc_data[0][4][0]=(par_04/10000)%10;//传入形参:区0的第4号件件号(最低位)
1197   1          loc_data[4][1][0]=(par_04/1000)%10;//传入形参:区4的第1号件件号(最高位)
1198   1          loc_data[4][2][0]=(par_04/100)%10;//传入形参:区4的第2号件件号
1199   1          loc_data[4][3][0]=(par_04/10)%10;//传入形参:区4的第3号件件号
1200   1          loc_data[4][4][0]=par_04%10;//传入形参:区4的第4号件件号(最低位)
1201   1          //目的区件号
1202   1          loc_data[3][1][0]=(par_37/10000000)%10;//传入形参:区0的第1号件件号(最高位)
1203   1          loc_data[3][2][0]=(par_37/1000000)%10;//传入形参:区0的第2号件件号
1204   1          loc_data[3][3][0]=(par_37/100000)%10;//传入形参:区0的第3号件件号
1205   1          loc_data[3][4][0]=(par_37/10000)%10;//传入形参:区0的第4号件件号(最低位)
1206   1          loc_data[7][1][0]=(par_37/1000)%10;//传入形参:区4的第1号件件号(最高位)
1207   1          loc_data[7][2][0]=(par_37/100)%10;//传入形参:区4的第2号件件号
1208   1          loc_data[7][3][0]=(par_37/10)%10;//传入形参:区4的第3号件件号
1209   1          loc_data[7][4][0]=par_37%10;//传入形参:区4的第4号件件号(最低位)
1210   1          //目的次序
1211   1          loc_data[3][1][1]=1;//标准次序:区3的第1号目的次序号(最高位)
1212   1          loc_data[3][2][1]=2;//标准次序:区3的第2号目的次序号
1213   1          loc_data[3][3][1]=3;//标准次序:区3的第3号目的次序号
1214   1          loc_data[3][4][1]=4;//标准次序:区3的第4号目的次序号(最低位)
1215   1          loc_data[7][1][1]=5;//标准次序:区7的第1号目的次序号(最高位)
1216   1          loc_data[7][2][1]=6;//标准次序:区7的第2号目的次序号
1217   1          loc_data[7][3][1]=7;//标准次序:区7的第3号目的次序号
1218   1          loc_data[7][4][1]=8;//标准次序:区7的第4号目的次序号(最低位)
1219   1          //根据形参统一次序
1220   1          for(loc_xh1=4;loc_xh1>0;loc_xh1--){
1221   2              if((loc_data[0][loc_xh1][0]==loc_data[3][1][0])&&(loc_data[0][loc_xh1][0]!=0))
1222   2                  loc_data[0][loc_xh1][1]=loc_data[3][1][1];
1223   2              else if((loc_data[0][loc_xh1][0]==loc_data[3][2][0])&&(loc_data[0][loc_xh1][0]!=0))
1224   2                  loc_data[0][loc_xh1][1]=loc_data[3][2][1];
1225   2              else if((loc_data[0][loc_xh1][0]==loc_data[3][3][0])&&(loc_data[0][loc_xh1][0]!=0))
1226   2                  loc_data[0][loc_xh1][1]=loc_data[3][3][1];
1227   2              else if((loc_data[0][loc_xh1][0]==loc_data[3][4][0])&&(loc_data[0][loc_xh1][0]!=0))
1228   2                  loc_data[0][loc_xh1][1]=loc_data[3][4][1];
1229   2              else if((loc_data[0][loc_xh1][0]==loc_data[7][1][0])&&(loc_data[0][loc_xh1][0]!=0))
1230   2                  loc_data[0][loc_xh1][1]=loc_data[7][1][1];
1231   2              else if((loc_data[0][loc_xh1][0]==loc_data[7][2][0])&&(loc_data[0][loc_xh1][0]!=0))
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 21  

1232   2                  loc_data[0][loc_xh1][1]=loc_data[7][2][1];
1233   2              else if((loc_data[0][loc_xh1][0]==loc_data[7][3][0])&&(loc_data[0][loc_xh1][0]!=0))
1234   2                  loc_data[0][loc_xh1][1]=loc_data[7][3][1];
1235   2              else if((loc_data[0][loc_xh1][0]==loc_data[7][4][0])&&(loc_data[0][loc_xh1][0]!=0))
1236   2                  loc_data[0][loc_xh1][1]=loc_data[7][4][1];
1237   2      
1238   2              if((loc_data[4][loc_xh1][0]==loc_data[3][1][0])&&(loc_data[4][loc_xh1][0]!=0))
1239   2                  loc_data[4][loc_xh1][1]=loc_data[3][1][1];
1240   2              else if((loc_data[4][loc_xh1][0]==loc_data[3][2][0])&&(loc_data[4][loc_xh1][0]!=0))
1241   2                  loc_data[4][loc_xh1][1]=loc_data[3][2][1];
1242   2              else if((loc_data[4][loc_xh1][0]==loc_data[3][3][0])&&(loc_data[4][loc_xh1][0]!=0))
1243   2                  loc_data[4][loc_xh1][1]=loc_data[3][3][1];
1244   2              else if((loc_data[4][loc_xh1][0]==loc_data[3][4][0])&&(loc_data[4][loc_xh1][0]!=0))
1245   2                  loc_data[4][loc_xh1][1]=loc_data[3][4][1];
1246   2              else if((loc_data[4][loc_xh1][0]==loc_data[7][1][0])&&(loc_data[4][loc_xh1][0]!=0))
1247   2                  loc_data[4][loc_xh1][1]=loc_data[7][1][1];
1248   2              else if((loc_data[4][loc_xh1][0]==loc_data[7][2][0])&&(loc_data[4][loc_xh1][0]!=0))
1249   2                  loc_data[4][loc_xh1][1]=loc_data[7][2][1];
1250   2              else if((loc_data[4][loc_xh1][0]==loc_data[7][3][0])&&(loc_data[4][loc_xh1][0]!=0))
1251   2                  loc_data[4][loc_xh1][1]=loc_data[7][3][1];
1252   2              else if((loc_data[4][loc_xh1][0]==loc_data[7][4][0])&&(loc_data[4][loc_xh1][0]!=0))
1253   2                  loc_data[4][loc_xh1][1]=loc_data[7][4][1];
1254   2          }
1255   1          //清空形参表(实际件序)
1256   1          for(loc_xh1=0;loc_xh1<=7;loc_xh1++)
1257   1              for(loc_xh2=0;loc_xh2<=4;loc_xh2++)
1258   1                  loc_data[loc_xh1][loc_xh2][0]=0;
1259   1          for(loc_xh1=0;loc_xh1<=4;loc_xh1++){
1260   2              loc_data[0][loc_xh1][0]=loc_data[0][loc_xh1][1];
1261   2              loc_data[4][loc_xh1][0]=loc_data[4][loc_xh1][1];
1262   2          }//转移04的序号
1263   1          for(loc_xh1=0;loc_xh1<=4;loc_xh1++){
1264   2              loc_data[0][loc_xh1][1]=0;
1265   2              loc_data[1][loc_xh1][1]=0;
1266   2              loc_data[2][loc_xh1][1]=0;
1267   2              loc_data[4][loc_xh1][1]=0;
1268   2              loc_data[5][loc_xh1][1]=0;
1269   2              loc_data[6][loc_xh1][1]=0;
1270   2          }//目的区除了3.7区全部清零
1271   1          for(loc_xh1=0;loc_xh1<=7;loc_xh1++){
1272   2              loc_high[loc_xh1]=4;//默认为没有件
1273   2              for(loc_xh2=0;loc_xh2<=4;loc_xh2++){//5个高度的循环
1274   3                  if(loc_data[loc_xh1][loc_xh2][0]!=0){//如果放了件了
1275   4                      loc_high[loc_xh1]=loc_xh2-1;//记录这个区最高空闲位置
1276   4                      break;//继续区的循环
1277   4                  }
1278   3              }
1279   2          }//8个区的循环
1280   1      
1281   1          fun_sj1(sjp_wz1);
1282   1          fun_sz1(han_s);
1283   1          if((str_begin.hzfx==dir_up)||(str_begin.hzfx==dir_down))//不在左右位转到左位
1284   1              fun_planezt(0);
1285   1      
1286   1          while(1){
1287   2              if(str_begin.hzfx==dir_left){
1288   3                  if((loc_data[0][loc_high[0]+1][0]==loc_data[3][loc_high[3]][1])&&(loc_high[0]<4)){
1289   4                      MSG("0 --> 3")
1290   4                      fun_sj2(fun_min(4,loc_high[0],loc_high[1],loc_high[2],loc_high[3]));//上升到0123最高
             -
1291   4                      fun_planezt(0);//平面状态0
1292   4                      fun_sj2(loc_high[0]+1);//下降到区0最高位
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 22  

1293   4                      fun_sz1(han_j);//抓件
1294   4                      fun_sj2(//上升到123最高位或向上一个格
1295   4                          loc_high[0]<fun_min(3,loc_high[1],loc_high[2],loc_high[3])-1?
1296   4                          loc_high[0]:fun_min(3,loc_high[1],loc_high[2],loc_high[3])-1);
1297   4                      fun_planezt(3);//平面状态3
1298   4                      fun_sj2(loc_high[3]);//下降到区3最高位
1299   4                      fun_sz1(han_s);//松件
1300   4      
1301   4                      loc_data[3][loc_high[3]][0]=loc_data[0][loc_high[0]+1][0];//件已经从0区拿到了3区
1302   4                      loc_data[0][loc_high[0]+1][0]=0;//0区木有了
1303   4                      loc_high[0]++;//更新区0最高位
1304   4                      loc_high[3]--;//更新区3最高位
1305   4                  }//0 --> 3
1306   3                  else if((loc_data[0][loc_high[0]+1][0]==loc_data[7][loc_high[7]][1])&&(loc_high[0]<4)){
1307   4                      MSG("0 --> 7")
1308   4                      fun_sj2(fun_min(4,loc_high[0],loc_high[1],loc_high[2],loc_high[3]));//上升到0123最高
             -
1309   4                      fun_planezt(0);//平面状态0
1310   4                      fun_sj2(loc_high[0]+1);//下降到区0最高位
1311   4                      fun_sz1(han_j);//抓件
1312   4                      fun_sj2(//上升到167最高位或向上一个格
1313   4                          loc_high[0]<fun_min(3,loc_high[1],loc_high[6],loc_high[7])-1?
1314   4                          loc_high[0]:fun_min(3,loc_high[1],loc_high[6],loc_high[7])-1);
1315   4                      fun_planezt(7);//平面状态7
1316   4                      fun_sj2(loc_high[7]);//下降到区7最高位
1317   4                      fun_sz1(han_s);//松件
1318   4      
1319   4                      loc_data[7][loc_high[7]][0]=loc_data[0][loc_high[0]+1][0];//件已经从0区拿到了7区
1320   4                      loc_data[0][loc_high[0]+1][0]=0;//0区木有了
1321   4                      loc_high[0]++;//更新区0最高位
1322   4                      loc_high[7]--;//更新区7最高位
1323   4                  }//0 --> 7
1324   3                  else if((loc_data[2][loc_high[2]+1][0]==loc_data[3][loc_high[3]][1])&&(loc_high[2]<4)){
1325   4                      MSG("2 --> 3")
1326   4                      fun_sj2(fun_min(4,loc_high[0],loc_high[1],loc_high[2],loc_high[3]));//上升到0123最高
             -
1327   4                      fun_planezt(2);//平面状态2
1328   4                      fun_sj2(loc_high[2]+1);//下降到区2最高位
1329   4                      fun_sz1(han_j);//抓件
1330   4                      fun_sj2(//上升到3最高位或向上一个格
1331   4                          loc_high[2]<loc_high[3]-1?
1332   4                          loc_high[2]:loc_high[3]-1);
1333   4                      fun_planezt(3);//平面状态3
1334   4                      fun_sj2(loc_high[3]);//下降到区3最高位
1335   4                      fun_sz1(han_s);//松件
1336   4      
1337   4                      loc_data[3][loc_high[3]][0]=loc_data[2][loc_high[2]+1][0];//件已经从2区拿到了3区
1338   4                      loc_data[2][loc_high[2]+1][0]=0;//2区木有了
1339   4                      loc_high[2]++;//更新区2最高位
1340   4                      loc_high[3]--;//更新区3最高位
1341   4                  }//2 --> 3
1342   3                  else if((loc_data[1][loc_high[1]+1][0]==loc_data[3][loc_high[3]][1])&&(loc_high[3]<4)){
1343   4                      MSG("1 --> 3")
1344   4                      fun_sj2(fun_min(4,loc_high[0],loc_high[1],loc_high[2],loc_high[3]));//上升到0123最高
             -
1345   4                      fun_planezt(1);//平面状态1
1346   4                      fun_sj2(loc_high[1]+1);//下降到区1最高位
1347   4                      fun_sz1(han_j);//抓件
1348   4                      fun_sj2(//上升到23最高位或向上一个格
1349   4                          loc_high[1]<fun_min(2,loc_high[2],loc_high[3])-1?
1350   4                          loc_high[1]:fun_min(2,loc_high[2],loc_high[3])-1);
1351   4                      fun_planezt(3);//平面状态3
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 23  

1352   4                      fun_sj2(loc_high[3]);//下降到区3最高位
1353   4                      fun_sz1(han_s);//松件
1354   4      
1355   4                      loc_data[3][loc_high[3]][0]=loc_data[1][loc_high[1]+1][0];//件已经从1区拿到了3区
1356   4                      loc_data[1][loc_high[1]+1][0]=0;//1区木有了
1357   4                      loc_high[1]++;//更新区1最高位
1358   4                      loc_high[3]--;//更新区3最高位
1359   4                  }//1 --> 3
1360   3                  else{
1361   4                      if(loc_high[0]<3){
1362   5                          if((loc_data[0][loc_high[0]+1][0]==loc_data[3][1][1])||
1363   5                             (loc_data[0][loc_high[0]+1][0]==loc_data[3][2][1])||
1364   5                             (loc_data[0][loc_high[0]+1][0]==loc_data[3][3][1])||
1365   5                             (loc_data[0][loc_high[0]+1][0]==loc_data[3][4][1])){
1366   6                              if(((loc_high[1]>=4)||(loc_data[0][loc_high[0]+1][0]>loc_data[1][loc_high[1]][0]))
             -&&loc_high[1]>2){
1367   7                                  MSG("0 --> 1")
1368   7                                  fun_sj2(fun_min(4,loc_high[0],loc_high[1],loc_high[2],loc_high[3]));//上升
             -0123最高位
1369   7                                  fun_planezt(0);//平面状态0
1370   7                                  fun_sj2(loc_high[0]+1);//下降到区0最高位
1371   7                                  fun_sz1(han_j);//抓件
1372   7                                  fun_sj2(//上升到1最高位或向上一个格
1373   7                                      loc_high[0]<loc_high[1]-1?
1374   7                                      loc_high[0]:loc_high[1]-1);
1375   7                                  fun_planezt(1);//平面状态1
1376   7                                  fun_sj2(loc_high[1]);//下降到区1最高位
1377   7                                  fun_sz1(han_s);//松件
1378   7      
1379   7                                  loc_data[1][loc_high[1]][0]=loc_data[0][loc_high[0]+1][0];//件已经从0区
             -到了1区
1380   7                                  loc_data[0][loc_high[0]+1][0]=0;//0区木有了
1381   7                                  loc_high[0]++;//更新区0最高位
1382   7                                  loc_high[1]--;//更新区1最高位
1383   7                              }//0 --> 1
1384   6                              else if(((loc_high[2]>=4)||(loc_data[0][loc_high[0]+1][0]>loc_data[2][loc_high[2]]
             -[0]))&&loc_high[2]>2){
1385   7                                  MSG("0 --> 2")
1386   7                                  fun_sj2(fun_min(4,loc_high[0],loc_high[1],loc_high[2],loc_high[3]));//上升
             -0123最高位
1387   7                                  fun_planezt(0);//平面状态0
1388   7                                  fun_sj2(loc_high[0]+1);//下降到区0最高位
1389   7                                  fun_sz1(han_j);//抓件
1390   7                                  fun_sj2(//上升到12最高位或向上一个格
1391   7                                      loc_high[0]<fun_min(2,loc_high[1],loc_high[2])-1?
1392   7                                      loc_high[0]:fun_min(2,loc_high[1],loc_high[2])-1);
1393   7                                  fun_planezt(2);//平面状态2
1394   7                                  fun_sj2(loc_high[2]);//下降到区2最高位
1395   7                                  fun_sz1(han_s);//松件
1396   7      
1397   7                                  loc_data[2][loc_high[2]][0]=loc_data[0][loc_high[0]+1][0];//件已经从0区
             -到了2区
1398   7                                  loc_data[0][loc_high[0]+1][0]=0;//0区木有了
1399   7                                  loc_high[0]++;//更新区0最高位
1400   7                                  loc_high[2]--;//更新区2最高位
1401   7                              }//0 --> 2
1402   6                          }//目的地在左边
1403   5                          else if((loc_data[0][loc_high[0]+1][0]==loc_data[7][1][1])||
1404   5                                  (loc_data[0][loc_high[0]+1][0]==loc_data[7][2][1])||
1405   5                                  (loc_data[0][loc_high[0]+1][0]==loc_data[7][3][1])||
1406   5                                  (loc_data[0][loc_high[0]+1][0]==loc_data[7][4][1])){
1407   6                              if(((loc_high[5]>=4)||(loc_data[0][loc_high[0]+1][0]>loc_data[5][loc_high[5]][0]))
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 24  

             -&&loc_high[5]>2){
1408   7                                  MSG("0 --> 5")
1409   7                                  fun_sj2(fun_min(4,loc_high[0],loc_high[1],loc_high[2],loc_high[3]));//上升
             -0123最高位
1410   7                                  fun_planezt(0);//平面状态0
1411   7                                  fun_sj2(loc_high[0]+1);//下降到区0最高位
1412   7                                  fun_sz1(han_j);//抓件
1413   7                                  fun_sj2(//上升到15最高位或向上一个格
1414   7                                      loc_high[0]<fun_min(2,loc_high[1],loc_high[5])-1?
1415   7                                      loc_high[0]:fun_min(2,loc_high[1],loc_high[5])-1);
1416   7                                  fun_planezt(5);//平面状态5
1417   7                                  fun_sj2(loc_high[5]);//下降到区5最高位
1418   7                                  fun_sz1(han_s);//松件
1419   7      
1420   7                                  loc_data[5][loc_high[5]][0]=loc_data[0][loc_high[0]+1][0];//件已经从0区
             -到了5区
1421   7                                  loc_data[0][loc_high[0]+1][0]=0;//0区木有了
1422   7                                  loc_high[0]++;//更新区0最高位
1423   7                                  loc_high[5]--;//更新区5最高位
1424   7                              }//0 --> 5
1425   6                              else if(((loc_high[6]>=4)||(loc_data[0][loc_high[0]+1][0]>loc_data[6][loc_high[6]]
             -[0]))&&loc_high[6]>2){
1426   7                                  MSG("0 --> 6")
1427   7                                  fun_sj2(fun_min(4,loc_high[0],loc_high[1],loc_high[2],loc_high[3]));//上升
             -0123最高位
1428   7                                  fun_planezt(0);//平面状态0
1429   7                                  fun_sj2(loc_high[0]+1);//下降到区0最高位
1430   7                                  fun_sz1(han_j);//抓件
1431   7                                  fun_sj2(//上升到16最高位或向上一个格
1432   7                                      loc_high[0]<fun_min(2,loc_high[1],loc_high[6])-1?
1433   7                                      loc_high[0]:fun_min(2,loc_high[1],loc_high[6])-1);
1434   7                                  fun_planezt(6);//平面状态6
1435   7                                  fun_sj2(loc_high[6]);//下降到区6最高位
1436   7                                  fun_sz1(han_s);//松件
1437   7      
1438   7                                  loc_data[6][loc_high[6]][0]=loc_data[0][loc_high[0]+1][0];//件已经从0区
             -到了6区
1439   7                                  loc_data[0][loc_high[0]+1][0]=0;//0区木有了
1440   7                                  loc_high[0]++;//更新区0最高位
1441   7                                  loc_high[6]--;//更新区6最高位
1442   7                              }//0 --> 6
1443   6                          }//目的地在右边
1444   5                      }//如果区0还有两个件以上
1445   4                      else if(loc_high[2]<3){
1446   5                          if(((loc_high[1]>=4)||(loc_data[2][loc_high[2]+1][0]>loc_data[1][loc_high[1]][0]))&&(l
             -oc_high[1]>2)){
1447   6                              MSG("2 --> 1")
1448   6                              fun_sj2(fun_min(4,loc_high[0],loc_high[1],loc_high[2],loc_high[3]));//上升到012
             -3最高位
1449   6                              fun_planezt(2);//平面状态2
1450   6                              fun_sj2(loc_high[2]+1);//下降到区2最高位
1451   6                              fun_sz1(han_j);//抓件
1452   6                              fun_sj2(//上升到1最高位或向上一个格
1453   6                                  loc_high[2]<loc_high[1]-1?
1454   6                                  loc_high[2]:loc_high[1]-1);
1455   6                              fun_planezt(1);//平面状态1
1456   6                              fun_sj2(loc_high[1]);//下降到区1最高位
1457   6                              fun_sz1(han_s);//松件
1458   6      
1459   6                              loc_data[1][loc_high[1]][0]=loc_data[2][loc_high[2]+1][0];//件已经从2区拿到
             -了1区
1460   6                              loc_data[2][loc_high[2]+1][0]=0;//2区木有了
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 25  

1461   6                              loc_high[2]++;//更新区2最高位
1462   6                              loc_high[1]--;//更新区1最高位
1463   6                          }//2 --> 1
1464   5                          else if(loc_high[0]>=4){
1465   6                              MSG("2 --> 0")
1466   6                              fun_sj2(fun_min(4,loc_high[0],loc_high[1],loc_high[2],loc_high[3]));//上升到012
             -3最高位
1467   6                              fun_planezt(2);//平面状态2
1468   6                              fun_sj2(loc_high[2]+1);//下降到区2最高位
1469   6                              fun_sz1(han_j);//抓件
1470   6                              fun_sj2(//上升到10最高位或向上一个格
1471   6                                  loc_high[2]<fun_min(2,loc_high[1],loc_high[0])-1?
1472   6                                  loc_high[2]:fun_min(2,loc_high[1],loc_high[0])-1);
1473   6                              fun_planezt(0);//平面状态0
1474   6                              fun_sj2(loc_high[0]);//下降到区0最高位
1475   6                              fun_sz1(han_s);//松件
1476   6      
1477   6                              loc_data[0][loc_high[0]][0]=loc_data[2][loc_high[2]+1][0];//件已经从2区拿到
             -了0区
1478   6                              loc_data[2][loc_high[2]+1][0]=0;//2区木有了
1479   6                              loc_high[2]++;//更新区2最高位
1480   6                              loc_high[0]--;//更新区0最高位
1481   6                          }//2 --> 0
1482   5                      }//如果区2有件
1483   4                      else if(loc_high[1]<3){
1484   5                          if(((loc_high[2]>=4)||(loc_data[1][loc_high[1]+1][0]>loc_data[2][loc_high[2]][0]))&&(l
             -oc_high[2]>2)){
1485   6                              MSG("1 --> 2")
1486   6                              fun_sj2(fun_min(4,loc_high[0],loc_high[1],loc_high[2],loc_high[3]));//上升到012
             -3最高位
1487   6                              fun_planezt(1);//平面状态1
1488   6                              fun_sj2(loc_high[1]+1);//下降到区1最高位
1489   6                              fun_sz1(han_j);//抓件
1490   6                              fun_sj2(//上升到2最高位或向上一个格
1491   6                                  loc_high[1]<loc_high[2]-1?
1492   6                                  loc_high[1]:loc_high[2]-1);
1493   6                              fun_planezt(2);//平面状态2
1494   6                              fun_sj2(loc_high[2]);//下降到区2最高位
1495   6                              fun_sz1(han_s);//松件
1496   6      
1497   6                              loc_data[2][loc_high[2]][0]=loc_data[1][loc_high[1]+1][0];//件已经从1区拿到
             -了2区
1498   6                              loc_data[1][loc_high[1]+1][0]=0;//1区木有了
1499   6                              loc_high[1]++;//更新区1最高位
1500   6                              loc_high[2]--;//更新区2最高位
1501   6                          }//1 --> 2
1502   5                          else if(loc_high[0]>=4){
1503   6                              MSG("1 --> 0")
1504   6                              fun_sj2(fun_min(4,loc_high[0],loc_high[1],loc_high[2],loc_high[3]));//上升到012
             -3最高位
1505   6                              fun_planezt(1);//平面状态1
1506   6                              fun_sj2(loc_high[1]+1);//下降到区1最高位
1507   6                              fun_sz1(han_j);//抓件
1508   6                              fun_sj2(//上升到0最高位或向上一个格
1509   6                                  loc_high[1]<loc_high[0]-1?
1510   6                                  loc_high[1]:loc_high[0]-1);
1511   6                              fun_planezt(0);//平面状态0
1512   6                              fun_sj2(loc_high[0]);//下降到区0最高位
1513   6                              fun_sz1(han_s);//松件
1514   6      
1515   6                              loc_data[0][loc_high[0]][0]=loc_data[1][loc_high[1]+1][0];//件已经从1区拿到
             -了0区
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 26  

1516   6                              loc_data[1][loc_high[1]+1][0]=0;//1区木有了
1517   6                              loc_high[1]++;//更新区1最高位
1518   6                              loc_high[0]--;//更新区0最高位
1519   6                          }//1 --> 0
1520   5                      }//如果区1有件
1521   4                  }//不能一次拿出来的话
1522   3                  if((loc_data[3][4][0]==loc_data[3][4][1])&&
1523   3                     (loc_data[3][3][0]==loc_data[3][3][1])&&
1524   3                     (loc_data[3][2][0]==loc_data[3][2][1])&&
1525   3                     (loc_data[3][1][0]==loc_data[3][1][1])&&
1526   3                     (loc_data[0][4][0]==0)&&
1527   3                     (loc_data[0][3][0]==0)&&
1528   3                     (loc_data[0][2][0]==0)&&
1529   3                     (loc_data[0][1][0]==0)){
1530   4                      if((loc_data[7][4][0]==loc_data[7][4][1])&&
1531   4                         (loc_data[7][3][0]==loc_data[7][3][1])&&
1532   4                         (loc_data[7][2][0]==loc_data[7][2][1])&&
1533   4                         (loc_data[7][1][0]==loc_data[7][1][1])&&
1534   4                         (loc_data[4][4][0]==0)&&
1535   4                         (loc_data[4][3][0]==0)&&
1536   4                         (loc_data[4][2][0]==0)&&
1537   4                         (loc_data[4][1][0]==0))
1538   4                          break;
1539   4                      else{
1540   5                          fun_sj1(fun_min(8,loc_high[0],loc_high[1],loc_high[2],loc_high[3],
1541   5                                            loc_high[4],loc_high[5],loc_high[6],loc_high[7]));
1542   5                          fun_hz1(dir_right);
1543   5                      }
1544   4                  }//退出条件
1545   3              }//回转方向在左方
1546   2              else if(str_begin.hzfx==dir_right){
1547   3                  if((loc_data[4][loc_high[4]+1][0]==loc_data[7][loc_high[7]][1])&&(loc_high[4]<4)){
1548   4                      MSG("4 --> 7")
1549   4                      fun_sj2(fun_min(4,loc_high[4],loc_high[5],loc_high[6],loc_high[7]));//上升到4567最高
             -
1550   4                      fun_planezt(4);//平面状态4
1551   4                      fun_sj2(loc_high[4]+1);//下降到区4最高位
1552   4                      fun_sz1(han_j);//抓件
1553   4                      fun_sj2(//上升到567最高位或向上一个格
1554   4                          loc_high[4]<fun_min(3,loc_high[5],loc_high[6],loc_high[7])-1?
1555   4                          loc_high[4]:fun_min(3,loc_high[5],loc_high[6],loc_high[7])-1);
1556   4                      fun_planezt(7);//平面状态7
1557   4                      fun_sj2(loc_high[7]);//下降到区7最高位
1558   4                      fun_sz1(han_s);//松件
1559   4      
1560   4                      loc_data[7][loc_high[7]][0]=loc_data[4][loc_high[4]+1][0];//件已经从4区拿到了7区
1561   4                      loc_data[4][loc_high[4]+1][0]=0;//4区木有了
1562   4                      loc_high[4]++;//更新区4最高位
1563   4                      loc_high[7]--;//更新区7最高位
1564   4                  }//4 --> 7
1565   3                  else if((loc_data[4][loc_high[4]+1][0]==loc_data[3][loc_high[3]][1])&&(loc_high[4]<4)){
1566   4                      MSG("4 --> 3")
1567   4                      fun_sj2(fun_min(4,loc_high[4],loc_high[5],loc_high[6],loc_high[7]));//上升到4567最高
             -
1568   4                      fun_planezt(4);//平面状态4
1569   4                      fun_sj2(loc_high[4]+1);//下降到区4最高位
1570   4                      fun_sz1(han_j);//抓件
1571   4                      fun_sj2(//上升到523最高位或向上一个格
1572   4                          loc_high[4]<fun_min(3,loc_high[5],loc_high[2],loc_high[3])-1?
1573   4                          loc_high[4]:fun_min(3,loc_high[5],loc_high[2],loc_high[3])-1);
1574   4                      fun_planezt(3);//平面状态3
1575   4                      fun_sj2(loc_high[3]);//下降到区3最高位
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 27  

1576   4                      fun_sz1(han_s);//松件
1577   4      
1578   4                      loc_data[3][loc_high[3]][0]=loc_data[4][loc_high[4]+1][0];//件已经从4区拿到了3区
1579   4                      loc_data[4][loc_high[4]+1][0]=0;//4区木有了
1580   4                      loc_high[4]++;//更新区4最高位
1581   4                      loc_high[3]--;//更新区3最高位
1582   4                  }//4 --> 3
1583   3                  else if((loc_data[6][loc_high[6]+1][0]==loc_data[7][loc_high[7]][1])&&(loc_high[6]<4)){
1584   4                      MSG("6 --> 7")
1585   4                      fun_sj2(fun_min(4,loc_high[4],loc_high[5],loc_high[6],loc_high[7]));//上升到4567最高
             -
1586   4                      fun_planezt(6);//平面状态6
1587   4                      fun_sj2(loc_high[6]+1);//下降到区6最高位
1588   4                      fun_sz1(han_j);//抓件
1589   4                      fun_sj2(//上升到7最高位或向上一个格
1590   4                          loc_high[6]<loc_high[7]-1?
1591   4                          loc_high[6]:loc_high[7]-1);
1592   4                      fun_planezt(7);//平面状态7
1593   4                      fun_sj2(loc_high[7]);//下降到区7最高位
1594   4                      fun_sz1(han_s);//松件
1595   4      
1596   4                      loc_data[7][loc_high[7]][0]=loc_data[6][loc_high[6]+1][0];//件已经从6区拿到了7区
1597   4                      loc_data[6][loc_high[6]+1][0]=0;//6区木有了
1598   4                      loc_high[6]++;//更新区6最高位
1599   4                      loc_high[7]--;//更新区7最高位
1600   4                  }//6 --> 7
1601   3                  else if((loc_data[5][loc_high[5]+1][0]==loc_data[7][loc_high[7]][1])&&(loc_high[5]<4)){
1602   4                      MSG("5 --> 7")
1603   4                      fun_sj2(fun_min(4,loc_high[4],loc_high[5],loc_high[6],loc_high[7]));//上升到4567最高
             -
1604   4                      fun_planezt(5);//平面状态5
1605   4                      fun_sj2(loc_high[5]+1);//下降到区5最高位
1606   4                      fun_sz1(han_j);//抓件
1607   4                      fun_sj2(//上升到67最高位或向上一个格
1608   4                          loc_high[5]<fun_min(2,loc_high[6],loc_high[7])-1?
1609   4                          loc_high[5]:fun_min(2,loc_high[6],loc_high[7])-1);
1610   4                      fun_planezt(7);//平面状态7
1611   4                      fun_sj2(loc_high[7]);//下降到区7最高位
1612   4                      fun_sz1(han_s);//松件
1613   4      
1614   4                      loc_data[7][loc_high[7]][0]=loc_data[5][loc_high[5]+1][0];//件已经从5区拿到了7区
1615   4                      loc_data[5][loc_high[5]+1][0]=0;//5区木有了
1616   4                      loc_high[5]++;//更新区5最高位
1617   4                      loc_high[7]--;//更新区7最高位
1618   4                  }//5 --> 7
1619   3                  else{
1620   4                      if(loc_high[4]<3){
1621   5                          if((loc_data[4][loc_high[4]+1][0]==loc_data[7][1][1])||
1622   5                             (loc_data[4][loc_high[4]+1][0]==loc_data[7][2][1])||
1623   5                             (loc_data[4][loc_high[4]+1][0]==loc_data[7][3][1])||
1624   5                             (loc_data[4][loc_high[4]+1][0]==loc_data[7][4][1])){
1625   6                              if(((loc_high[5]>=4)||(loc_data[4][loc_high[4]+1][0]>loc_data[5][loc_high[5]][0]))
             -&&loc_high[5]>2){
1626   7                                  MSG("4 --> 5")
1627   7                                  fun_sj2(fun_min(4,loc_high[4],loc_high[5],loc_high[6],loc_high[7]));//上升
             -4567最高位
1628   7                                  fun_planezt(4);//平面状态4
1629   7                                  fun_sj2(loc_high[4]+1);//下降到区4最高位
1630   7                                  fun_sz1(han_j);//抓件
1631   7                                  fun_sj2(//上升到5最高位或向上一个格
1632   7                                      loc_high[4]<loc_high[5]-1?
1633   7                                      loc_high[4]:loc_high[5]-1);
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 28  

1634   7                                  fun_planezt(5);//平面状态5
1635   7                                  fun_sj2(loc_high[5]);//下降到区5最高位
1636   7                                  fun_sz1(han_s);//松件
1637   7      
1638   7                                  loc_data[5][loc_high[5]][0]=loc_data[4][loc_high[4]+1][0];//件已经从4区
             -到了5区
1639   7                                  loc_data[4][loc_high[4]+1][0]=0;//4区木有了
1640   7                                  loc_high[4]++;//更新区4最高位
1641   7                                  loc_high[5]--;//更新区5最高位
1642   7                              }//4 --> 5
1643   6                              else if(((loc_high[6]>=4)||(loc_data[4][loc_high[4]+1][0]>loc_data[6][loc_high[6]]
             -[0]))&&loc_high[6]>2){
1644   7                                  MSG("4 --> 6")
1645   7                                  fun_sj2(fun_min(4,loc_high[4],loc_high[5],loc_high[6],loc_high[7]));//上升
             -4567最高位
1646   7                                  fun_planezt(4);//平面状态4
1647   7                                  fun_sj2(loc_high[4]+1);//下降到区4最高位
1648   7                                  fun_sz1(han_j);//抓件
1649   7                                  fun_sj2(//上升到56最高位或向上一个格
1650   7                                      loc_high[4]<fun_min(2,loc_high[5],loc_high[6])-1?
1651   7                                      loc_high[4]:fun_min(2,loc_high[5],loc_high[6])-1);
1652   7                                  fun_planezt(6);//平面状态6
1653   7                                  fun_sj2(loc_high[6]);//下降到区6最高位
1654   7                                  fun_sz1(han_s);//松件
1655   7      
1656   7                                  loc_data[6][loc_high[6]][0]=loc_data[4][loc_high[4]+1][0];//件已经从4区
             -到了6区
1657   7                                  loc_data[4][loc_high[4]+1][0]=0;//4区木有了
1658   7                                  loc_high[4]++;//更新区4最高位
1659   7                                  loc_high[6]--;//更新区6最高位
1660   7                              }//4 --> 6
1661   6                          }//目的地在右边
1662   5                          else if((loc_data[4][loc_high[4]+1][0]==loc_data[3][1][1])||
1663   5                                  (loc_data[4][loc_high[4]+1][0]==loc_data[3][2][1])||
1664   5                                  (loc_data[4][loc_high[4]+1][0]==loc_data[3][3][1])||
1665   5                                  (loc_data[4][loc_high[4]+1][0]==loc_data[3][4][1])){
1666   6                              if(((loc_high[1]>=4)||(loc_data[4][loc_high[4]+1][0]>loc_data[1][loc_high[1]][0]))
             -&&loc_high[1]>2){
1667   7                                  MSG("4 --> 1")
1668   7                                  fun_sj2(fun_min(4,loc_high[4],loc_high[5],loc_high[6],loc_high[7]));//上升
             -4567最高位
1669   7                                  fun_planezt(4);//平面状态4
1670   7                                  fun_sj2(loc_high[4]+1);//下降到区4最高位
1671   7                                  fun_sz1(han_j);//抓件
1672   7                                  fun_sj2(//上升到51最高位或向上一个格
1673   7                                      loc_high[4]<fun_min(2,loc_high[5],loc_high[1])-1?
1674   7                                      loc_high[4]:fun_min(2,loc_high[5],loc_high[1])-1);
1675   7                                  fun_planezt(1);//平面状态1
1676   7                                  fun_sj2(loc_high[1]);//下降到区1最高位
1677   7                                  fun_sz1(han_s);//松件
1678   7      
1679   7                                  loc_data[1][loc_high[1]][0]=loc_data[4][loc_high[4]+1][0];//件已经从4区
             -到了1区
1680   7                                  loc_data[4][loc_high[4]+1][0]=0;//4区木有了
1681   7                                  loc_high[4]++;//更新区4最高位
1682   7                                  loc_high[1]--;//更新区1最高位
1683   7                              }//4 --> 1
1684   6                              else if(((loc_high[2]>=4)||(loc_data[4][loc_high[4]+1][0]>loc_data[2][loc_high[2]]
             -[0]))&&loc_high[2]>2){
1685   7                                  MSG("4 --> 2")
1686   7                                  fun_sj2(fun_min(4,loc_high[4],loc_high[5],loc_high[6],loc_high[7]));//上升
             -4567最高位
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 29  

1687   7                                  fun_planezt(4);//平面状态4
1688   7                                  fun_sj2(loc_high[4]+1);//下降到区4最高位
1689   7                                  fun_sz1(han_j);//抓件
1690   7                                  fun_sj2(//上升到523最高位或向上一个格
1691   7                                      loc_high[4]<fun_min(2,loc_high[5],loc_high[2])-1?
1692   7                                      loc_high[4]:fun_min(2,loc_high[5],loc_high[2])-1);
1693   7                                  fun_planezt(2);//平面状态2
1694   7                                  fun_sj2(loc_high[2]);//下降到区2最高位
1695   7                                  fun_sz1(han_s);//松件
1696   7      
1697   7                                  loc_data[2][loc_high[2]][0]=loc_data[4][loc_high[4]+1][0];//件已经从4区
             -到了2区
1698   7                                  loc_data[4][loc_high[4]+1][0]=0;//4区木有了
1699   7                                  loc_high[4]++;//更新区4最高位
1700   7                                  loc_high[2]--;//更新区2最高位
1701   7                              }//4 --> 2
1702   6                          }//目的地在左边
1703   5                      }//如果区4还有两个件以上
1704   4                      else if(loc_high[6]<3){
1705   5                          if(((loc_high[5]>=4)||(loc_data[6][loc_high[6]+1][0]>loc_data[5][loc_high[5]][0]))&&(l
             -oc_high[5]>2)){
1706   6                              MSG("6 --> 5")
1707   6                              fun_sj2(fun_min(4,loc_high[4],loc_high[5],loc_high[6],loc_high[7]));//上升到456
             -7最高位
1708   6                              fun_planezt(6);//平面状态6
1709   6                              fun_sj2(loc_high[6]+1);//下降到区6最高位
1710   6                              fun_sz1(han_j);//抓件
1711   6                              fun_sj2(//上升到5最高位或向上一个格
1712   6                                  loc_high[6]<loc_high[5]-1?
1713   6                                  loc_high[6]:loc_high[5]-1);
1714   6                              fun_planezt(5);//平面状态5
1715   6                              fun_sj2(loc_high[5]);//下降到区5最高位
1716   6                              fun_sz1(han_s);//松件
1717   6      
1718   6                              loc_data[5][loc_high[5]][0]=loc_data[6][loc_high[6]+1][0];//件已经从6区拿到
             -了5区
1719   6                              loc_data[6][loc_high[6]+1][0]=0;//6区木有了
1720   6                              loc_high[6]++;//更新区6最高位
1721   6                              loc_high[5]--;//更新区5最高位
1722   6                          }//6 --> 5
1723   5                          else if(loc_high[4]>=4){
1724   6                              MSG("6 --> 4")
1725   6                              fun_sj2(fun_min(4,loc_high[4],loc_high[5],loc_high[6],loc_high[7]));//上升到456
             -7最高位
1726   6                              fun_planezt(6);//平面状态6
1727   6                              fun_sj2(loc_high[6]+1);//下降到区6最高位
1728   6                              fun_sz1(han_j);//抓件
1729   6                              fun_sj2(//上升到56最高位或向上一个格
1730   6                                  loc_high[6]<fun_min(2,loc_high[5],loc_high[4])-1?
1731   6                                  loc_high[6]:fun_min(2,loc_high[5],loc_high[4])-1);
1732   6                              fun_planezt(4);//平面状态4
1733   6                              fun_sj2(loc_high[4]);//下降到区4最高位
1734   6                              fun_sz1(han_s);//松件
1735   6      
1736   6                              loc_data[4][loc_high[4]][0]=loc_data[6][loc_high[6]+1][0];//件已经从6区拿到
             -了4区
1737   6                              loc_data[6][loc_high[6]+1][0]=0;//6区木有了
1738   6                              loc_high[6]++;//更新区6最高位
1739   6                              loc_high[4]--;//更新区4最高位
1740   6                          }//6 --> 4
1741   5                      }//如果区6有件
1742   4                      else if(loc_high[5]<3){
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 30  

1743   5                          if(((loc_high[6]>=4)||(loc_data[5][loc_high[5]+1][0]>loc_data[6][loc_high[6]][0]))&&(l
             -oc_high[6]>2)){
1744   6                              MSG("5 --> 6")
1745   6                              fun_sj2(fun_min(4,loc_high[4],loc_high[5],loc_high[6],loc_high[7]));//上升到456
             -7最高位
1746   6                              fun_planezt(5);//平面状态5
1747   6                              fun_sj2(loc_high[5]+1);//下降到区5最高位
1748   6                              fun_sz1(han_j);//抓件
1749   6                              fun_sj2(//上升到6最高位或向上一个格
1750   6                                  loc_high[5]<loc_high[6]-1?
1751   6                                  loc_high[5]:loc_high[6]-1);
1752   6                              fun_planezt(6);//平面状态6
1753   6                              fun_sj2(loc_high[6]);//下降到区6最高位
1754   6                              fun_sz1(han_s);//松件
1755   6      
1756   6                              loc_data[6][loc_high[6]][0]=loc_data[5][loc_high[5]+1][0];//件已经从5区拿到
             -了6区
1757   6                              loc_data[5][loc_high[5]+1][0]=0;//5区木有了
1758   6                              loc_high[5]++;//更新区5最高位
1759   6                              loc_high[6]--;//更新区6最高位
1760   6                          }//5 --> 6
1761   5                          else if(loc_high[4]>=4){
1762   6                              MSG("5 --> 4")
1763   6                              fun_sj2(fun_min(4,loc_high[4],loc_high[5],loc_high[6],loc_high[7]));//上升到456
             -7最高位
1764   6                              fun_planezt(5);//平面状态5
1765   6                              fun_sj2(loc_high[5]+1);//下降到区5最高位
1766   6                              fun_sz1(han_j);//抓件
1767   6                              fun_sj2(//上升到4最高位或向上一个格
1768   6                                  loc_high[5]<loc_high[4]-1?
1769   6                                  loc_high[5]:loc_high[4]-1);
1770   6                              fun_planezt(4);//平面状态4
1771   6                              fun_sj2(loc_high[4]);//下降到区4最高位
1772   6                              fun_sz1(han_s);//松件
1773   6      
1774   6                              loc_data[4][loc_high[4]][0]=loc_data[5][loc_high[5]+1][0];//件已经从5区拿到
             -了4区
1775   6                              loc_data[5][loc_high[5]+1][0]=0;//5区木有了
1776   6                              loc_high[5]++;//更新区5最高位
1777   6                              loc_high[4]--;//更新区4最高位
1778   6                          }//5 --> 4
1779   5                      }//如果区5有件
1780   4                  }//不能一次拿出来的话
1781   3                  if((loc_data[7][4][0]==loc_data[7][4][1])&&
1782   3                     (loc_data[7][3][0]==loc_data[7][3][1])&&
1783   3                     (loc_data[7][2][0]==loc_data[7][2][1])&&
1784   3                     (loc_data[7][1][0]==loc_data[7][1][1])&&
1785   3                     (loc_data[4][4][0]==0)&&
1786   3                     (loc_data[4][3][0]==0)&&
1787   3                     (loc_data[4][2][0]==0)&&
1788   3                     (loc_data[4][1][0]==0)){
1789   4                      if((loc_data[3][4][0]==loc_data[3][4][1])&&
1790   4                         (loc_data[3][3][0]==loc_data[3][3][1])&&
1791   4                         (loc_data[3][2][0]==loc_data[3][2][1])&&
1792   4                         (loc_data[3][1][0]==loc_data[3][1][1])&&
1793   4                         (loc_data[0][4][0]==0)&&
1794   4                         (loc_data[0][3][0]==0)&&
1795   4                         (loc_data[0][2][0]==0)&&
1796   4                         (loc_data[0][1][0]==0))
1797   4                          break;
1798   4                      else{
1799   5                          fun_sj1(fun_min(8,loc_high[0],loc_high[1],loc_high[2],loc_high[3],
C51 COMPILER V9.01   8023                                                                  03/18/2015 16:43:06 PAGE 31  

1800   5                                            loc_high[4],loc_high[5],loc_high[6],loc_high[7]));
1801   5                          fun_hz1(dir_left);
1802   5                      }
1803   4                  }//退出条件
1804   3              }//回转方向在右方
1805   2          }//循环执行抓件
1806   1          if(str_begin.hzfx==dir_left){
1807   2              fun_sj1(sjp_wz1);
1808   2              fun_planezt(7);
1809   2              fun_sj1(sjp_wz12);
1810   2          }
1811   1          fun_sz1(han_j);
1812   1      }//自动抓件
1813          uc fun_min(uc par_num,...){
1814   1          va_list loc_argp;//保存参数结构
1815   1          uc loc_xh;//循环
1816   1          uc loc_shu;//当前参数
1817   1          uc loc_min;//最小值
1818   1          va_start(loc_argp,par_num);//loc_argp指向传入的第一个可选参数，par_num是最后一个确
             -的参数
1819   1          loc_min=va_arg(loc_argp,uc);//第一个参数传入
1820   1          for(loc_xh=1;loc_xh<par_num;loc_xh++){//指定循环次数
1821   2              loc_shu=va_arg(loc_argp,uc);//取出一个参数
1822   2              if(loc_shu<loc_min)
1823   2                  loc_min=loc_shu;
1824   2          }
1825   1          va_end(loc_argp);//结束
1826   1          return loc_min;//退出
1827   1      }//求最小?


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  12117    ----
   CONSTANT SIZE    =    197    ----
   XDATA SIZE       =     47      90
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      45
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
