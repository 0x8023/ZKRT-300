C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE 8023
OBJECT MODULE PLACED IN .\output\8023.obj
COMPILER INVOKED BY: D:\MyProgram\keil\C51\BIN\C51.EXE program\8023.c OPTIMIZE(8,SPEED) DEBUG OBJECTEXTEND PRINT(.\8023.
                    -lst) OBJECT(.\output\8023.obj)

line level    source

   1          #include "./output/8023.h"
   2          xdata struct str_state str_begin,str_now,str_next;//分别为:起始状态/当前状态/目标状态
   3          xdata struct str_parameter str_cod={
   4              /*ui str_cod.mlinerqd*/25000,//默认主函数巡线软起动路程为25000
   5              /*ui str_cod.mlineqc*/200,   //默认主函数巡线前冲时间为500毫秒
   6          
   7              /*ui str_cod.sj1bzw*/58,     //升降标准位延时
   8              /*ui str_cod.sj1zjw*/800,    //升降中间位延时
   9          
  10              /*ui str_cod.py1bz*/60,      //fun_py1标准位延时
  11              /*ui str_cod.py1qkq*/700,    //fun_py1前到靠前延时参数
  12              /*ui str_cod.py1kqz*/1000,    //fun_py1靠前到中间延时
  13              /*ui str_cod.py1zkh*/635,    //fun_py1中间到靠后延时
  14              /*ui str_cod.py1khh*/620,    //fun_py1靠后到后延时
  15              /*ui str_cod.py1qz*/1325,    //fun_py1前到中间延时
  16              /*ui str_cod.py1zh*/1250,    //fun_py1中间到后延时
  17              /*ui str_cod.py1kqkh*/1250,  //fun_py1靠前到靠后延时
  18              /*ui str_cod.py1khkq*/1250,  //fun_py1靠后到靠前延时
  19              /*ui str_cod.py1qkh*/1890,   //fun_py1前到靠后延时
  20              /*ui str_cod.py1kqh*/1835,   //fun_py1靠前到后延时
  21          
  22              /*ui str_cod.hz1bz*/20,      //fun_hz1标准位延时
  23          
  24              /*ui turn90;*/500,           //90度转弯屏蔽延时
  25              /*ui turn180;*/2000          //180度转弯屏蔽延时
  26          };
  27          xdata struct str_timerfolline str_tfl;
  28          ul var_timer=0;
  29          void fun_delay(ui par_value,enum varENU_del par_model){
  30   1          ui loc_con=par_value;
  31   1          switch(par_model){
  32   2              case del_us://微秒级延时
  33   2                  #ifdef Debug
                              printf("fun_delay(%d,del_us);\n",par_value);
                          #else
  36   2                      while(loc_con-->0){
  37   3                          _nop_();
  38   3                          _nop_();
  39   3                      }
  40   2                  #endif
  41   2                  return;
  42   2              case del_ms://毫秒级延时
  43   2                  #ifdef Debug
                              printf("fun_delay(%d,del_ms);\n",par_value);
                          #else
  46   2                      while(loc_con-->0){
  47   3                          uc loc_i, loc_j;
  48   3                          _nop_();
  49   3                          _nop_();
  50   3                          loc_i=12;
  51   3                          loc_j=168;
  52   3                          do{
  53   4                              while(--loc_j);
  54   4                          }while(--loc_i);
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 2   

  55   3                      }
  56   2                  #endif
  57   2                  return;
  58   2              case del_s://秒级延时
  59   2                  #ifdef Debug
                              printf("fun_delay(%d,del_s);\n",par_value);
                          #else
  62   2                      while(loc_con-->0){
  63   3                          uc loc_i, loc_j, loc_k;
  64   3                          loc_i=46;
  65   3                          loc_j=153;
  66   3                          loc_k=245;
  67   3                          do{
  68   4                              do{
  69   5                                  while(--loc_k);
  70   5                              }while(--loc_j);
  71   4                          }while(--loc_i);
  72   3                      }
  73   2                  #endif
  74   2                  return;
  75   2              default:return;
  76   2          }
  77   1      }//延时
  78          void fun_timer0init(){
  79   1          #ifdef Debug
                      printf("fun_timer0init();\n");
                  #endif
  82   1          AUXR|=0x80;   //定时器时钟1T模式
  83   1          TMOD&=0xF0;   //定时器模式:16位
  84   1          TMOD|=0x01;   //定时器模式:16位
  85   1          TL0=0x20;     //定时初值:1ms
  86   1          TH0=0xD1;     //定时初值:1ms
  87   1          TF0=0;        //清除TF0标志
  88   1          ET0=1;
  89   1          EA=1;         //开启总中断
  90   1      }//1毫秒定时器0初始化
  91          void fun_timer1init(){
  92   1          #ifdef Debug
                      printf("fun_timer1init();\n");
                  #endif
  95   1          AUXR&=0xBF;     //定时器时钟12T模式
  96   1          TMOD&=0x0F;     //定时器模式:16位
  97   1          TMOD|=0x10;     //定时器模式:16位
  98   1          TL1=0xE0;       //定时初值:20ms
  99   1          TH1=0xB1;       //定时初值:20ms
 100   1          TF1=0;          //清除TF1标志
 101   1          ET1=1;
 102   1          EA=1;           //开启总中断
 103   1      }//20毫秒定时器1初始化
 104          void fun_timer0(){
 105   1          TL0=0x20;
 106   1          TH0=0xD1;//定时器初值恢复至1ms
 107   1          var_timer++;//全局计时器开始计时
 108   1          if(str_tfl.doing==tf_ture)//如果正在移动
 109   1              fun_timermove();//定时器移动
 110   1      }//1毫秒定时器0处理函数
 111          void fun_timer1(){
 112   1          TL1=0xE0;
 113   1          TH1=0xB1;
 114   1      }//20毫秒定时器1处理函数
 115          void fun_wait(){
 116   1          #ifdef Debug
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 3   

                      printf("fun_wait();\n");
                  #else
 119   1              while(in_start==1);
 120   1              fun_delay(20,del_ms);
 121   1              while(in_start==0);
 122   1              fun_delay(256,del_ms);
 123   1          #endif
 124   1      }//等待按键
 125          void fun_pwminit(){
 126   1          #ifdef Debug
                      printf("fun_pwminit();\n");
                  #endif
 129   1          CCON=0x00;//PAC寄存控制器
 130   1          CH=0;//重置PAC计时器
 131   1          CL=0;
 132   1          CMOD=0x08;//不分频
 133   1      }//PWM初始化
 134          void fun_pwmr(uc par_value){
 135   1          CCAP0H=CCAP0L=par_value*25/10;//控制输出的占空比
 136   1          CCAPM0=0X42;//8位PWM输出，无中断
 137   1          PCA_PWM0=0x00;
 138   1      }//右路PWM输出
 139          void fun_pwml(uc par_value){
 140   1          CCAP1H=CCAP1L=par_value*25/10;//控制输出的占空比
 141   1          CCAPM1=0X42;//8位PWM输出，无中断
 142   1          PCA_PWM1=0x00;
 143   1      }//左路PWM输出
 144          void fun_motors(enum varENU_mot par_model,char par_speed){
 145   1          if(par_speed>100)
 146   1              par_speed=100;
 147   1          else if(par_speed<-100)
 148   1              par_speed=-100;//速度最多100,最少-100
 149   1          switch(par_model){
 150   2              case mot_l://左轮电机
 151   2                  if(str_begin.leftsd==par_speed)
 152   2                      return;
 153   2                  else
 154   2                      str_begin.leftsd=par_speed;
 155   2                  if(par_speed==0){
 156   3                      fun_pwml(0);out_pwml=0;
 157   3                  }
 158   2                  else if(par_speed>0){
 159   3                      CR=1;fun_pwml(par_speed);out_pwml=0;
 160   3                  }
 161   2                  else if(par_speed<0){
 162   3                      CR=1;fun_pwml(cabs(par_speed));out_pwml=1;
 163   3                  }
 164   2                  break;
 165   2              case mot_r://右轮电机
 166   2                  if(str_begin.rightsd==par_speed)
 167   2                      return;
 168   2                  else
 169   2                      str_begin.rightsd=par_speed;
 170   2                  if(par_speed==0){
 171   3                      fun_pwmr(0);out_pwmr=0;
 172   3                  }
 173   2                  else if(par_speed>0){
 174   3                      CR=1;fun_pwmr(par_speed);out_pwmr=0;
 175   3                  }
 176   2                  else if(par_speed<0){
 177   3                      CR=1;fun_pwmr(cabs(par_speed));out_pwmr=1;
 178   3                  }
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 4   

 179   2                  break;
 180   2              case mot_rl://左右轮同步
 181   2                  if((str_begin.leftsd==par_speed)&&(str_begin.rightsd==par_speed))
 182   2                      return;
 183   2                  else
 184   2                      str_begin.leftsd=str_begin.rightsd=par_speed;
 185   2                  if(par_speed==0){
 186   3                      CR=0;
 187   3                      fun_pwmr(0);out_pwmr=0;
 188   3                      fun_pwml(0);out_pwml=0;
 189   3                  }
 190   2                  else if(par_speed>0){
 191   3                      CR=1;
 192   3                      fun_pwml(par_speed);out_pwml=0;
 193   3                      fun_pwmr(par_speed);out_pwmr=0;
 194   3                  }
 195   2                  else if(par_speed<0){
 196   3                      CR=1;
 197   3                      fun_pwml(cabs(par_speed));out_pwml=1;
 198   3                      fun_pwmr(cabs(par_speed));out_pwmr=1;
 199   3                  }
 200   2                  break;
 201   2              case mot_sz://正转为抓紧，反转为松开
 202   2                  if(str_begin.szsd==par_speed)
 203   2                      return;
 204   2                  else
 205   2                      str_begin.szsd=par_speed;
 206   2                  if(par_speed==0){
 207   3                      out_motorselect=1;out_dir1=0;out_en1=1;
 208   3                  }
 209   2                  else if(par_speed>0){
 210   3                      out_motorselect=1;out_dir1=1;out_en1=0;
 211   3                  }
 212   2                  else if(par_speed<0){
 213   3                      out_motorselect=1;out_dir1=0;out_en1=0;
 214   3                  }
 215   2                  break;
 216   2              case mot_py://正转是向无电机一方转,反转为向有电机一方转
 217   2                  if(str_begin.pysd==par_speed)
 218   2                      return;
 219   2                  else
 220   2                      str_begin.pysd=par_speed;
 221   2                  if(par_speed==0){
 222   3                      out_motorselect=1;out_dir2=0;out_en2=1;
 223   3                  }
 224   2                  else if(par_speed>0){
 225   3                      out_motorselect=1;out_dir2=1;out_en2=0;
 226   3                  }
 227   2                  else if(par_speed<0){
 228   3                      out_motorselect=1;out_dir2=0;out_en2=0;
 229   3                  }
 230   2                  break;
 231   2              case mot_sj://向上为正转,向下为反转
 232   2                  if(str_begin.sjsd==par_speed)
 233   2                      return;
 234   2                  else
 235   2                      str_begin.sjsd=par_speed;
 236   2                  if(par_speed==0){
 237   3                      out_motorselect=0;out_dir1=0;out_en1=1;
 238   3                  }
 239   2                  else if(par_speed>0){
 240   3                      out_motorselect=0;out_dir1=0;out_en1=0;
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 5   

 241   3                  }
 242   2                  else if(par_speed<0){
 243   3                      out_motorselect=0;out_dir1=1;out_en1=0;
 244   3                  }
 245   2                  break;
 246   2              case mot_hz://顺时针为正转,逆时针为反转
 247   2                  if(str_begin.hzsd==par_speed)
 248   2                      return;
 249   2                  else
 250   2                      str_begin.hzsd=par_speed;
 251   2                  if(par_speed==0){
 252   3                      out_motorselect=0;out_dir2=0;out_en2=1;
 253   3                  }
 254   2                  else if(par_speed>0){
 255   3                      out_motorselect=0;out_dir2=0;out_en2=0;
 256   3                  }
 257   2                  else if(par_speed<0){
 258   3                      out_motorselect=0;out_dir2=1;out_en2=0;
 259   3                  }
 260   2                  break;
 261   2              default:
 262   2                  break;
 263   2          }
 264   1      }//主函数操作电机
 265          void fun_motorsrl(enum varENU_mot par_model,char par_speed){
 266   1          if(par_speed>100)
 267   1              par_speed=100;
 268   1          else if(par_speed<-100)
 269   1              par_speed=-100;//速度最多100,最少-100
 270   1          switch(par_model){
 271   2              case mot_l://左轮电机
 272   2                  if(str_begin.leftsd==par_speed)
 273   2                      return;
 274   2                  else
 275   2                      str_begin.leftsd=par_speed;
 276   2                  if(par_speed==0){
 277   3                      fun_pwml(0);out_pwml=0;
 278   3                  }
 279   2                  else if(par_speed>0){
 280   3                      CR=1;fun_pwml(par_speed);out_pwml=0;
 281   3                  }
 282   2                  else if(par_speed<0){
 283   3                      CR=1;fun_pwml(cabs(par_speed));out_pwml=1;
 284   3                  }
 285   2                  break;
 286   2              case mot_r://右轮电机
 287   2                  if(str_begin.rightsd==par_speed)
 288   2                      return;
 289   2                  else
 290   2                      str_begin.rightsd=par_speed;
 291   2                  if(par_speed==0){
 292   3                      fun_pwmr(0);out_pwmr=0;
 293   3                  }
 294   2                  else if(par_speed>0){
 295   3                      CR=1;fun_pwmr(par_speed);out_pwmr=0;
 296   3                  }
 297   2                  else if(par_speed<0){
 298   3                      CR=1;fun_pwmr(cabs(par_speed));out_pwmr=1;
 299   3                  }
 300   2                  break;
 301   2              case mot_rl://左右轮同步
 302   2                  if((str_begin.leftsd==par_speed)&&(str_begin.rightsd==par_speed))
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 6   

 303   2                      return;
 304   2                  else
 305   2                      str_begin.leftsd=str_begin.rightsd=par_speed;
 306   2                  if(par_speed==0){
 307   3                      CR=0;
 308   3                      fun_pwmr(0);out_pwmr=0;
 309   3                      fun_pwml(0);out_pwml=0;
 310   3                  }
 311   2                  else if(par_speed>0){
 312   3                      CR=1;
 313   3                      fun_pwml(par_speed);out_pwml=0;
 314   3                      fun_pwmr(par_speed);out_pwmr=0;
 315   3                  }
 316   2                  else if(par_speed<0){
 317   3                      CR=1;
 318   3                      fun_pwml(cabs(par_speed));out_pwml=1;
 319   3                      fun_pwmr(cabs(par_speed));out_pwmr=1;
 320   3                  }
 321   2                  break;
 322   2              default:
 323   2                  break;
 324   2          }
 325   1      }//定时器操作左右轮
 326          void fun_sz1(enum varENU_han par_model){
 327   1          if(str_begin.szzt==par_model)
 328   1              return;
 329   1          if(par_model==han_s){//手抓松
 330   2              #ifdef Debug
                          printf("fun_sz1(han_s);\n");
                      #else
 333   2                  fun_motors(mot_sz,-100);
 334   2                  while(in_s==1);
 335   2              #endif
 336   2          }
 337   1          else{//手抓紧
 338   2              #ifdef Debug
                          printf("fun_sz1(han_j);\n");
                      #else
 341   2                  fun_motors(mot_sz,100);
 342   2                  while(in_j==1);
 343   2              #endif
 344   2          }
 345   1              fun_delay(20,del_ms);
 346   1              fun_motors(mot_sz,0);
 347   1          str_begin.szzt=par_model;//存储运行结果
 348   1      }//手抓单步运动
 349          void fun_py1(enum varENU_tra par_model){
 350   1          if(str_begin.pywz==par_model)
 351   1              return;
 352   1          switch(par_model){
 353   2              case tra_q://前平移(没有电机的呢个方向)
 354   2                  #ifdef Debug
                              printf("fun_py1(tra_q);\n");
                          #else
 357   2                      fun_motors(mot_py,100);
 358   2                      while(in_qpy==1);
 359   2                      fun_delay(str_cod.py1bz,del_ms);
 360   2                  #endif
 361   2                      break;
 362   2              case tra_kq://靠前平移
 363   2                  #ifdef Debug
                              printf("fun_py1(tra_kq);\n");
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 7   

                          #else
 366   2                      switch(str_begin.pywz){
 367   3                          case tra_q://现在在前面
 368   3                              fun_motors(mot_py,-100);
 369   3                              fun_delay(str_cod.py1qkq,del_ms);
 370   3                              break;
 371   3                          case tra_z://现在在中间
 372   3                              fun_motors(mot_py,100);
 373   3                              fun_delay(str_cod.py1kqz,del_ms);
 374   3                              break;
 375   3                          case tra_kh://现在在靠后
 376   3                              fun_motors(mot_py,100);
 377   3                              fun_delay(str_cod.py1khkq,del_ms);
 378   3                              break;
 379   3                          case tra_h://现在在后
 380   3                              fun_motors(mot_py,100);
 381   3                              fun_delay(str_cod.py1kqh,del_ms);
 382   3                              break;
 383   3                      }
 384   2                  #endif
 385   2                      break;
 386   2              case tra_z://平移到中间
 387   2                  #ifdef Debug
                              printf("fun_py1(tra_z);\n");
                          #else
 390   2                      switch(str_begin.pywz){
 391   3                          case tra_q://现在在前面
 392   3                              fun_motors(mot_py,-100);
 393   3                              fun_delay(str_cod.py1qz,del_ms);
 394   3                              break;
 395   3                          case tra_kq://现在在靠前
 396   3                              fun_motors(mot_py,-100);
 397   3                              fun_delay(str_cod.py1kqz,del_ms);
 398   3                              break;
 399   3                          case tra_kh://现在在靠后
 400   3                              fun_motors(mot_py,100);
 401   3                              fun_delay(str_cod.py1zkh,del_ms);
 402   3                              break;
 403   3                          case tra_h://现在在后面
 404   3                              fun_motors(mot_py,100);
 405   3                              fun_delay(str_cod.py1zh,del_ms);
 406   3                              break;
 407   3                      }
 408   2                  #endif
 409   2                      break;
 410   2              case tra_kh://平移到靠后
 411   2                  #ifdef Debug
                              printf("fun_py1(tra_kh);\n");
                          #else
 414   2                      switch(str_begin.pywz){
 415   3                          case tra_q://现在在前面
 416   3                              fun_motors(mot_py,-100);
 417   3                              fun_delay(str_cod.py1qkh,del_ms);
 418   3                              break;
 419   3                          case tra_kq://现在在靠前
 420   3                              fun_motors(mot_py,-100);
 421   3                              fun_delay(str_cod.py1kqkh,del_ms);
 422   3                              break;
 423   3                          case tra_z://现在在中间
 424   3                              fun_motors(mot_py,-100);
 425   3                              fun_delay(str_cod.py1zkh,del_ms);
 426   3                              break;
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 8   

 427   3                          case tra_h://现在在后面
 428   3                              fun_motors(mot_py,100);
 429   3                              fun_delay(str_cod.py1khh,del_ms);
 430   3                              break;
 431   3                      }
 432   2                  #endif
 433   2                      break;
 434   2              case tra_h://后平移(有电机的呢个方向)
 435   2                  #ifdef Debug
                              printf("fun_py1(tra_h);\n");
                          #else
 438   2                      fun_motors(mot_py,-100);
 439   2                      while(in_hpy==1);
 440   2                      fun_delay(str_cod.py1bz,del_ms);
 441   2                  #endif
 442   2                      break;
 443   2              default:
 444   2                  break;
 445   2          }
 446   1          fun_motors(mot_py,0);
 447   1          str_begin.pywz=par_model;//存储运行结果
 448   1      }//平移单步运动
 449          void fun_sj1(enum varENU_sjp par_model){
 450   1          if(str_begin.sjwz==par_model)
 451   1             return;
 452   1          switch(par_model){
 453   2              case sjp_1://升降位置1(最上位)
 454   2                  #ifdef Debug
                              printf("fun_sj1(sjp_1);\n");
                          #else
 457   2                      fun_motors(mot_sj,100);
 458   2                      def_select(sel_58);
 459   2                      while(in_wz1==1);
 460   2                      fun_delay(str_cod.sj1bzw,del_ms);
 461   2                  #endif
 462   2                      break;
 463   2              case sjp_12:
 464   2                  #ifdef Debug
                              printf("fun_sj1(sjp_12);\n");
                          #else
 467   2                      if(par_model>str_begin.sjwz){
 468   3                          fun_motors(mot_sj,-100);
 469   3                          fun_delay(str_cod.sj1zjw,del_ms);
 470   3                      }
 471   2                      else{//要去的地方在上面，向上走
 472   3                          fun_sj1(sjp_2);
 473   3                          fun_motors(mot_sj,100);
 474   3                          fun_delay(str_cod.sj1zjw,del_ms);
 475   3                      }
 476   2                  #endif
 477   2                      break;
 478   2              case sjp_2://升降位置2
 479   2                  #ifdef Debug
                              printf("fun_sj1(sjp_2);\n");
                          #else
 482   2                      fun_motors(mot_sj,par_model<str_begin.sjwz?100:-100);
 483   2                      def_select(sel_58);
 484   2                      while(in_wz2==1);
 485   2                      fun_delay(str_cod.sj1bzw,del_ms);
 486   2                  #endif
 487   2                      break;
 488   2              case sjp_23:
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 9   

 489   2                  #ifdef Debug
                              printf("fun_sj1(sjp_23);\n");
                          #else
 492   2                      if(par_model>str_begin.sjwz){
 493   3                          fun_sj1(sjp_2);
 494   3                          fun_motors(mot_sj,-100);
 495   3                          fun_delay(str_cod.sj1zjw,del_ms);
 496   3                      }
 497   2                      else{//要去的地方在上面，向上走
 498   3                          fun_sj1(sjp_3);
 499   3                          fun_motors(mot_sj,100);
 500   3                          fun_delay(str_cod.sj1zjw,del_ms);
 501   3                      }
 502   2                  #endif
 503   2                      break;
 504   2              case sjp_3://升降位置3
 505   2                  #ifdef Debug
                              printf("fun_sj1(sjp_3);\n");
                          #else
 508   2                      fun_motors(mot_sj,par_model<str_begin.sjwz?100:-100);
 509   2                      def_select(sel_58);
 510   2                      while(in_wz3==1);
 511   2                      fun_delay(str_cod.sj1bzw,del_ms);
 512   2                  #endif
 513   2                  break;
 514   2              case sjp_34:
 515   2                  #ifdef Debug
                              printf("fun_sj1(sjp_34);\n");
                          #else
 518   2                      if(par_model>str_begin.sjwz){
 519   3                          fun_sj1(sjp_3);
 520   3                          fun_motors(mot_sj,-100);
 521   3                          fun_delay(str_cod.sj1zjw,del_ms);
 522   3                      }
 523   2                      else{//要去的地方在上面，向上走
 524   3                          fun_sj1(sjp_4);
 525   3                          fun_motors(mot_sj,100);
 526   3                          fun_delay(str_cod.sj1zjw,del_ms);
 527   3                      }
 528   2                  #endif
 529   2                      break;
 530   2              case sjp_4://升降位置4
 531   2                  #ifdef Debug
                              printf("fun_sj1(sjp_4);\n");
                          #else
 534   2                      fun_motors(mot_sj,par_model<str_begin.sjwz?100:-100);
 535   2                      def_select(sel_58);
 536   2                      while(in_wz4==1);
 537   2                      fun_delay(str_cod.sj1bzw,del_ms);
 538   2                  #endif
 539   2                      break;
 540   2              case sjp_45:
 541   2                  #ifdef Debug
                              printf("fun_sj1(sjp_45);\n");
                          #else
 544   2                      if(par_model>str_begin.sjwz){
 545   3                          fun_sj1(sjp_4);
 546   3                          fun_motors(mot_sj,-100);
 547   3                          fun_delay(str_cod.sj1zjw,del_ms);
 548   3                      }
 549   2                      else{//要去的地方在上面，向上走
 550   3                          fun_motors(mot_sj,100);
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 10  

 551   3                          fun_delay(str_cod.sj1zjw,del_ms);
 552   3                      }
 553   2                  #endif
 554   2                      break;
 555   2              case sjp_5://升降位置5
 556   2                  #ifdef Debug
                              printf("fun_sj1(sjp_5);\n");
                          #else
 559   2                      fun_motors(mot_sj,-100);
 560   2                      def_select(sel_912);
 561   2                      while(in_wz5==1);
 562   2                      fun_delay(str_cod.sj1bzw,del_ms);
 563   2                  #endif
 564   2                      break;
 565   2              default:
 566   2                  break;
 567   2          }
 568   1          fun_motors(mot_sj,0);
 569   1          str_begin.sjwz=par_model;//存储运行结果
 570   1      }//升降单步运动
 571          void fun_hz1(enum varENU_dir par_model){
 572   1          if(str_begin.hzfx==par_model)
 573   1              return;
 574   1          def_select(sel_912);
 575   1          switch(par_model){
 576   2              case dir_up://回转至前方
 577   2                  #ifdef Debug
                              printf("fun_hz1(dir_up);\n");
                          #else
 580   2                      switch(str_begin.hzfx){
 581   3                          case dir_down://现在在下方
 582   3                              fun_motors(mot_hz,-100);
 583   3                              fun_delay(1,del_s);
 584   3                              while(in_hz==1);
 585   3                              while(in_hz==0);
 586   3                              while(in_hz==1);
 587   3                              fun_delay(str_cod.hz1bz,del_ms);
 588   3                              break;
 589   3                          case dir_left://现在在左边
 590   3                              fun_motors(mot_hz,100);
 591   3                              fun_delay(1,del_s);
 592   3                              while(in_hz==1);
 593   3                              fun_delay(str_cod.hz1bz,del_ms);
 594   3                              break;
 595   3                          case dir_right://现在在右边
 596   3                              fun_motors(mot_hz,-100);
 597   3                              fun_delay(1,del_s);
 598   3                              while(in_hz==1);
 599   3                              fun_delay(str_cod.hz1bz,del_ms);
 600   3                              break;
 601   3                          default:
 602   3                              break;
 603   3                      }
 604   2                  #endif
 605   2                      break;
 606   2              case dir_down://要去下面
 607   2                  #ifdef Debug
                              printf("fun_hz1(dir_down);\n");
                          #else
 610   2                      switch(str_begin.hzfx){
 611   3                          case dir_up://现在在上面
 612   3                              fun_motors(mot_hz,100);
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 11  

 613   3                              fun_delay(1,del_s);
 614   3                              while(in_hz==1);
 615   3                              while(in_hz==0);
 616   3                              while(in_hz==1);
 617   3                              fun_delay(str_cod.hz1bz,del_ms);
 618   3                              break;
 619   3                          case dir_left://现在在左面
 620   3                              fun_motors(mot_hz,-100);
 621   3                              fun_delay(1,del_s);
 622   3                              while(in_hz==1);
 623   3                              fun_delay(str_cod.hz1bz,del_ms);
 624   3                              break;
 625   3                              break;
 626   3                          case dir_right://现在在右面
 627   3                              fun_motors(mot_hz,100);
 628   3                              fun_delay(1,del_s);
 629   3                              while(in_hz==1);
 630   3                              fun_delay(str_cod.hz1bz,del_ms);
 631   3                              break;
 632   3                          default:
 633   3                              break;
 634   3                      }
 635   2                  #endif
 636   2                      break;
 637   2              case dir_left://要去左边
 638   2                  #ifdef Debug
                              printf("fun_hz1(dir_left);\n");
                          #else
 641   2                      switch(str_begin.hzfx){
 642   3                          case dir_up://现在在上面
 643   3                              fun_motors(mot_hz,-100);
 644   3                              fun_delay(1,del_s);
 645   3                              while(in_hz==1);
 646   3                              fun_delay(str_cod.hz1bz,del_ms);
 647   3                              break;
 648   3                              break;
 649   3                          case dir_down://现在在下面
 650   3                              fun_motors(mot_hz,100);
 651   3                              fun_delay(1,del_s);
 652   3                              while(in_hz==1);
 653   3                              fun_delay(str_cod.hz1bz,del_ms);
 654   3                              break;
 655   3                              break;
 656   3                          case dir_right://现在在右面
 657   3                              fun_motors(mot_hz,-100);
 658   3                              fun_delay(1,del_s);
 659   3                              while(in_hz==1);
 660   3                              while(in_hz==0);
 661   3                              while(in_hz==1);
 662   3                              fun_delay(str_cod.hz1bz,del_ms);
 663   3                              break;
 664   3                          default:
 665   3                              break;
 666   3                      }
 667   2                  #endif
 668   2                      break;
 669   2              case dir_right://要去右面
 670   2                  #ifdef Debug
                              printf("fun_hz1(dir_right);\n");
                          #else
 673   2                      switch(str_begin.hzfx){
 674   3                          case dir_up://现在在前面
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 12  

 675   3                              fun_motors(mot_hz,100);
 676   3                              fun_delay(1,del_s);
 677   3                              while(in_hz==1);
 678   3                              fun_delay(str_cod.hz1bz,del_ms);
 679   3                              break;
 680   3                          case dir_down://现在在下面
 681   3                              fun_motors(mot_hz,-100);
 682   3                              fun_delay(1,del_s);
 683   3                              while(in_hz==1);
 684   3                              fun_delay(str_cod.hz1bz,del_ms);
 685   3                              break;
 686   3                          case dir_left://现在在左面
 687   3                              fun_motors(mot_hz,100);
 688   3                              fun_delay(1,del_s);
 689   3                              while(in_hz==1);
 690   3                              while(in_hz==0);
 691   3                              while(in_hz==1);
 692   3                              fun_delay(str_cod.hz1bz,del_ms);
 693   3                              break;
 694   3                          default:
 695   3                              break;
 696   3                      }
 697   2                  #endif
 698   2                      break;
 699   2              default:
 700   2                  break;
 701   2          }
 702   1          fun_motors(mot_hz,0);
 703   1          str_begin.hzfx=par_model;//存储运行结果
 704   1      }//回转单步运动
 705          void fun_pyhz2(enum varENU_tra par_pymodel,enum varENU_dir par_hzmodel){
 706   1          switch(par_hzmodel){//获取想要到达的回转位置
 707   2              case dir_left://要去左边
 708   2                  switch(str_begin.hzfx){
 709   3                      case dir_right://现在在右边
 710   3                          fun_motors(mot_hz,-100);
 711   3                          break;
 712   3                      case dir_up://现在在上面
 713   3                          fun_motors(mot_hz,-100);
 714   3                          break;
 715   3                      case dir_down://现在在下面
 716   3                          fun_motors(mot_hz,100);
 717   3                          break;
 718   3                      default:
 719   3                          break;
 720   3                  }//获取现在回转所在的位置
 721   2                  break;
 722   2              case dir_right://要去右边
 723   2                  switch(str_begin.hzfx){
 724   3                      case dir_left://现在在左边
 725   3                          fun_motors(mot_hz,100);
 726   3                          break;
 727   3                      case dir_up://现在在上面
 728   3                          fun_motors(mot_hz,100);
 729   3                          break;
 730   3                      case dir_down://现在在下面
 731   3                          fun_motors(mot_hz,-100);
 732   3                          break;
 733   3                      default:
 734   3                          break;
 735   3                  }//获取现在回转所在的位置
 736   2                  break;
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 13  

 737   2              case dir_up://要去上面
 738   2                  switch(str_begin.hzfx){
 739   3                      case dir_left://现在在左边
 740   3                          fun_motors(mot_hz,100);
 741   3                          break;
 742   3                      case dir_right://现在在右边
 743   3                          fun_motors(mot_hz,-100);
 744   3                          break;
 745   3                      case dir_down://现在在下面
 746   3                          fun_motors(mot_hz,-100);
 747   3                          break;
 748   3                      default:
 749   3                          break;
 750   3                  }//获取现在回转所在的位置
 751   2                  break;
 752   2              case dir_down://要去下面
 753   2                  switch(str_begin.hzfx){
 754   3                      case dir_left://现在在左边
 755   3                          fun_motors(mot_hz,-100);
 756   3                          break;
 757   3                      case dir_right://现在在右边
 758   3                          fun_motors(mot_hz,100);
 759   3                          break;
 760   3                      case dir_up://现在在上面
 761   3                          fun_motors(mot_hz,100);
 762   3                          break;
 763   3                      default:
 764   3                          break;
 765   3                  }//获取现在回转所在的位置
 766   2                  break;
 767   2              default:
 768   2                  break;
 769   2          }//获取现在要去的回转位置
 770   1          switch(par_pymodel){
 771   2              case tra_q://前平移(没有电机的呢个方向)
 772   2                  fun_motors(mot_py,100);
 773   2                  while(in_qpy==1);
 774   2                  fun_delay(str_cod.py1bz,del_ms);
 775   2                  break;
 776   2              case tra_kq://靠前
 777   2                  switch(str_begin.pywz){
 778   3                      case tra_q://现在在前面
 779   3                          fun_motors(mot_py,-100);
 780   3                          fun_delay(str_cod.py1qkq,del_ms);
 781   3                          break;
 782   3                      case tra_z://现在在中间
 783   3                          fun_motors(mot_py,100);
 784   3                          fun_delay(str_cod.py1kqz,del_ms);
 785   3                          break;
 786   3                      case tra_kh://现在在靠后
 787   3                          fun_motors(mot_py,100);
 788   3                          fun_delay(str_cod.py1khkq,del_ms);
 789   3                          break;
 790   3                      case tra_h://现在在后面
 791   3                          fun_motors(mot_py,100);
 792   3                          fun_delay(str_cod.py1kqh,del_ms);
 793   3                          break;
 794   3                  }
 795   2                  break;
 796   2              case tra_z://中
 797   2                  switch(str_begin.pywz){
 798   3                      case tra_q://现在在前面
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 14  

 799   3                          fun_motors(mot_py,-100);
 800   3                          fun_delay(str_cod.py1qz,del_ms);
 801   3                          break;
 802   3                      case tra_kq://现在在靠前
 803   3                          fun_motors(mot_py,-100);
 804   3                          fun_delay(str_cod.py1kqz,del_ms);
 805   3                          break;
 806   3                      case tra_kh://现在在靠后
 807   3                          fun_motors(mot_py,100);
 808   3                          fun_delay(str_cod.py1zkh,del_ms);
 809   3                          break;
 810   3                      case tra_h://现在在后面
 811   3                          fun_motors(mot_py,100);
 812   3                          fun_delay(str_cod.py1zh,del_ms);
 813   3                          break;
 814   3                  }
 815   2                  break;
 816   2              case tra_kh://靠后
 817   2                  switch(str_begin.pywz){
 818   3                      case tra_q://现在在前面
 819   3                          fun_motors(mot_py,-100);
 820   3                          fun_delay(str_cod.py1qkh,del_ms);
 821   3                          break;
 822   3                      case tra_kq://现在在靠前
 823   3                          fun_motors(mot_py,-100);
 824   3                          fun_delay(str_cod.py1kqkh,del_ms);
 825   3                          break;
 826   3                      case tra_z://现在在中间
 827   3                          fun_motors(mot_py,-100);
 828   3                          fun_delay(str_cod.py1zkh,del_ms);
 829   3                          break;
 830   3                      case tra_h://现在在后面
 831   3                          fun_motors(mot_py,100);
 832   3                          fun_delay(str_cod.py1khh,del_ms);
 833   3                          break;
 834   3                  }
 835   2                  break;
 836   2              case tra_h://后平移(有电机的呢个方向)
 837   2                  fun_motors(mot_py,-100);
 838   2                  while(in_hpy==1);
 839   2                  fun_delay(str_cod.py1bz,del_ms);
 840   2                  break;
 841   2              default:
 842   2                  break;
 843   2          }//获取现在平移所在的位置
 844   1          fun_motors(mot_py,0);//停止平移动作
 845   1          str_begin.pywz=par_pymodel;//存储运行结果
 846   1          switch(par_hzmodel){//获取想要到达的回转位置
 847   2              case dir_up://回转至前方
 848   2                  switch(str_begin.hzfx){
 849   3                      case dir_down://现在在下方
 850   3                          while(in_hz==1);
 851   3                          while(in_hz==0);
 852   3                          while(in_hz==1);
 853   3                          fun_delay(str_cod.hz1bz,del_ms);
 854   3                          break;
 855   3                      case dir_left://现在在左边
 856   3                          while(in_hz==1);
 857   3                          fun_delay(str_cod.hz1bz,del_ms);
 858   3                          break;
 859   3                      case dir_right://现在在右边
 860   3                          while(in_hz==1);
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 15  

 861   3                          fun_delay(str_cod.hz1bz,del_ms);
 862   3                          break;
 863   3                      default:
 864   3                          break;
 865   3                  }
 866   2                  break;
 867   2              case dir_down://要去下面
 868   2                  switch(str_begin.hzfx){
 869   3                      case dir_up://现在在上面
 870   3                          while(in_hz==1);
 871   3                          while(in_hz==0);
 872   3                          while(in_hz==1);
 873   3                          fun_delay(str_cod.hz1bz,del_ms);
 874   3                          break;
 875   3                      case dir_left://现在在左面
 876   3                          while(in_hz==1);
 877   3                          fun_delay(str_cod.hz1bz,del_ms);
 878   3                          break;
 879   3                          break;
 880   3                      case dir_right://现在在右面
 881   3                          while(in_hz==1);
 882   3                          fun_delay(str_cod.hz1bz,del_ms);
 883   3                          break;
 884   3                      default:
 885   3                          break;
 886   3                  }
 887   2                  break;
 888   2              case dir_left://要去左边
 889   2                  switch(str_begin.hzfx){
 890   3                      case dir_up://现在在上面
 891   3                          while(in_hz==1);
 892   3                          fun_delay(str_cod.hz1bz,del_ms);
 893   3                          break;
 894   3                          break;
 895   3                      case dir_down://现在在下面
 896   3                          while(in_hz==1);
 897   3                          fun_delay(str_cod.hz1bz,del_ms);
 898   3                          break;
 899   3                          break;
 900   3                      case dir_right://现在在右面
 901   3                          while(in_hz==1);
 902   3                          while(in_hz==0);
 903   3                          while(in_hz==1);
 904   3                          fun_delay(str_cod.hz1bz,del_ms);
 905   3                          break;
 906   3                      default:
 907   3                          break;
 908   3                  }
 909   2                  break;
 910   2              case dir_right://要去右面
 911   2                  switch(str_begin.hzfx){
 912   3                      case dir_up://现在在前面
 913   3                          while(in_hz==1);
 914   3                          fun_delay(str_cod.hz1bz,del_ms);
 915   3                          break;
 916   3                      case dir_down://现在在下面
 917   3                          while(in_hz==1);
 918   3                          fun_delay(str_cod.hz1bz,del_ms);
 919   3                          break;
 920   3                      case dir_left://现在在左面
 921   3                          while(in_hz==1);
 922   3                          while(in_hz==0);
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 16  

 923   3                          while(in_hz==1);
 924   3                          fun_delay(str_cod.hz1bz,del_ms);
 925   3                          break;
 926   3                      default:
 927   3                          break;
 928   3                  }
 929   2                  break;
 930   2              default:
 931   2                  break;
 932   2          }//获取现在要去的回转位置
 933   1          fun_motors(mot_hz,0);//停止回转动作
 934   1          str_begin.hzfx=par_hzmodel;//存储运行结果
 935   1      }//平移回转同步运动
 936          void fun_jtjp(){
 937   1          while(1){
 938   2              if((!in_ls1&&!in_ls2&&in_ls4&&in_ls5&&!in_ls7&&!in_ls8)&&((in_ls3&&in_ls6)||(!in_ls3&&!in_ls6))){
 939   3                  fun_delay(10,del_ms);
 940   3                  fun_motors(mot_rl,0);
 941   3                  return;
 942   3              }
 943   2              if(in_ls2||in_ls1){
 944   3                  fun_motors(mot_l,16);
 945   3                  fun_motors(mot_r,-16);
 946   3              }
 947   2              else if(in_ls7||in_ls8){
 948   3                  fun_motors(mot_l,-16);
 949   3                  fun_motors(mot_r,16);
 950   3              }
 951   2              else{
 952   3                  if(!in_ls4){
 953   4                      fun_motors(mot_l,-12);
 954   4                      fun_motors(mot_r,12);
 955   4                  }
 956   3                  else if(!in_ls5){
 957   4                      fun_motors(mot_l,12);
 958   4                      fun_motors(mot_r,-12);
 959   4                  }
 960   3                  else{
 961   4                      if(in_ls6&&!in_ls3){
 962   5                          fun_motors(mot_l,-8);
 963   5                          fun_motors(mot_r,8);
 964   5                      }
 965   4                      if(in_ls3&&!in_ls6){
 966   5                          fun_motors(mot_l,8);
 967   5                          fun_motors(mot_r,-8);
 968   5                      }
 969   4                  }
 970   3              }
 971   2          }
 972   1      }//静态纠偏
 973          void fun_timermove(){
 974   1          static uc loc_con=0;//需要分步做的动作需要用到此静态私有分步标志位
 975   1          int loc_sdl,loc_sdr;//左轮速度和右轮速度的局部变量
 976   1          switch(*str_tfl.run){//选择运行方式
 977   2              case def_end://运行结束
 978   2                  fun_motorsrl(mot_rl,0);//再次停止电机运动
 979   2                  str_tfl.doing=tf_false;//移动结束
 980   2                  memset(str_tfl.step,0,sizeof(str_tfl.step));//清空step数组
 981   2                  str_tfl.run=str_tfl.step;//指针指向step的第一个元素
 982   2                  break;
 983   2              case tfl_line://运行巡线
 984   2                  if(*(str_tfl.run+1)){//如果参数为非0数
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 17  

 985   3                      if((in_ls1||in_ls8)&&(in_ls2&&in_ls3&&in_ls4&&in_ls5&in_ls6&&in_ls7)){//如果中间6个
             -全亮,左右亮任意一个
 986   4                          str_tfl.online=tf_ture;//标志位记录在线
 987   4                          fun_motorsrl(mot_rl,str_tfl.gospeed);//按照常规速度过线
 988   4                      }
 989   3                      else if(str_tfl.online==tf_ture){//如果标志位记录在线,而且不符合在线特征
 990   4                          str_tfl.online=tf_false;//标志位记录不在线
 991   4                          (*(str_tfl.run+1))--;//参数值减1,记录已经走了一条线
 992   4                      }
 993   3                      else{
 994   4                          loc_sdl=loc_sdr=str_tfl.gospeed;//巡线速度为str_tfl.gospeed
 995   4                          if(in_ls1&&!in_ls8){//1亮8不亮
 996   5                              loc_sdl*=0.7;//左减速
 997   5                              loc_sdr*=1.3;//右加速
 998   5                          }//向左转
 999   4                          if(in_ls8&&!in_ls1){//8亮1不亮
1000   5                              loc_sdl*=1.3;//左加速
1001   5                              loc_sdr*=0.7;//右减速
1002   5                          }//向右转
1003   4                          if(in_ls2&&!in_ls7){//2亮7不亮
1004   5                              loc_sdl*=0.8;//左减速
1005   5                              loc_sdr*=1.2;//右加速
1006   5                          }//向左转
1007   4                          if(in_ls7&&!in_ls2){//7亮2不亮
1008   5                              loc_sdl*=1.2;//左加速
1009   5                              loc_sdr*=0.8;//右减速
1010   5                          }//向右转
1011   4                          if(in_ls3&&!in_ls6){//3亮6不亮
1012   5                              loc_sdl*=0.9;//左减速
1013   5                              loc_sdr*=1.1;//右加速
1014   5                          }//向左转
1015   4                          if(in_ls6&&!in_ls3){//6亮3不亮
1016   5                              loc_sdl*=1.1;//左加速
1017   5                              loc_sdr*=0.9;//右减速
1018   5                          }//向右转
1019   4                          fun_motorsrl(mot_r,loc_sdr);
1020   4                          fun_motorsrl(mot_l,loc_sdl);
1021   4                      }
1022   3                  }
1023   2                  else{//如果线走完了
1024   3                      str_tfl.run+=2;//指针指向下一组过程
1025   3                      fun_motorsrl(mot_rl,0);//停止电机运动
1026   3                  }
1027   2                  break;
1028   2              case tfl_turn://运行转弯
1029   2                  switch(loc_con){//分步运行标志位
1030   3                      case 0://第一步
1031   3                          switch(*(str_tfl.run+1)){//获取参数
1032   4                              case tur_r90://右转90
1033   4                                  fun_motorsrl(mot_l,str_tfl.turnspeed);//左轮向前
1034   4                                  fun_motorsrl(mot_r,-str_tfl.turnspeed);//右轮向后
1035   4                                  str_tfl.delay=var_timer+str_cod.turn90;//计时
1036   4                                  break;
1037   4                              case tur_l90://左转90
1038   4                                  fun_motorsrl(mot_l,-str_tfl.turnspeed);//左轮向后
1039   4                                  fun_motorsrl(mot_r,str_tfl.turnspeed);//右轮向前
1040   4                                  str_tfl.delay=var_timer+str_cod.turn90;//计时
1041   4                                  break;
1042   4                              case tur_r180://右转180
1043   4                                  fun_motorsrl(mot_l,str_tfl.turnspeed);//左轮向前
1044   4                                  fun_motorsrl(mot_r,-str_tfl.turnspeed);//右轮向后
1045   4                                  str_tfl.delay=var_timer+str_cod.turn180;//计时
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 18  

1046   4                                  break;
1047   4                              case tur_l180://左转180
1048   4                                  fun_motorsrl(mot_l,-str_tfl.turnspeed);//左轮向后
1049   4                                  fun_motorsrl(mot_r,str_tfl.turnspeed);//左轮向前
1050   4                                  str_tfl.delay=var_timer+str_cod.turn180;//计时
1051   4                                  break;
1052   4                          }
1053   3                          loc_con++;//执行下一步
1054   3                          break;
1055   3                      case 1://第二步
1056   3                          if(str_tfl.delay<=var_timer)//计时时间到
1057   3                              loc_con++;//执行下一步
1058   3                          break;
1059   3                      case 2://第三步
1060   3                          if(in_ls4&&in_ls5){//如果中间两个灯亮
1061   4                              fun_motorsrl(mot_rl,0);//停止电机
1062   4                              str_tfl.run+=2;//指针指向下一组过程
1063   4                              str_tfl.delay=0;//延时计数器归零
1064   4                              loc_con=0;//分步运行标志位归零
1065   4                          }
1066   3                          break;
1067   3                  }
1068   2                  break;
1069   2              case tfl_cache://运行前冲
1070   2                  switch(loc_con){
1071   3                      case 0://第一步
1072   3                          str_tfl.delay=var_timer+((*(str_tfl.run+1))*10);//延时时间(毫秒)为参数的10
             -
1073   3                          loc_con++;//执行下一步
1074   3                          break;
1075   3                      case 1://第二步
1076   3                          if(str_tfl.delay<=var_timer){//计时时间到
1077   4                              fun_motorsrl(mot_rl,0);//停止电机
1078   4                              str_tfl.run+=2;//指针指向下一组过程
1079   4                              str_tfl.delay=0;//延时计数器归零
1080   4                              loc_con=0;//分步运行标志位归零
1081   4                          }
1082   3                          else{
1083   4                              loc_sdl=loc_sdr=str_tfl.cachespeed;//前冲速度为str_tfl.cachespeed
1084   4                              if(in_ls1&&!in_ls8){//1亮8不亮
1085   5                                  loc_sdl*=0.5;//左减速
1086   5                                  loc_sdr*=1.5;//右加速
1087   5                              }//向左转
1088   4                              if(in_ls8&&!in_ls1){//8亮1不亮
1089   5                                  loc_sdl*=1.5;//左加速
1090   5                                  loc_sdr*=0.5;//右减速
1091   5                              }//向右转
1092   4                              if(in_ls2&&!in_ls7){//2亮7不亮
1093   5                                  loc_sdl*=0.7;//左减速
1094   5                                  loc_sdr*=1.3;//右加速
1095   5                              }//向左转
1096   4                              if(in_ls7&&!in_ls2){//7亮2不亮
1097   5                                  loc_sdl*=1.3;//左加速
1098   5                                  loc_sdr*=0.7;//右减速
1099   5                              }//向右转
1100   4                              if(in_ls3&&!in_ls6){//3亮6不亮
1101   5                                  loc_sdl*=0.9;//左减速
1102   5                                  loc_sdr*=1.1;//右加速
1103   5                              }//向左转
1104   4                              if(in_ls6&&!in_ls3){//6亮3不亮
1105   5                                  loc_sdl*=1.1;//左加速
1106   5                                  loc_sdr*=0.9;//右减速
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 19  

1107   5                              }//向右转
1108   4                              fun_motorsrl(mot_r,loc_sdr);
1109   4                              fun_motorsrl(mot_l,loc_sdl);
1110   4                          }
1111   3                          break;
1112   3                  }
1113   2                  break;
1114   2              case tfl_start://运行带加速的前冲
1115   2      
1116   2                  break;
1117   2              case tfl_end://运行带减速的前冲
1118   2      
1119   2                  break;
1120   2          }
1121   1      }//定时器移动
1122          void fun_folline(uc par_con,uc par_speed){
1123   1          uc loc_con=par_con;//巡线条数标志位
1124   1          uc loc_sdr,loc_sdl;//左右轮速度
1125   1          uc loc_online;//在线标志位
1126   1          while(loc_con){
1127   2              if((in_ls1||in_ls8)&&(in_ls2&&in_ls3&&in_ls4&&in_ls5&in_ls6&&in_ls7)){//如果中间6个灯全亮,
             -左右亮任意一个
1128   3                  loc_online=tf_ture;//标志位记录在线
1129   3                  fun_motors(mot_rl,par_speed);//按照常规速度过线
1130   3              }
1131   2              else if(loc_online==tf_ture){//如果标志位记录在线,而且不符合在线特征
1132   3                  loc_online=tf_false;//标志位记录不在线
1133   3                  loc_con--;//参数值减1,记录已经走了一条线
1134   3              }
1135   2              else{
1136   3                  loc_sdr=loc_sdl=par_speed;
1137   3                  if(in_ls1&&!in_ls8){//1亮8不亮
1138   4                      loc_sdl*=0.5;//左减速
1139   4                      loc_sdr*=1.5;//右加速
1140   4                  }//向左转
1141   3                  if(in_ls8&&!in_ls1){//8亮1不亮
1142   4                      loc_sdl*=1.5;//左加速
1143   4                      loc_sdr*=0.5;//右减速
1144   4                  }//向右转
1145   3                  if(in_ls2&&!in_ls7){//2亮7不亮
1146   4                      loc_sdl*=0.7;//左减速
1147   4                      loc_sdr*=1.3;//右加速
1148   4                  }//向左转
1149   3                  if(in_ls7&&!in_ls2){//7亮2不亮
1150   4                      loc_sdl*=1.3;//左加速
1151   4                      loc_sdr*=0.7;//右减速
1152   4                  }//向右转
1153   3                  if(in_ls3&&!in_ls6){//3亮6不亮
1154   4                      loc_sdl*=0.9;//左减速
1155   4                      loc_sdr*=1.1;//右加速
1156   4                  }//向左转
1157   3                  if(in_ls6&&!in_ls3){//6亮3不亮
1158   4                      loc_sdl*=1.1;//左加速
1159   4                      loc_sdr*=0.9;//右减速
1160   4                  }//向右转
1161   3                  fun_motors(mot_r,loc_sdr);
1162   3                  fun_motors(mot_l,loc_sdl);
1163   3                  fun_delay(1,del_ms);
1164   3              }
1165   2          }//如果巡线条数不为0
1166   1          fun_qc(65,40);
1167   1      }//主函数巡线
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 20  

1168          void fun_turn(enum varENU_tur par_model,uc par_speed){
1169   1          switch(par_model){//获取参数
1170   2              case tur_r90://右转90
1171   2                  fun_motors(mot_l,par_speed);//左轮向前
1172   2                  fun_motors(mot_r,-par_speed);//右轮向后
1173   2                  fun_delay(str_cod.turn90,del_ms);//计时
1174   2                  break;
1175   2              case tur_l90://左转90
1176   2                  fun_motors(mot_l,-par_speed);//左轮向后
1177   2                  fun_motors(mot_r,par_speed);//右轮向前
1178   2                  fun_delay(str_cod.turn90,del_ms);//计时
1179   2                  break;
1180   2              case tur_r180://右转180
1181   2                  fun_motors(mot_l,par_speed);//左轮向前
1182   2                  fun_motors(mot_r,-par_speed);//右轮向后
1183   2                  fun_delay(str_cod.turn180,del_ms);//计时
1184   2                  break;
1185   2              case tur_l180://左转180
1186   2                  fun_motors(mot_l,-par_speed);//左轮向后
1187   2                  fun_motors(mot_r,par_speed);//左轮向前
1188   2                  fun_delay(str_cod.turn180,del_ms);//计时
1189   2                  break;
1190   2          }
1191   1          while(!in_ls4||!in_ls5);
1192   1          fun_motors(mot_rl,0);//停止电机
1193   1      }//主函数转弯
1194          void fun_qc(uc par_time,uc par_speed){
1195   1          uc loc_sdr,loc_sdl;//左右轮速度
1196   1          str_tfl.delay=var_timer+par_time*10;//延时时间(毫秒)为参数的10倍
1197   1          while(str_tfl.delay>var_timer){
1198   2              loc_sdr=loc_sdl=par_speed;
1199   2              if(in_ls1&&!in_ls8){//1亮8不亮
1200   3                  loc_sdl*=0.7;//左减速
1201   3                  loc_sdr*=1.3;//右加速
1202   3              }//向左转
1203   2              if(in_ls8&&!in_ls1){//8亮1不亮
1204   3                  loc_sdl*=1.3;//左加速
1205   3                  loc_sdr*=0.7;//右减速
1206   3              }//向右转
1207   2              if(in_ls2&&!in_ls7){//2亮7不亮
1208   3                  loc_sdl*=0.8;//左减速
1209   3                  loc_sdr*=1.2;//右加速
1210   3              }//向左转
1211   2              if(in_ls7&&!in_ls2){//7亮2不亮
1212   3                  loc_sdl*=1.2;//左加速
1213   3                  loc_sdr*=0.8;//右减速
1214   3              }//向右转
1215   2              if(in_ls3&&!in_ls6){//3亮6不亮
1216   3                  loc_sdl*=0.9;//左减速
1217   3                  loc_sdr*=1.1;//右加速
1218   3              }//向左转
1219   2              if(in_ls6&&!in_ls3){//6亮3不亮
1220   3                  loc_sdl*=1.1;//左加速
1221   3                  loc_sdr*=0.9;//右减速
1222   3              }//向右转
1223   2              fun_motors(mot_r,loc_sdr);
1224   2              fun_motors(mot_l,loc_sdl);
1225   2              fun_delay(1,del_ms);
1226   2          }
1227   1          fun_motors(mot_rl,0);//停止电机
1228   1      }//主函数前冲
1229          void fun_stope2prom(){
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 21  

1230   1          IAP_CONTR = 0;                  //关闭IAP功能
1231   1          IAP_CMD = 0;                    //清除命令
1232   1          IAP_TRIG = 0;                   //清除触发寄存器
1233   1          IAP_ADDRH = 0x80;               //数据指针指向非EEPROM区
1234   1          IAP_ADDRL = 0;                  //清除IAP地址
1235   1      }//关闭EEPROM功能(IapIdle)
1236          uc fun_reade2prom(ui par_add){
1237   1          uc loc_dat;                     //数据缓冲区
1238   1          IAP_CONTR = 0x83;               //打开EEPROM功能,设置等待时间
1239   1          IAP_CMD = 1;                    //设置EEPROM读命令
1240   1          IAP_ADDRL = par_add;            //设置EEPROM地址低八位
1241   1          IAP_ADDRH = par_add >> 8;       //设置EEPROM地址高八位
1242   1          IAP_TRIG = 0x5a;                //触发
1243   1          IAP_TRIG = 0xa5;                //再次触发
1244   1          fun_delay(10,del_us);           //稍等一会儿
1245   1          loc_dat = IAP_DATA;             //读出EEPROM中的数据
1246   1          fun_stope2prom();               //关闭EEPROM功能
1247   1          return loc_dat;                 //返回读取结果
1248   1      }//读取EEPROM数据
1249          void fun_writee2prom(ui par_add,uc par_dat){
1250   1          IAP_CONTR = 0x83;               //打开EEPROM功能,设置等待时间
1251   1          IAP_CMD = 2;                    //设置EEPROM写入命令
1252   1          IAP_ADDRL = par_add;            //设置EEPROM地址低八位
1253   1          IAP_ADDRH = par_add >> 8;       //设置EEPROM地址高八位
1254   1          IAP_DATA = par_dat;             //写入数据
1255   1          IAP_TRIG = 0x5a;                //触发
1256   1          IAP_TRIG = 0xa5;                //再次触发
1257   1          fun_delay(10,del_us);           //稍等一会儿
1258   1          fun_stope2prom();               //关闭EEPROM功能
1259   1      }//写EEPROM数据
1260          void fun_cleane2prom(ui par_add){
1261   1          IAP_CONTR = 0x83;               //打开EEPROM功能,设置等待时间
1262   1          IAP_CMD = 3;                    //设置EEPROM擦除命令
1263   1          IAP_ADDRL = par_add;            //设置EEPROM地址低八位
1264   1          IAP_ADDRH = par_add >> 8;       //设置EEPROM地址高八位
1265   1          IAP_TRIG = 0x5a;                //触发
1266   1          IAP_TRIG = 0xa5;                //再次触发
1267   1          fun_delay(10,del_us);           //稍等一会儿
1268   1          fun_stope2prom();               //关闭EEPROM功能
1269   1      }//清除EEPROM数据
1270          void fun_calibration(){
1271   1          // fun_sj1(sjp_1);//升到最上位
1272   1          ul loc_time;
1273   1          fun_py1(tra_q);//移动到最前端
1274   1          fun_py1(tra_h);//移动到最后端
1275   1          loc_time=var_timer;
1276   1          fun_py1(tra_q);//移动到前端并计时
1277   1          fun_py1(tra_h);//移动到后端
1278   1          loc_time=var_timer-loc_time;
1279   1          loc_time*=0.5;
1280   1          str_cod.py1zh=loc_time*0.5;//从后到中间
1281   1          str_cod.py1qz=loc_time*0.5;//从前到中间
1282   1          str_cod.py1qkh=loc_time*0.75;//从前到靠后
1283   1          str_cod.py1kqh=loc_time*0.564;//从靠前到后
1284   1          str_cod.py1qkq=loc_time*0.34;//从前到靠前
1285   1          str_cod.py1khh=loc_time*0.2701;//从后到靠后
1286   1          str_cod.py1kqz=loc_time*0.189;//从靠前到中间
1287   1          str_cod.py1zkh=loc_time*0.20;//从靠后到中间
1288   1          str_cod.py1kqkh=loc_time*0.5;//从靠前到靠后
1289   1          str_cod.py1khkq=loc_time*0.5;//从靠后到靠前
1290   1      }//自动校准平移参数
1291          void fun_port(){
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 22  

1292   1          //19200bps@12.000MHz
1293   1          PCON |= 0x80;       //使能波特率倍速位SMOD
1294   1          SCON = 0x50;        //8位数据,可变波特率
1295   1          AUXR |= 0x04;       //独立波特率发生器时钟为Fosc,即1T
1296   1          BRT = 0xD9;         //设定独立波特率发生器重装值
1297   1          AUXR |= 0x01;       //串口1选择独立波特率发生器为波特率发生器
1298   1          AUXR |= 0x10;       //启动独立波特率发生器
1299   1      }//串口初始化
1300          void fun_test(){
1301   1          fun_sz1(han_j);
1302   1          fun_delay(1,del_s);
1303   1          fun_sz1(han_s);
1304   1          fun_delay(1,del_s);
1305   1          fun_sz1(han_j);
1306   1          fun_delay(1,del_s);
1307   1          fun_sz1(han_s);
1308   1          fun_delay(1,del_s);
1309   1      
1310   1          str_begin.pywz=tra_h;
1311   1          fun_py1(tra_q);
1312   1          fun_delay(1,del_s);
1313   1          fun_py1(tra_h);
1314   1          fun_delay(1,del_s);
1315   1          fun_py1(tra_q);
1316   1          fun_delay(1,del_s);
1317   1          fun_py1(tra_h);
1318   1          fun_delay(1,del_s);
1319   1      
1320   1          fun_sj1(sjp_1);
1321   1          fun_delay(1,del_s);
1322   1          fun_sj1(sjp_2);
1323   1          fun_delay(1,del_s);
1324   1          fun_sj1(sjp_3);
1325   1          fun_delay(1,del_s);
1326   1          fun_sj1(sjp_4);
1327   1          fun_delay(1,del_s);
1328   1          fun_sj1(sjp_5);
1329   1          fun_delay(1,del_s);
1330   1          fun_sj1(sjp_4);
1331   1          fun_delay(1,del_s);
1332   1          fun_sj1(sjp_3);
1333   1          fun_delay(1,del_s);
1334   1          fun_sj1(sjp_2);
1335   1          fun_delay(1,del_s);
1336   1          fun_sj1(sjp_1);
1337   1      
1338   1          str_now.hzfx=str_begin.hzfx;
1339   1          str_begin.hzfx=dir_up;
1340   1          fun_hz1(dir_right);
1341   1          fun_delay(1,del_s);
1342   1          fun_hz1(dir_up);
1343   1          fun_delay(1,del_s);
1344   1          fun_hz1(dir_right);
1345   1          fun_delay(1,del_s);
1346   1          fun_hz1(dir_up);
1347   1          fun_delay(1,del_s);
1348   1          str_begin.hzfx=str_now.hzfx;
1349   1      
1350   1          fun_motors(mot_rl,60);
1351   1          fun_delay(1,del_s);
1352   1          fun_motors(mot_rl,0);
1353   1          fun_delay(1,del_s);
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 23  

1354   1      
1355   1          fun_motors(mot_rl,-60);
1356   1          fun_delay(1,del_s);
1357   1          fun_motors(mot_rl,0);
1358   1          fun_delay(1,del_s);
1359   1      
1360   1          fun_motors(mot_r,40);
1361   1          fun_motors(mot_l,-40);
1362   1          fun_delay(1,del_s);
1363   1          fun_motors(mot_rl,0);
1364   1          fun_delay(1,del_s);
1365   1      
1366   1          fun_motors(mot_r,-40);
1367   1          fun_motors(mot_l,40);
1368   1          fun_delay(1,del_s);
1369   1          fun_motors(mot_rl,0);
1370   1      }//测试程序
1371          uc fun_min(uc par_num,...){
1372   1          va_list loc_argp;//保存参数结构
1373   1          uc loc_min=par_num;//现在的最小值就是第一个
1374   1          uc loc_shu;//当前参数
1375   1          va_start(loc_argp,par_num);//loc_argp指向传入的第一个可选参数，par_num是最后一个确
             -的参数
1376   1          loc_shu=va_arg(loc_argp,uc);//取出下一个参数
1377   1          do{
1378   2              if(loc_shu<loc_min)
1379   2                  loc_min=loc_shu;
1380   2              loc_shu=va_arg(loc_argp,uc);//取出下一个参数
1381   2          }while(loc_shu!=def_end);
1382   1          va_end(loc_argp);//结束
1383   1          return loc_min;//退出
1384   1      }//求最小值
1385          void fun_coordinate(){
1386   1          
1387   1      }//自动巡线之坐标
1388          void fun_zdzj(ul par_04,ul par_37){//ul型数据,一次输入所有结果,无需等待
1389   1          xdata struct str_zdzj str_pass,str_end;//str_zdzj(自动抓件)的结构体:现在的数据和结束
             -得到的结果
1390   1          xdata char loc_high[8];         //每摞工件的高度
1391   1          xdata uc loc_xh1;             //第一个循环
1392   1      
1393   1          memset(str_pass.jx,0,sizeof(str_pass.jx));//清空现在件序
1394   1          memset(str_end.jx,0,sizeof(str_end.jx)); //清空想要的件序
1395   1          memset(loc_high,5,sizeof(loc_high));     //每组高度置5(没有件)
1396   1      
1397   1          //起始区件号
1398   1          str_pass.jx[0][1]=(par_04/10000000)%10;  //传入现在件序:区0的第1号件件号(最高位)
1399   1          str_pass.jx[0][2]=(par_04/1000000)%10;   //传入现在件序:区0的第2号件件号
1400   1          str_pass.jx[0][3]=(par_04/100000)%10;    //传入现在件序:区0的第3号件件号
1401   1          str_pass.jx[0][4]=(par_04/10000)%10;     //传入现在件序:区0的第4号件件号(最低位)
1402   1          str_pass.jx[4][1]=(par_04/1000)%10;      //传入现在件序:区4的第1号件件号(最高位)
1403   1          str_pass.jx[4][2]=(par_04/100)%10;       //传入现在件序:区4的第2号件件号
1404   1          str_pass.jx[4][3]=(par_04/10)%10;        //传入现在件序:区4的第3号件件号
1405   1          str_pass.jx[4][4]=par_04%10;             //传入现在件序:区4的第4号件件号(最低位)
1406   1          //目的区件号
1407   1          str_pass.jx[3][1]=(par_37/10000000)%10;  //传入现在件序:区0的第1号件件号(最高位)
1408   1          str_pass.jx[3][2]=(par_37/1000000)%10;   //传入现在件序:区0的第2号件件号
1409   1          str_pass.jx[3][3]=(par_37/100000)%10;    //传入现在件序:区0的第3号件件号
1410   1          str_pass.jx[3][4]=(par_37/10000)%10;     //传入现在件序:区0的第4号件件号(最低位)
1411   1          str_pass.jx[7][1]=(par_37/1000)%10;      //传入现在件序:区4的第1号件件号(最高位)
1412   1          str_pass.jx[7][2]=(par_37/100)%10;       //传入现在件序:区4的第2号件件号
1413   1          str_pass.jx[7][3]=(par_37/10)%10;        //传入现在件序:区4的第3号件件号
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 24  

1414   1          str_pass.jx[7][4]=par_37%10;             //传入现在件序:区4的第4号件件号(最低位)
1415   1          //目的次序
1416   1          str_end.jx[3][1]=1;                      //标准目标次序:区3的第1号目的次序号(最高位)
1417   1          str_end.jx[3][2]=2;                      //标准目标次序:区3的第2号目的次序号
1418   1          str_end.jx[3][3]=3;                      //标准目标次序:区3的第3号目的次序号
1419   1          str_end.jx[3][4]=4;                      //标准目标次序:区3的第4号目的次序号(最低位)
1420   1          str_end.jx[7][1]=5;                      //标准目标次序:区7的第1号目的次序号(最高位)
1421   1          str_end.jx[7][2]=6;                      //标准目标次序:区7的第2号目的次序号
1422   1          str_end.jx[7][3]=7;                      //标准目标次序:区7的第3号目的次序号
1423   1          str_end.jx[7][4]=8;                      //标准目标次序:区7的第4号目的次序号(最低位)
1424   1      
1425   1          for(loc_xh1=1;loc_xh1<=4;loc_xh1++){
1426   2              if((str_pass.jx[0][loc_xh1]==str_pass.jx[3][1])&&(str_pass.jx[0][loc_xh1]!=0))
1427   2                  str_end.jx[0][loc_xh1]=str_end.jx[3][1];
1428   2              else if((str_pass.jx[0][loc_xh1]==str_pass.jx[3][2])&&(str_pass.jx[0][loc_xh1]!=0))
1429   2                  str_end.jx[0][loc_xh1]=str_end.jx[3][2];
1430   2              else if((str_pass.jx[0][loc_xh1]==str_pass.jx[3][3])&&(str_pass.jx[0][loc_xh1]!=0))
1431   2                  str_end.jx[0][loc_xh1]=str_end.jx[3][3];
1432   2              else if((str_pass.jx[0][loc_xh1]==str_pass.jx[3][4])&&(str_pass.jx[0][loc_xh1]!=0))
1433   2                  str_end.jx[0][loc_xh1]=str_end.jx[3][4];
1434   2              else if((str_pass.jx[0][loc_xh1]==str_pass.jx[7][1])&&(str_pass.jx[0][loc_xh1]!=0))
1435   2                  str_end.jx[0][loc_xh1]=str_end.jx[7][1];
1436   2              else if((str_pass.jx[0][loc_xh1]==str_pass.jx[7][2])&&(str_pass.jx[0][loc_xh1]!=0))
1437   2                  str_end.jx[0][loc_xh1]=str_end.jx[7][2];
1438   2              else if((str_pass.jx[0][loc_xh1]==str_pass.jx[7][3])&&(str_pass.jx[0][loc_xh1]!=0))
1439   2                  str_end.jx[0][loc_xh1]=str_end.jx[7][3];
1440   2              else if((str_pass.jx[0][loc_xh1]==str_pass.jx[7][4])&&(str_pass.jx[0][loc_xh1]!=0))
1441   2                  str_end.jx[0][loc_xh1]=str_end.jx[7][4];
1442   2      
1443   2              if((str_pass.jx[4][loc_xh1]==str_pass.jx[3][1])&&(str_pass.jx[4][loc_xh1]!=0))
1444   2                  str_end.jx[4][loc_xh1]=str_end.jx[3][1];
1445   2              else if((str_pass.jx[4][loc_xh1]==str_pass.jx[3][2])&&(str_pass.jx[4][loc_xh1]!=0))
1446   2                  str_end.jx[4][loc_xh1]=str_end.jx[3][2];
1447   2              else if((str_pass.jx[4][loc_xh1]==str_pass.jx[3][3])&&(str_pass.jx[4][loc_xh1]!=0))
1448   2                  str_end.jx[4][loc_xh1]=str_end.jx[3][3];
1449   2              else if((str_pass.jx[4][loc_xh1]==str_pass.jx[3][4])&&(str_pass.jx[4][loc_xh1]!=0))
1450   2                  str_end.jx[4][loc_xh1]=str_end.jx[3][4];
1451   2              else if((str_pass.jx[4][loc_xh1]==str_pass.jx[7][1])&&(str_pass.jx[4][loc_xh1]!=0))
1452   2                  str_end.jx[4][loc_xh1]=str_end.jx[7][1];
1453   2              else if((str_pass.jx[4][loc_xh1]==str_pass.jx[7][2])&&(str_pass.jx[4][loc_xh1]!=0))
1454   2                  str_end.jx[4][loc_xh1]=str_end.jx[7][2];
1455   2              else if((str_pass.jx[4][loc_xh1]==str_pass.jx[7][3])&&(str_pass.jx[4][loc_xh1]!=0))
1456   2                  str_end.jx[4][loc_xh1]=str_end.jx[7][3];
1457   2              else if((str_pass.jx[4][loc_xh1]==str_pass.jx[7][4])&&(str_pass.jx[4][loc_xh1]!=0))
1458   2                  str_end.jx[4][loc_xh1]=str_end.jx[7][4];
1459   2          }//通过实际件序获得编号
1460   1      
1461   1          memset(str_pass.jx,0,sizeof(str_pass.jx));//清空现在实际件序
1462   1          for(loc_xh1=1;loc_xh1<=4;loc_xh1++){
1463   2              str_pass.jx[0][loc_xh1]=str_end.jx[0][loc_xh1];
1464   2              str_pass.jx[4][loc_xh1]=str_end.jx[4][loc_xh1];
1465   2          }//将现在的件序从str_end.jx中拿到str_pass.jx
1466   1          for(loc_xh1=1;loc_xh1<=4;loc_xh1++){
1467   2              str_end.jx[0][loc_xh1]=0;
1468   2              str_end.jx[4][loc_xh1]=0;
1469   2          }//删除str_end.jx中现在的件序
1470   1          loc_high[0]=loc_high[4]=1;//只有0号和4号放满了件
1471   1          loc_xh1=0;//循环标志位归零
1472   1      
1473   1          /*
1474   1              到目前为止准备工作结束,现在的数组中没有实际件序,
1475   1              现在的编号在str_pass.jx中,
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 25  

1476   1              想要得到的结果件序编号在str_end.jx中
1477   1          */
1478   1          while(1){
1479   2              //退出条件
1480   2              if((str_pass.jx[3][1]==str_end.jx[3][1])&&
1481   2              (str_pass.jx[3][2]==str_end.jx[3][2])&&
1482   2              (str_pass.jx[3][3]==str_end.jx[3][3])&&
1483   2              (str_pass.jx[3][4]==str_end.jx[3][4])&&
1484   2              (str_pass.jx[7][1]==str_end.jx[7][1])&&
1485   2              (str_pass.jx[7][2]==str_end.jx[7][2])&&
1486   2              (str_pass.jx[7][3]==str_end.jx[7][3])&&
1487   2              (str_pass.jx[7][4]==str_end.jx[7][4])){
1488   3                  if(str_begin.hzfx==dir_left){
1489   4                      fun_sz1(han_s);                 //手抓松
1490   4                      fun_sj1(sjp_1);                 //升降到最高位
1491   4                      fun_zjzt(mot_pyhz,7);           //平面位置7
1492   4                      fun_zjzt(mot_sj,loc_high[7]);   //升降到7的最高位
1493   4                      fun_sz1(han_j);                 //手抓紧
1494   4                  }//如果停在左边
1495   3                  return;
1496   3              }//如果小车一方的实际件序和想要达到的件序相等
1497   2              if(str_begin.hzfx==dir_left){
1498   3                  //转向条件
1499   3                  loc_xh1++;//标志位+1
1500   3                  if(loc_xh1>=100){
1501   4                      loc_xh1=0;
1502   4                      fun_zjzt(mot_sj,fun_min(loc_high[0],loc_high[1],loc_high[2],loc_high[3],loc_high[4],loc_hi
             -gh[5],loc_high[6],loc_high[7],def_end)-1);
1503   4                      fun_hz1(dir_right);
1504   4                  }
1505   3                  //可以一次拿走,不需要中间位的
1506   3                  if(loc_high[1]<5){
1507   4                      if(str_pass.jx[1][loc_high[1]]==str_end.jx[3][loc_high[3]-1]){
1508   5                          fun_najian(1,3,loc_high,str_pass.jx);//1-->3
1509   5                          continue;
1510   5                      }
1511   4                  }//如果区1有件
1512   3                  if(loc_high[2]<5){
1513   4                      if(str_pass.jx[2][loc_high[2]]==str_end.jx[3][loc_high[3]-1]){
1514   5                          fun_najian(2,3,loc_high,str_pass.jx);//2-->3
1515   5                          continue;
1516   5                      }
1517   4                  }//如果区2有件
1518   3                  if(loc_high[0]<5){
1519   4                      if(str_pass.jx[0][loc_high[0]]==str_end.jx[3][loc_high[3]-1]){
1520   5                          fun_najian(0,3,loc_high,str_pass.jx);//0-->3
1521   5                          continue;
1522   5                      }
1523   4                      if(str_pass.jx[0][loc_high[0]]==str_end.jx[7][loc_high[7]-1]){
1524   5                          fun_najian(0,7,loc_high,str_pass.jx);//0-->7
1525   5                          continue;
1526   5                      }
1527   4                  }//如果区0有件
1528   3      
1529   3                  //不可以一次拿走,需要中间位的
1530   3                  if(loc_high[0]<5){
1531   4                      if((str_pass.jx[0][loc_high[0]]==str_end.jx[3][1])||
1532   4                      (str_pass.jx[0][loc_high[0]]==str_end.jx[3][2])||
1533   4                      (str_pass.jx[0][loc_high[0]]==str_end.jx[3][3])||
1534   4                      (str_pass.jx[0][loc_high[0]]==str_end.jx[3][4])){
1535   5                          if(((loc_high[1]==5)||//如果1区没放东西或者
1536   5                          (str_pass.jx[0][loc_high[0]]>str_pass.jx[1][loc_high[1]]))&&//0区的件编号大于1
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 26  

             -的编号并且
1537   5                          (loc_high[1]>2)){//1区不能放超过2个件
1538   6                              fun_najian(0,1,loc_high,str_pass.jx);//0-->1
1539   6                              continue;
1540   6                          }
1541   5                          if(((loc_high[2]==5)||//如果2区没放东西或者
1542   5                          (str_pass.jx[0][loc_high[0]]>str_pass.jx[2][loc_high[2]]))&&//0区的件编号大于2
             -的编号并且
1543   5                          (loc_high[2]>2)){//2区不能放超过2个件
1544   6                              fun_najian(0,2,loc_high,str_pass.jx);//0-->2
1545   6                              continue;
1546   6                          }
1547   5                      }//如果要放在3上,但目前不能放
1548   4                      if((str_pass.jx[0][loc_high[0]]==str_end.jx[7][1])||
1549   4                      (str_pass.jx[0][loc_high[0]]==str_end.jx[7][2])||
1550   4                      (str_pass.jx[0][loc_high[0]]==str_end.jx[7][3])||
1551   4                      (str_pass.jx[0][loc_high[0]]==str_end.jx[7][4])){
1552   5                          if(((loc_high[5]==5)||//如果5区没东西放或者
1553   5                          (str_pass.jx[0][loc_high[0]]>str_pass.jx[5][loc_high[5]]))&&//0区的件编号大于5
             -的编号并且
1554   5                          (loc_high[5]>2)){//5区不能放超过2个件
1555   6                              fun_najian(0,5,loc_high,str_pass.jx);//0-->5
1556   6                              continue;
1557   6                          }
1558   5                          if(((loc_high[6]==5)||//如果6区没东西放或者
1559   5                          (str_pass.jx[0][loc_high[0]]>str_pass.jx[6][loc_high[6]]))&&//0区的件编号大于6
             -的编号并且
1560   5                          (loc_high[6]>2)){//6区不能放超过2个件
1561   6                              fun_najian(0,6,loc_high,str_pass.jx);//0-->6
1562   6                              continue;
1563   6                          }
1564   5                      }//如果要放在7上,但目前不能放
1565   4                  }//如果区0有件
1566   3      
1567   3                  //中间两个位置也不能一次搞定的
1568   3                  if((loc_high[1]<5)&&(loc_high[2]<5)){
1569   4                      if((str_pass.jx[1][loc_high[1]]>str_pass.jx[2][loc_high[2]])&&(loc_high[2]>1)){
1570   5                          fun_najian(1,2,loc_high,str_pass.jx);//1-->2
1571   5                          continue;
1572   5                      }//1的件比2的件大且区2放了不到3个件
1573   4                      if((str_pass.jx[2][loc_high[2]]>str_pass.jx[1][loc_high[1]])&&(loc_high[1]>1)){
1574   5                          fun_najian(2,1,loc_high,str_pass.jx);//2-->1
1575   5                          continue;
1576   5                      }//2的件比1的件大且区1放了不到3个件
1577   4                  }//如果区1和区2都有件
1578   3      
1579   3                  //中间两个位置怎么也搞不定的
1580   3                  if((loc_high[1]<5)&&(loc_high[2]<5)){
1581   4                      if((loc_high[0]>1)&&(str_pass.jx[1][loc_high[1]]>str_pass.jx[0][loc_high[0]])){
1582   5                          fun_najian(1,0,loc_high,str_pass.jx);//1-->0
1583   5                          continue;
1584   5                      }//1区的件比0区的大且0区放了不到3个件
1585   4                      if((loc_high[0]>1)&&(str_pass.jx[2][loc_high[2]]>str_pass.jx[0][loc_high[0]])){
1586   5                          fun_najian(2,0,loc_high,str_pass.jx);//2-->0
1587   5                          continue;
1588   5                      }//2区的件比0区的大且0区放了不到3个件
1589   4                  }
1590   3              }//如果回转在左边 
1591   2              if(str_begin.hzfx==dir_right){
1592   3                  //转向条件
1593   3                  loc_xh1++;//标志位+1
1594   3                  if(loc_xh1>=100){
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 27  

1595   4                      loc_xh1=0;
1596   4                      fun_zjzt(mot_sj,fun_min(loc_high[0],loc_high[1],loc_high[2],loc_high[3],loc_high[4],loc_hi
             -gh[5],loc_high[6],loc_high[7],def_end)-1);
1597   4                      fun_hz1(dir_left);
1598   4                  }
1599   3                  //可以一次拿走,不需要中间位的
1600   3                  if(loc_high[5]<5){
1601   4                      if(str_pass.jx[5][loc_high[5]]==str_end.jx[7][loc_high[7]-1]){
1602   5                          fun_najian(5,7,loc_high,str_pass.jx);//5-->7
1603   5                          continue;
1604   5                      }//5-->7
1605   4                  }//如果区5有件
1606   3                  if(loc_high[6]<5){
1607   4                      if(str_pass.jx[6][loc_high[6]]==str_end.jx[7][loc_high[7]-1]){
1608   5                          fun_najian(6,7,loc_high,str_pass.jx);//6-->7
1609   5                          continue;
1610   5                      }//6-->7
1611   4                  }//如果区6有件
1612   3                  if(loc_high[4]<5){
1613   4                      if(str_pass.jx[4][loc_high[4]]==str_end.jx[7][loc_high[7]-1]){
1614   5                          fun_najian(4,7,loc_high,str_pass.jx);//4-->7
1615   5                          continue;
1616   5                      }//4-->7
1617   4                      if(str_pass.jx[4][loc_high[4]]==str_end.jx[3][loc_high[3]-1]){
1618   5                          fun_najian(4,3,loc_high,str_pass.jx);//4-->3
1619   5                          continue;
1620   5                      }//4-->3
1621   4                  }//如果区4有件
1622   3      
1623   3                  //不可以一次拿走,需要中间位的
1624   3                  if(loc_high[4]<5){
1625   4                      if((str_pass.jx[4][loc_high[4]]==str_end.jx[7][1])||
1626   4                      (str_pass.jx[4][loc_high[4]]==str_end.jx[7][2])||
1627   4                      (str_pass.jx[4][loc_high[4]]==str_end.jx[7][3])||
1628   4                      (str_pass.jx[4][loc_high[4]]==str_end.jx[7][4])){
1629   5                          if(((loc_high[5]==5)||//如果5区没东西放或者
1630   5                          (str_pass.jx[4][loc_high[4]]>str_pass.jx[5][loc_high[5]]))&&//4区的件编号大于5
             -的编号并且
1631   5                          (loc_high[5]>2)){//5区不能放超过2个件
1632   6                              fun_najian(4,5,loc_high,str_pass.jx);//4-->5
1633   6                              continue;
1634   6                          }
1635   5                          if(((loc_high[6]==5)||//如果6区没东西放或者
1636   5                          (str_pass.jx[4][loc_high[4]]>str_pass.jx[6][loc_high[6]]))&&//4区的件编号大于6
             -的编号并且
1637   5                          (loc_high[6]>2)){//6区不能放超过2个件
1638   6                              fun_najian(4,6,loc_high,str_pass.jx);//4-->6
1639   6                              continue;
1640   6                          }
1641   5                      }//如果要放在7上,但目前不能放
1642   4                      if((str_pass.jx[4][loc_high[4]]==str_end.jx[3][1])||
1643   4                      (str_pass.jx[4][loc_high[4]]==str_end.jx[3][2])||
1644   4                      (str_pass.jx[4][loc_high[4]]==str_end.jx[3][3])||
1645   4                      (str_pass.jx[4][loc_high[4]]==str_end.jx[3][4])){
1646   5                          if(((loc_high[1]==5)||//如果1区没放东西或者
1647   5                          (str_pass.jx[4][loc_high[4]]>str_pass.jx[1][loc_high[1]]))&&//4区的件编号大于1
             -的编号并且
1648   5                          (loc_high[1]>2)){//1区不能放超过2个件
1649   6                              fun_najian(4,1,loc_high,str_pass.jx);//4-->1
1650   6                              continue;
1651   6                          }
1652   5                          if(((loc_high[2]==5)||//如果2区没放东西或者
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 28  

1653   5                              (str_pass.jx[4][loc_high[4]]>str_pass.jx[2][loc_high[2]]))&&//4区的件编号大
             -2区的编号并且
1654   5                              (loc_high[2]>2)){//2区不能放超过2个件
1655   6                              fun_najian(4,2,loc_high,str_pass.jx);//4-->2
1656   6                              continue;
1657   6                          }
1658   5                      }//如果要放在3上,但目前不能放
1659   4                  }//如果区4有件
1660   3      
1661   3                  //中间两个位置也不能一次搞定的
1662   3                  if((loc_high[5]<5)&&(loc_high[6]<5)){
1663   4                      if((str_pass.jx[5][loc_high[5]]>str_pass.jx[6][loc_high[6]])&&(loc_high[6]>1)){
1664   5                          fun_najian(5,6,loc_high,str_pass.jx);//5-->6
1665   5                          continue;
1666   5                      }//5的件比6的件大且区6放了不到3个件
1667   4                      if((str_pass.jx[6][loc_high[6]]>str_pass.jx[5][loc_high[5]])&&(loc_high[5]>1)){
1668   5                          fun_najian(6,5,loc_high,str_pass.jx);//6-->5
1669   5                          continue;
1670   5                      }//6的件比5的件大且区5放了不到3个件
1671   4                  }//如果区5和区6都有件
1672   3      
1673   3                  //中间两个位置怎么也搞不定的
1674   3                  if((loc_high[5]<5)&&(loc_high[6]<5)){
1675   4                      if((loc_high[4]>1)&&(str_pass.jx[5][loc_high[5]]>str_pass.jx[4][loc_high[4]])){
1676   5                          fun_najian(5,4,loc_high,str_pass.jx);//5-->4
1677   5                          continue;
1678   5                      }//5区的件比4区的大且4区放了不到3个件
1679   4                      if((loc_high[4]>1)&&(str_pass.jx[6][loc_high[6]]>str_pass.jx[4][loc_high[4]])){
1680   5                          fun_najian(6,4,loc_high,str_pass.jx);//6-->4
1681   5                          continue;
1682   5                      }//6区的件比4区的大且4区放了不到3个件
1683   4                  }
1684   3              }//如果回转在右边
1685   2          }    
1686   1      }//自动抓件
1687          void fun_zjzt(uc par_motor,char par_model){
1688   1          if(par_motor==mot_pyhz){
1689   2              switch(par_model){
1690   3                  case 0:
1691   3                      if((str_begin.pywz==tra_h)&&(str_begin.hzfx==dir_left))
1692   3                          break;
1693   3                      if(str_begin.hzfx==dir_right){
1694   4                          fun_py1(tra_z);
1695   4                          fun_hz1(dir_left);
1696   4                      }
1697   3                      fun_py1(tra_h);
1698   3                      break;
1699   3                  case 1:
1700   3                      if((str_begin.pywz==tra_kh)&&(str_begin.hzfx==dir_left))
1701   3                          break;
1702   3                      if(str_begin.hzfx==dir_right){
1703   4                          fun_py1(tra_z);
1704   4                          fun_hz1(dir_left);
1705   4                      }
1706   3                      fun_py1(tra_kh);
1707   3                      break;
1708   3                  case 2:
1709   3                      if((str_begin.pywz==tra_kq)&&(str_begin.hzfx==dir_left))
1710   3                          break;
1711   3                      if(str_begin.hzfx==dir_right){
1712   4                          fun_py1(tra_z);
1713   4                          fun_hz1(dir_left);
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 29  

1714   4                      }
1715   3                      fun_py1(tra_kq);
1716   3                      break;
1717   3                  case 3:
1718   3                      if((str_begin.pywz==tra_q)&&(str_begin.hzfx==dir_left))
1719   3                          break;
1720   3                      if(str_begin.hzfx==dir_right){
1721   4                          fun_py1(tra_z);
1722   4                          fun_hz1(dir_left);
1723   4                      }
1724   3                      fun_py1(tra_q);
1725   3                      break;
1726   3                  case 4:
1727   3                      if((str_begin.pywz==tra_q)&&(str_begin.hzfx==dir_right))
1728   3                          break;
1729   3                      if(str_begin.hzfx==dir_left){
1730   4                          fun_py1(tra_z);
1731   4                          fun_hz1(dir_right);
1732   4                      }
1733   3                      fun_py1(tra_q);
1734   3                      break;
1735   3                  case 5:
1736   3                      if((str_begin.pywz==tra_kq)&&(str_begin.hzfx==dir_right))
1737   3                          break;
1738   3                      if(str_begin.hzfx==dir_left){
1739   4                          fun_py1(tra_z);
1740   4                          fun_hz1(dir_right);
1741   4                      }
1742   3                      fun_py1(tra_kq);
1743   3                      break;
1744   3                  case 6:
1745   3                      if((str_begin.pywz==tra_kh)&&(str_begin.hzfx==dir_right))
1746   3                          break;
1747   3                      if(str_begin.hzfx==dir_left){
1748   4                          fun_py1(tra_z);
1749   4                          fun_hz1(dir_right);
1750   4                      }
1751   3                      fun_py1(tra_kh);
1752   3                      break;
1753   3                  case 7:
1754   3                      if((str_begin.pywz==tra_h)&&(str_begin.hzfx==dir_right))
1755   3                          break;
1756   3                      if(str_begin.hzfx==dir_left){
1757   4                          fun_py1(tra_z);
1758   4                          fun_hz1(dir_right);
1759   4                      }
1760   3                      fun_py1(tra_h);
1761   3                      break;
1762   3                  default:
1763   3                      break;
1764   3              }
1765   2          }
1766   1          else if(par_motor==mot_sj){
1767   2              switch(par_model){
1768   3                  case 0:
1769   3                      fun_sj1(sjp_1);
1770   3                      break;
1771   3                  case 1:
1772   3                      fun_sj1(sjp_2);
1773   3                      break;
1774   3                  case 2:
1775   3                      fun_sj1(sjp_3);
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 30  

1776   3                      break;
1777   3                  case 3:
1778   3                      fun_sj1(sjp_4);
1779   3                      break;
1780   3                  case 4:
1781   3                      fun_sj1(sjp_5);
1782   3                      break;
1783   3                  default:
1784   3                      if(par_model<0)
1785   3                          fun_sj1(sjp_1);
1786   3                      else if(par_model>5)
1787   3                          fun_sj1(sjp_5);
1788   3                      break;
1789   3              }
1790   2          }
1791   1      }//抓件状态,0为左上位,3为左下位,4为右上位,7为右下位
1792          void fun_najian(uc par_now,uc par_next,char par_high[8],uc par_data[8][5]){
1793   1          #ifdef Debug
                      printf("%d --> %d\n",(ui)par_now,(ui)par_next);
                  #else
1796   1              //取各位置的最高位
1797   1              xdata uc loc_high=fun_min(par_high[0],par_high[1],par_high[2],par_high[3],par_high[4],par_high[5],
             -par_high[6],par_high[7]);
1798   1              //升起
1799   1              if(par_now==0||par_now==1||par_now==2||par_now==3){
1800   2                  if(str_begin.hzfx==dir_left)
1801   2                      fun_zjzt(mot_sj,fun_min(par_high[0],par_high[1],par_high[2],par_high[3],def_end)-1);
1802   2                  else if(str_begin.hzfx==dir_right)
1803   2                      fun_zjzt(mot_sj,fun_min(par_high[0],par_high[1],par_high[2],par_high[3],par_high[4],par_hi
             -gh[5],par_high[6],par_high[7],def_end)-1);            
1804   2              }
1805   1              else if(par_now==4||par_now==5||par_now==6||par_now==7){
1806   2                  if(str_begin.hzfx==dir_right)
1807   2                      fun_zjzt(mot_sj,fun_min(par_high[4],par_high[5],par_high[6],par_high[7],def_end)-1);
1808   2                  else if(str_begin.hzfx==dir_left)
1809   2                      fun_zjzt(mot_sj,fun_min(par_high[0],par_high[1],par_high[2],par_high[3],par_high[4],par_hi
             -gh[5],par_high[6],par_high[7],def_end)-1);            
1810   2              }
1811   1              //平移回转到需要的地方
1812   1              fun_zjzt(mot_pyhz,par_now);
1813   1              //下降到工件的位置
1814   1              fun_zjzt(mot_sj,par_high[par_now]);
1815   1              //抓紧工件
1816   1              fun_sz1(han_j);
1817   1              //上升到正确的最高位
1818   1              switch(par_now){
1819   2                  case 0:
1820   2                      switch(par_next){
1821   3                          case 1:
1822   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1823   3                              break;
1824   3                          case 2:
1825   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[1],par_high[par_next
             -]-1,def_end)-1);
1826   3                              break;
1827   3                          case 3:
1828   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[1],par_high[2],par_h
             -igh[par_next]-1,def_end)-1);
1829   3                              break;
1830   3                          case 4:
1831   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[1],par_high[5],par_h
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 31  

             -igh[par_next]-1,def_end)-1);
1832   3                              break;
1833   3                          case 5:
1834   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[1],par_high[par_next
             -]-1,def_end)-1);
1835   3                              break;
1836   3                          case 6:
1837   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[1],par_high[par_next
             -]-1,def_end)-1);
1838   3                              break;
1839   3                          case 7:
1840   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[1],par_high[6],par_h
             -igh[par_next]-1,def_end)-1);
1841   3                              break;
1842   3                          default:
1843   3                              break;
1844   3                      }
1845   2                      break;
1846   2                  case 1:
1847   2                      switch(par_next){
1848   3                          case 0:
1849   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1850   3                              break;
1851   3                          case 2:
1852   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1853   3                              break;
1854   3                          case 3:
1855   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[2],par_high[par_next
             -]-1,def_end)-1);
1856   3                              break;
1857   3                          case 4:
1858   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[5],par_high[par_next
             -]-1,def_end)-1);
1859   3                              break;
1860   3                          case 5:
1861   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1862   3                              break;
1863   3                          case 6:
1864   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1865   3                              break;
1866   3                          case 7:
1867   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[6],par_high[par_next
             -]-1,def_end)-1);
1868   3                              break;
1869   3                          default:
1870   3                              break;
1871   3                      }
1872   2                      break;
1873   2                  case 2:
1874   2                      switch(par_next){
1875   3                          case 0:
1876   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[1],par_high[par_next
             -]-1,def_end)-1);
1877   3                              break;
1878   3                          case 1:
1879   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1880   3                              break;
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 32  

1881   3                          case 3:
1882   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1883   3                              break;
1884   3                          case 4:
1885   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[5],par_high[par_next
             -]-1,def_end)-1);
1886   3                              break;
1887   3                          case 5:
1888   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1889   3                              break;
1890   3                          case 6:
1891   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1892   3                              break;
1893   3                          case 7:
1894   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[6],par_high[par_next
             -]-1,def_end)-1);
1895   3                              break;
1896   3                          default:
1897   3                              break;
1898   3                      }
1899   2                      break;
1900   2                  case 3:
1901   2                      switch(par_next){
1902   3                          case 0:
1903   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[2],par_high[1],par_h
             -igh[par_next]-1,def_end)-1);
1904   3                              break;
1905   3                          case 1:
1906   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[2],par_high[par_next
             -]-1,def_end)-1);
1907   3                              break;
1908   3                          case 2:
1909   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1910   3                              break;
1911   3                          case 4:
1912   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[2],par_high[5],par_h
             -igh[par_next]-1,def_end)-1);
1913   3                              break;
1914   3                          case 5:
1915   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[2],par_high[par_next
             -]-1,def_end)-1);
1916   3                              break;
1917   3                          case 6:
1918   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[2],par_high[par_next
             -]-1,def_end)-1);
1919   3                              break;
1920   3                          case 7:
1921   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[2],par_high[6],par_h
             -igh[par_next]-1,def_end)-1);
1922   3                              break;
1923   3                          default:
1924   3                              break;
1925   3                      }
1926   2                      break;
1927   2                  case 4:
1928   2                      switch(par_next){
1929   3                          case 0:
1930   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[5],par_high[1],par_h
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 33  

             -igh[par_next]-1,def_end)-1);
1931   3                              break;
1932   3                          case 1:
1933   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[5],par_high[par_next
             -]-1,def_end)-1);
1934   3                              break;
1935   3                          case 2:
1936   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[5],par_high[par_next
             -]-1,def_end)-1);
1937   3                              break;
1938   3                          case 3:
1939   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[5],par_high[2],par_h
             -igh[par_next]-1,def_end)-1);
1940   3                              break;
1941   3                          case 5:
1942   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1943   3                              break;
1944   3                          case 6:
1945   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[5],par_high[par_next
             -]-1,def_end)-1);
1946   3                              break;
1947   3                          case 7:
1948   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[5],par_high[6],par_h
             -igh[par_next]-1,def_end)-1);
1949   3                              break;
1950   3                          default:
1951   3                              break;
1952   3                      }
1953   2                      break;
1954   2                  case 5:
1955   2                      switch(par_next){
1956   3                          case 0:
1957   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[1],par_high[par_next
             -]-1,def_end)-1);
1958   3                              break;
1959   3                          case 1:
1960   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1961   3                              break;
1962   3                          case 2:
1963   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1964   3                              break;
1965   3                          case 3:
1966   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[2],par_high[par_next
             -]-1,def_end)-1);
1967   3                              break;
1968   3                          case 4:
1969   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1970   3                              break;
1971   3                          case 6:
1972   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1973   3                              break;
1974   3                          case 7:
1975   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[6],par_high[par_next
             -]-1,def_end)-1);
1976   3                              break;
1977   3                          default:
1978   3                              break;
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 34  

1979   3                      }
1980   2                      break;
1981   2                  case 6:
1982   2                      switch(par_next){
1983   3                          case 0:
1984   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[1],par_high[par_next
             -]-1,def_end)-1);
1985   3                              break;
1986   3                          case 1:
1987   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1988   3                              break;
1989   3                          case 2:
1990   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1991   3                              break;
1992   3                          case 3:
1993   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[2],par_high[par_next
             -]-1,def_end)-1);
1994   3                              break;
1995   3                          case 4:
1996   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[5],par_high[par_next
             -]-1,def_end)-1);
1997   3                              break;
1998   3                          case 5:
1999   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
2000   3                              break;
2001   3                          case 7:
2002   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
2003   3                              break;
2004   3                          default:
2005   3                              break;
2006   3                      }
2007   2                      break;
2008   2                  case 7:
2009   2                      switch(par_next){
2010   3                          case 0:
2011   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[6],par_high[1],par_h
             -igh[par_next]-1,def_end)-1);
2012   3                              break;
2013   3                          case 1:
2014   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[6],par_high[par_next
             -]-1,def_end)-1);
2015   3                              break;
2016   3                          case 2:
2017   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[6],par_high[par_next
             -]-1,def_end)-1);
2018   3                              break;
2019   3                          case 3:
2020   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[6],par_high[2],par_h
             -igh[par_next]-1,def_end)-1);
2021   3                              break;
2022   3                          case 4:
2023   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[5],par_high[6],par_h
             -igh[par_next]-1,def_end)-1);
2024   3                              break;
2025   3                          case 5:
2026   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[6],par_high[par_next
             -]-1,def_end)-1);
2027   3                              break;
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 35  

2028   3                          case 6:
2029   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
2030   3                              break;
2031   3                          default:
2032   3                              break;
2033   3                      }
2034   2                      break;
2035   2                  default:
2036   2                      break;
2037   2              }
2038   1              //平移回转至放件处
2039   1              fun_zjzt(mot_pyhz,par_next);
2040   1              //下降到要放下的位置
2041   1              fun_zjzt(mot_sj,par_high[par_next]-1);
2042   1              //松开手抓
2043   1              fun_sz1(han_s);
2044   1          #endif
2045   1      
2046   1          //更新参数
2047   1          par_data[par_next][par_high[par_next]-1]=par_data[par_now][par_high[par_now]];
2048   1          par_data[par_now][par_high[par_now]]=0;
2049   1          par_high[par_now]++;
2050   1          par_high[par_next]--;
2051   1      }//拿件(配合自动抓件使用)
2052          void fun_zhuajian(){
2053   1          fun_sz1(han_s);                 //手抓松
2054   1          fun_sj1(sjp_1);                 //上升到最高位
2055   1          fun_py1(tra_q);                 //平移到前端
2056   1          if(str_begin.hzfx!=dir_right)   //如果不在右边
2057   1              fun_hz1(dir_right);         //就平移到右边
2058   1      
2059   1          fun_folline(2,60);
2060   1          fun_turn(tur_l90,40);
2061   1          fun_folline(1,60);
2062   1          fun_qc(100,40);
2063   1          while(!in_ls1&&!in_ls2&&!in_ls3&&in_ls4&&in_ls5&&!in_ls6&&!in_ls7&&!in_ls8){
2064   2              if(in_ls3||!in_ls5){
2065   3                  fun_motors(mot_r,-30);
2066   3                  fun_motors(mot_l,-29);
2067   3                  fun_delay(500,del_ms);
2068   3                  fun_motors(mot_r,-29);
2069   3                  fun_motors(mot_l,-30);
2070   3                  fun_delay(500,del_ms);
2071   3                  fun_motors(mot_rl,-30);
2072   3                  fun_delay(500,del_ms);
2073   3              }//3亮或5不亮
2074   2              else if(in_ls6||!in_ls4){
2075   3                  fun_motors(mot_r,-30);
2076   3                  fun_motors(mot_l,-29);
2077   3                  fun_delay(500,del_ms);
2078   3                  fun_motors(mot_r,-29);
2079   3                  fun_motors(mot_l,-30);
2080   3                  fun_delay(500,del_ms);
2081   3                  fun_motors(mot_rl,-30);
2082   3                  fun_delay(500,del_ms);
2083   3              }//6亮或4不亮
2084   2              fun_qc(200,40);//重新进行前冲
2085   2          }
2086   1          fun_motors(mot_rl,0);
2087   1      }//从起始区走到抓件区
2088          void fun_back(){
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 36  

2089   1          fun_motors(mot_rl,-30);
2090   1          fun_delay(1,del_s);
2091   1      
2092   1          fun_motors(mot_r,-50);
2093   1          fun_motors(mot_l,-20);
2094   1          fun_delay(3,del_s);    
2095   1      
2096   1          fun_motors(mot_rl,-35);
2097   1          fun_delay(1,del_s);
2098   1      }//从抓件区回到起始区
2099          void fun_start(char par_x,char par_y,enum varENU_dir par_ctfx,enum varENU_han par_szzt,enum varENU_sjp par
             -_sjwz,enum varENU_tra par_pywz,enum varENU_dir par_hzfx){
2100   1          CLK_DIV=0x00;             //不分频
2101   1          P0M1=0xff;                //P0用于输入
2102   1          P0M0=0x00;                //P0不能输出
2103   1          P1M1=0x00;                //P1口0-1双向
2104   1          P1M0=0xfc;                //P1口2-7输出
2105   1          P2M1=0xf0;                //P2口4-7输入
2106   1          P2M0=0x0f;                //P2口0-3输出
2107   1      
2108   1          out_en1=1;                //电机1/3使能
2109   1          out_en2=1;                //电机2/4使能
2110   1          CR=0;                     //PAC计数器归零
2111   1          out_motorselect=0;        //电机片选为0
2112   1      
2113   1          #ifdef Debug              //如果是调试模式
                      fun_port();           //初始化串口
                      TI=1;                 //打开串口传输功能        
                  #endif
2117   1          fun_pwminit();            //PWM的初始化
2118   1          fun_timer0init();         //初始化定时器0
2119   1          fun_timer1init();         //初始化定时器1
2120   1      
2121   1          str_begin.x=par_x;        //X坐标
2122   1          str_begin.y=par_y;        //Y坐标
2123   1          str_begin.ctfx=par_ctfx;  //车头方向
2124   1          str_begin.szzt=par_szzt;  //手抓状态
2125   1          str_begin.sjwz=par_sjwz;  //升降位置
2126   1          str_begin.pywz=par_pywz;  //平移位置
2127   1          str_begin.hzfx=par_hzfx;  //回转方向
2128   1      
2129   1          str_tfl.gospeed=0;        //速度归零
2130   1          fun_motors(mot_sz,0);     //手抓速度归零
2131   1          fun_motors(mot_py,0);     //平移速度归零
2132   1          fun_motors(mot_sj,0);     //手抓速度归零
2133   1          fun_motors(mot_hz,0);     //手抓速度归零
2134   1          fun_motors(mot_rl,0);     //左右速度归零
2135   1      
2136   1          TR0=1;                    //打开定时器0
2137   1          TR1=1;                    //打开定时器1
2138   1          in_start=1;               //按键置1
2139   1          #ifdef Debug              //如果开启调试模式
                      fun_delay(5,del_s);
                      MSG("Ready!")         //输出Ready!
                  #else
2143   1              fun_wait();           //等待按键
2144   1          #endif
2145   1      }//初始化函数
2146          void fun_stop(){
2147   1          EA=0;                   //关总中断
2148   1          str_tfl.gospeed=0;      //速度归零
2149   1          fun_motors(mot_sz,0);   //手抓速度归零
C51 COMPILER V9.54   8023                                                                  09/29/2015 11:19:43 PAGE 37  

2150   1          fun_motors(mot_py,0);   //平移速度归零
2151   1          fun_motors(mot_sj,0);   //手抓速度归零
2152   1          fun_motors(mot_hz,0);   //手抓速度归零
2153   1          fun_motors(mot_rl,0);   //左右速度归零
2154   1          MSG("End!")             //输出End!
2155   1          while(1);               //死循环
2156   1      }//结束函数


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  12394    ----
   CONSTANT SIZE    =      9    ----
   XDATA SIZE       =    150      90
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5      72
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
