C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE 8023
OBJECT MODULE PLACED IN .\output\8023.obj
COMPILER INVOKED BY: H:\Program\keil\C51\BIN\C51.EXE program\8023.c DEBUG OBJECTEXTEND PRINT(.\8023.lst) OBJECT(.\output
                    -\8023.obj)

line level    source

   1          #include "./output/8023.h"
   2          xdata struct str_state str_begin,str_now,str_next;//分别为:起始状态/当前状态/目标状态
   3          xdata struct str_parameter str_cod={
   4              /*ui str_cod.mlinerqd*/500,//默认主函数巡线软起动时间为500毫秒
   5              /*ui str_cod.mlineqc*/200,//默认主函数巡线前冲时间为500毫秒
   6          
   7              /*ui str_cod.sj1bzw*/58,
   8              /*ui str_cod.sj1zjw*/800,
   9          
  10              /*ui str_cod.py1qkq*/666,
  11              /*ui str_cod.py1kqz*/684,
  12              /*ui str_cod.py1zkh*/684,
  13              /*ui str_cod.py1khh*/666,
  14              /*ui str_cod.py1qz*/500,
  15              /*ui str_cod.py1zh*/500,
  16              /*ui str_cod.py1kqkh*/1480,
  17              /*ui str_cod.py1qkh*/2122,
  18              /*ui str_cod.py1kqh*/2122,
  19          };
  20          ui var_timer0=0;
  21          void fun_delay(ui par_value,enum varENU_del par_model){
  22   1          ui loc_con=par_value;
  23   1          switch(par_model){
  24   2              case del_us://微秒级延时
  25   2                  while(loc_con-->0){
  26   3                      _nop_();
  27   3                      _nop_();
  28   3                  }
  29   2                  return;
  30   2              case del_ms://毫秒级延时
  31   2                  while(loc_con-->0){
  32   3                      uc loc_i, loc_j;
  33   3                      _nop_();
  34   3                      _nop_();
  35   3                      loc_i=12;
  36   3                      loc_j=168;
  37   3                      do{
  38   4                          while(--loc_j);
  39   4                      }while(--loc_i);
  40   3                  }
  41   2                  return;
  42   2              case del_s://秒级延时
  43   2                  while(loc_con-->0){
  44   3                      uc loc_i, loc_j, loc_k;
  45   3                      loc_i=46;
  46   3                      loc_j=153;
  47   3                      loc_k=245;
  48   3                      do{
  49   4                          do{
  50   5                              while(--loc_k);
  51   5                          }while(--loc_j);
  52   4                      }while(--loc_i);
  53   3                  }
  54   2                  return;
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 2   

  55   2              default:return;
  56   2          }
  57   1      }//延时
  58          void fun_timer0init(){
  59   1          AUXR|=0x80;       //定时器时钟1T模式
  60   1          TMOD&=0xF0;       //设置定时器模式
  61   1          TMOD|=0x01;       //设置定时器模式
  62   1          TL0=0x20;     //设置定时初值
  63   1          TH0=0xD1;     //设置定时初值
  64   1          TF0=0;        //清除TF0标志
  65   1          ET0=1;
  66   1          EA=1;
  67   1      }//1毫秒定时器0初始化
  68          void fun_timer1init(){
  69   1          AUXR&=0xBF;
  70   1          TMOD&=0x0F;
  71   1          TMOD|=0x10;
  72   1          TL1=0xE0;
  73   1          TH1=0xB1;
  74   1          TF1=0;
  75   1          ET1=1;
  76   1          EA=1;
  77   1      }//20毫秒定时器1初始化
  78          void fun_timer0(){
  79   1          TL0=0x20;
  80   1          TH0=0xD1;
  81   1          _nop_();
  82   1          var_timer0++;
  83   1      }//1毫秒定时器0处理函数
  84          void fun_timer1(){
  85   1          TL1=0xE0;
  86   1          TH1=0xB1;
  87   1          _nop_();
  88   1      }//20毫秒定时器1处理函数
  89          void fun_wait(){
  90   1          while(in_start==1);
  91   1          fun_delay(20,del_ms);
  92   1          while(in_start==0);
  93   1          fun_delay(256,del_ms);
  94   1      }//等待按键
  95          void fun_select(enum varENU_sel par_model){
  96   1          if(par_model==sel_58)
  97   1              out_switchselect=0;
  98   1          else if(par_model==sel_912)
  99   1              out_switchselect=1;
 100   1      }//传感器片选
 101          void fun_initialization(){
 102   1          CLK_DIV=0x00;//不分频
 103   1      
 104   1          P0M1=0xff;//P0用于输入
 105   1          P0M0=0x00;//P0不能输出
 106   1          
 107   1          P1M1=0x00;//P1口0-1双向，2中断输入，3-6输入，7输出
 108   1          P1M0=0xfc;//P1口2-7输出
 109   1      
 110   1          P2M1=0xf0;//P2口4-7输入
 111   1          P2M0=0x0f;//P2口0-3输出
 112   1      
 113   1          //PS_2=1;//手抓松传感器置1 $?$
 114   1          //PS_11=1;//升降位置3传感器置1 $?$
 115   1      
 116   1          out_en1=1;//电机1/3使能 $?$
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 3   

 117   1          out_en2=1;//电机2/4使能 $?$
 118   1          //out_motorselect=1;//电机片选为1 $?$
 119   1          //fun_delay(del_ms,1);//延时1毫秒 $?$
 120   1          out_motorselect=0;//电机片选为0 $?$
 121   1          //PS_5=PS_1;// $?$
 122   1      
 123   1          fun_pwminit();//PWM的初始化设置
 124   1          fun_timer0init();//初始化定时器0
 125   1          fun_timer1init();//初始化定时器1
 126   1          fun_port();//初始化串口
 127   1          in_start=1;//按键置1
 128   1      
 129   1          fun_wait();
 130   1      }//初始化
 131          void fun_pwminit(){
 132   1          CCON=0x00;
 133   1          CH=0;
 134   1          CL=0;
 135   1          CMOD=0x00;
 136   1      }//PWM初始化
 137          void fun_pwmr(uc par_value){
 138   1          CCAP0H=CCAP0L=par_value*2.5;//控制输出的占空比
 139   1          CCAPM0=0X42;//8位PWM输出，无中断
 140   1          PCA_PWM0=0x00;
 141   1      }//右路PWM输出
 142          void fun_pwml(uc par_value){
 143   1          CCAP1H=CCAP1L=par_value*2.5;//控制输出的占空比
 144   1          CCAPM1=0X42;//8位PWM输出，无中断
 145   1          PCA_PWM1=0x00;
 146   1      }//左路PWM输出
 147          void fun_startdj(enum varENU_mot par_model,char par_speed){
 148   1          if(par_speed==0)
 149   1              return;
 150   1          else if(par_speed>100)
 151   1              par_speed=100;
 152   1          else if(par_speed<-100)
 153   1              par_speed=-100;
 154   1          switch(par_model){
 155   2              case mot_l://左轮电机
 156   2                  CR=1;
 157   2                  if(par_speed>0){
 158   3                      fun_pwml(par_speed);out_pwml=0;
 159   3                  }
 160   2                  else if(par_speed<0){
 161   3                      fun_pwml(cabs(par_speed));out_pwml=1;
 162   3                  }
 163   2                  break;
 164   2              case mot_r://右轮电机
 165   2                  CR=1;
 166   2                  if(par_speed>0){
 167   3                      fun_pwmr(par_speed);out_pwmr=0;
 168   3                  }
 169   2                  else if(par_speed<0){
 170   3                      fun_pwmr(cabs(par_speed));out_pwmr=1;
 171   3                  }
 172   2                  break;
 173   2              case mot_rl://左右轮同步
 174   2                  CR=1;
 175   2                  if(par_speed>0){
 176   3                      fun_pwml(par_speed);out_pwml=0;
 177   3                      fun_pwmr(par_speed);out_pwmr=0;
 178   3                  }
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 4   

 179   2                  else if(par_speed<0){
 180   3                      fun_pwml(cabs(par_speed));out_pwml=1;
 181   3                      fun_pwmr(cabs(par_speed));out_pwmr=1;
 182   3                  }
 183   2                  break;
 184   2              case mot_dj1://正转为抓紧，反转为松开
 185   2                  out_motorselect=1;
 186   2                  if(par_speed>0)
 187   2                      out_dir1=1;
 188   2                  else if(par_speed<0)
 189   2                      out_dir1=0;
 190   2                  out_en1=0;
 191   2                  break;
 192   2              case mot_dj2://正转是向无电机一方转,反转为向有电机一方转
 193   2                  out_motorselect=1;
 194   2                  if(par_speed>0)
 195   2                      out_dir2=1;
 196   2                  else if(par_speed<0)
 197   2                      out_dir2=0;
 198   2                  out_en2=0;
 199   2                  break;
 200   2              case mot_dj3://向上为正转,向下为反转
 201   2                  out_motorselect=0;
 202   2                  if(par_speed>0)
 203   2                      out_dir1=0;
 204   2                  else if(par_speed<0)
 205   2                      out_dir1=1;
 206   2                  out_en1=0;
 207   2                  break;
 208   2              case mot_dj4://顺时针为正转,逆时针为反转
 209   2                  out_motorselect=0;
 210   2                  if(par_speed>0)
 211   2                      out_dir2=0;
 212   2                  else if(par_speed<0)
 213   2                      out_dir2=1;
 214   2                  out_en2=0;
 215   2                  break;
 216   2              default:
 217   2                  break;
 218   2          }
 219   1      }//启动电机
 220          void fun_stop(enum varENU_mot par_model){
 221   1          switch(par_model){
 222   2              case mot_l:
 223   2                  fun_pwml(0);out_pwml=0;break;
 224   2              case mot_r:
 225   2                  fun_pwmr(0);out_pwmr=0;break;
 226   2              case mot_rl:
 227   2                  CR=0;
 228   2                  fun_pwmr(0);out_pwmr=0;
 229   2                  fun_pwml(0);out_pwml=0;
 230   2                  break;
 231   2              case mot_dj1:
 232   2                  out_motorselect=1;out_dir1=0;out_en1=1;break;
 233   2              case mot_dj2:
 234   2                  out_motorselect=1;out_dir2=0;out_en2=1;break;
 235   2              case mot_dj3:
 236   2                  out_motorselect=0;out_dir1=0;out_en1=1;break;
 237   2              case mot_dj4:
 238   2                  out_motorselect=0;out_dir2=0;out_en2=1;break;
 239   2              default:
 240   2                  break;
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 5   

 241   2          }
 242   1      }//停止电机
 243          void fun_sz1(enum varENU_han par_model){
 244   1          if(par_model==han_s){//手抓松
 245   2              while(1){
 246   3                  fun_startdj(mot_dj1,-100);
 247   3                  while(in_s==1);
 248   3                  fun_delay(20,del_ms);
 249   3                  if(in_s==0)
 250   3                      break;
 251   3              }
 252   2          }
 253   1          else{//手抓紧
 254   2              while(1){
 255   3                  fun_startdj(mot_dj1,100);
 256   3                  while(in_j==1);
 257   3                  fun_delay(20,del_ms);
 258   3                  if(in_j==0)
 259   3                      break;
 260   3              }
 261   2          }
 262   1          fun_stop(mot_dj1);
 263   1          str_begin.szzt=par_model;//存储运行结果
 264   1      }//手抓单步运动
 265          void fun_sj1(enum varENU_sjp par_model){
 266   1          if(par_model==str_begin.sjwz)
 267   1             return;
 268   1          switch(par_model){
 269   2              case sjp_wz1://升降位置1(最上位)
 270   2                  fun_startdj(mot_dj3,100);
 271   2                  fun_select(sel_58);
 272   2                  fun_delay(50,del_ms);
 273   2                  while(1){//只有向上
 274   3                      while(in_wz1==1);
 275   3                      fun_delay(20,del_ms);
 276   3                      if(in_wz1==0){
 277   4                          fun_delay(20,del_ms);
 278   4                          break;                    
 279   4                      }
 280   3                  }
 281   2                  break;
 282   2              case sjp_wz12:
 283   2                  if(par_model>str_begin.sjwz){
 284   3                      fun_startdj(mot_dj3,-100);
 285   3                      fun_delay(str_cod.sj1zjw,del_ms);
 286   3                  }
 287   2                  else{//要去的地方在上面，向上走
 288   3                      fun_sj1(sjp_wz2);
 289   3                      fun_startdj(mot_dj3,100);
 290   3                      fun_delay(str_cod.sj1zjw,del_ms);
 291   3                  }
 292   2                  break;
 293   2              case sjp_wz2://升降位置2
 294   2                  if(par_model>str_begin.sjwz)
 295   2                      fun_startdj(mot_dj3,-100);
 296   2                  else
 297   2                      fun_startdj(mot_dj3,100);
 298   2                  fun_select(sel_58);
 299   2                  fun_delay(50,del_ms);
 300   2                  while(1){//要去的地方比较靠下,向下走                    
 301   3                      while(in_wz2==1);
 302   3                      fun_delay(20,del_ms);
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 6   

 303   3                      if(in_wz2==0){
 304   4                          fun_delay(str_cod.sj1bzw,del_ms);
 305   4                          break;
 306   4                      }
 307   3                  }
 308   2                  break;
 309   2              case sjp_wz23:
 310   2                  if(par_model>str_begin.sjwz){
 311   3                      fun_sj1(sjp_wz2);
 312   3                      fun_startdj(mot_dj3,-100);
 313   3                      fun_delay(str_cod.sj1zjw,del_ms);
 314   3                  }
 315   2                  else{//要去的地方在上面，向上走
 316   3                      fun_sj1(sjp_wz3);
 317   3                      fun_startdj(mot_dj3,100);
 318   3                      fun_delay(str_cod.sj1zjw,del_ms);
 319   3                  }
 320   2                  break;
 321   2              case sjp_wz3://升降位置3
 322   2                  if(par_model>str_begin.sjwz)
 323   2                      fun_startdj(mot_dj3,-100);
 324   2                  else
 325   2                      fun_startdj(mot_dj3,100);
 326   2                  fun_select(sel_58);
 327   2                  fun_delay(50,del_ms);
 328   2                  while(1){
 329   3                      while(in_wz3==1);
 330   3                      fun_delay(str_cod.sj1bzw,del_ms);
 331   3                      if(in_wz3==0)
 332   3                          break;
 333   3                  }
 334   2                  break;
 335   2              case sjp_wz34:
 336   2                  if(par_model>str_begin.sjwz){
 337   3                      fun_sj1(sjp_wz3);
 338   3                      fun_startdj(mot_dj3,-100);
 339   3                      fun_delay(str_cod.sj1zjw,del_ms);
 340   3                  }
 341   2                  else{//要去的地方在上面，向上走
 342   3                      fun_sj1(sjp_wz4);
 343   3                      fun_startdj(mot_dj3,100);
 344   3                      fun_delay(str_cod.sj1zjw,del_ms);
 345   3                  }
 346   2                  break;
 347   2              case sjp_wz4://升降位置4
 348   2                  if(par_model>str_begin.sjwz)
 349   2                      fun_startdj(mot_dj3,-100);
 350   2                  else
 351   2                      fun_startdj(mot_dj3,100);
 352   2                  fun_select(sel_58);
 353   2                  fun_delay(50,del_ms);
 354   2                  while(1){
 355   3                      while(in_wz4==1);
 356   3                      fun_delay(str_cod.sj1bzw,del_ms);
 357   3                      if(in_wz4==0)
 358   3                          break;
 359   3                  }
 360   2                  break;
 361   2              case sjp_wz45:
 362   2                  if(par_model>str_begin.sjwz){
 363   3                      fun_sj1(sjp_wz4);
 364   3                      fun_startdj(mot_dj3,-100);
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 7   

 365   3                      fun_delay(str_cod.sj1zjw,del_ms);
 366   3                  }
 367   2                  else{//要去的地方在上面，向上走
 368   3                      fun_startdj(mot_dj3,100);
 369   3                      fun_delay(str_cod.sj1zjw,del_ms);
 370   3                  }
 371   2                  break;
 372   2              case sjp_wz5://升降位置5
 373   2                  fun_startdj(mot_dj3,-100);
 374   2                  fun_select(sel_912);
 375   2                  fun_delay(50,del_ms);
 376   2                  while(1){//要去的地方比较靠下,向下走                
 377   3                      while(in_wz5==1);
 378   3                      fun_delay(20,del_ms);
 379   3                      if(in_wz5==0){
 380   4                          fun_delay(str_cod.sj1bzw,del_ms);
 381   4                          break;
 382   4                      }
 383   3                  }
 384   2                  break;
 385   2              default:
 386   2                  break;
 387   2          }
 388   1          fun_stop(mot_dj3);
 389   1          str_begin.sjwz=par_model;//存储运行结果
 390   1      }//升降单步运动
 391          void fun_py1(enum varENU_tra par_model){
 392   1          switch(par_model){
 393   2              case tra_q://前平移(没有电机的呢个方向)
 394   2                  while(1){
 395   3                      fun_startdj(mot_dj2,100);
 396   3                      while(in_qpy==1);
 397   3                      fun_delay(20,del_ms);
 398   3                      if(in_qpy==0){
 399   4                          fun_delay(20,del_ms);
 400   4                          break;
 401   4                      }
 402   3                  }
 403   2                  break;
 404   2              case tra_kq:
 405   2                  switch(str_begin.pywz){
 406   3                      case tra_q:
 407   3                          fun_startdj(mot_dj2,-100);
 408   3                          fun_delay(str_cod.py1qkq,del_ms);
 409   3                          break;
 410   3                      case tra_z:
 411   3                          fun_startdj(mot_dj2,100);
 412   3                          fun_delay(str_cod.py1kqz,del_ms);
 413   3                          break;
 414   3                      case tra_kh:
 415   3                          fun_startdj(mot_dj2,100);
 416   3                          fun_delay(str_cod.py1kqkh,del_ms);
 417   3                          break;
 418   3                      case tra_h:
 419   3                          fun_startdj(mot_dj2,100);
 420   3                          fun_delay(str_cod.py1kqh,del_ms);
 421   3                          break;
 422   3                  }
 423   2                  break;
 424   2              case tra_z:
 425   2                  switch(str_begin.pywz){
 426   3                      case tra_q:
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 8   

 427   3                          fun_startdj(mot_dj2,-100);
 428   3                          fun_delay(str_cod.py1qz,del_ms);
 429   3                          break;
 430   3                      case tra_kq:
 431   3                          fun_startdj(mot_dj2,-100);
 432   3                          fun_delay(str_cod.py1kqz,del_ms);
 433   3                          break;
 434   3                      case tra_kh:
 435   3                          fun_startdj(mot_dj2,100);
 436   3                          fun_delay(str_cod.py1zkh,del_ms);
 437   3                          break;
 438   3                      case tra_h:
 439   3                          fun_startdj(mot_dj2,100);
 440   3                          fun_delay(str_cod.py1zh,del_ms);
 441   3                          break;
 442   3                  }
 443   2                  break;
 444   2              case tra_kh:
 445   2                  switch(str_begin.pywz){
 446   3                      case tra_q:
 447   3                          fun_startdj(mot_dj2,-100);
 448   3                          fun_delay(str_cod.py1qkh,del_ms);
 449   3                          break;
 450   3                      case tra_kq:
 451   3                          fun_startdj(mot_dj2,-100);
 452   3                          fun_delay(str_cod.py1kqkh,del_ms);
 453   3                          break;
 454   3                      case tra_z:
 455   3                          fun_startdj(mot_dj2,-100);
 456   3                          fun_delay(str_cod.py1zkh,del_ms);
 457   3                          break;
 458   3                      case tra_h:
 459   3                          fun_startdj(mot_dj2,100);
 460   3                          fun_delay(str_cod.py1khh,del_ms);
 461   3                          break;
 462   3                  }
 463   2                  break;
 464   2              case tra_h://后平移(有电机的呢个方向)
 465   2                  while(1){
 466   3                      fun_startdj(mot_dj2,-100);
 467   3                      while(in_hpy==1);
 468   3                      fun_delay(20,del_ms);
 469   3                      if(in_hpy==0){
 470   4                          fun_delay(20,del_ms);
 471   4                          break;
 472   4                      }
 473   3                  }
 474   2                  break;
 475   2              default:
 476   2                  break;
 477   2          }
 478   1          fun_stop(mot_dj2);
 479   1          str_begin.pywz=par_model;//存储运行结果
 480   1      }//平移单步运动
 481          void fun_hz1(enum varENU_dir par_model){
 482   1          fun_select(sel_912);
 483   1          switch(par_model){
 484   2              case dir_up://回转至前方
 485   2                  switch(str_begin.hzfx){
 486   3                      case dir_down://现在在下方
 487   3                          fun_startdj(mot_dj4,-100);
 488   3                          fun_delay(1,del_s);
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 9   

 489   3                          while(1){
 490   4                              while(in_hz==1);
 491   4                              fun_delay(25,del_ms);
 492   4                              if(in_hz==0)
 493   4                                  break;
 494   4                          }
 495   3                          while(1){
 496   4                              while(in_hz==0);
 497   4                              fun_delay(25,del_ms);
 498   4                              if(in_hz==1)
 499   4                                  break;
 500   4                          }
 501   3                          while(1){
 502   4                              while(in_hz==1);
 503   4                              fun_delay(25,del_ms);
 504   4                              if(in_hz==0)
 505   4                                  break;
 506   4                          }
 507   3                          break;
 508   3                      case dir_left://现在在左边
 509   3                          fun_startdj(mot_dj4,100);
 510   3                          fun_delay(1,del_s);
 511   3                          while(1){
 512   4                              while(in_hz==1);
 513   4                              fun_delay(25,del_ms);
 514   4                              if(in_hz==0)
 515   4                                  break;
 516   4                          }
 517   3                          break;
 518   3                      case dir_right://现在在右边
 519   3                          fun_startdj(mot_dj4,-100);
 520   3                          fun_delay(1,del_s);
 521   3                          while(1){
 522   4                              while(in_hz==1);
 523   4                              fun_delay(25,del_ms);
 524   4                              if(in_hz==0)
 525   4                                  break;
 526   4                          }
 527   3                          break;
 528   3                      default:
 529   3                          break;
 530   3                  }
 531   2                  break;
 532   2              case dir_down://要去下面
 533   2                  switch(str_begin.hzfx){
 534   3                      case dir_up://现在在上面
 535   3                          fun_startdj(mot_dj4,100);
 536   3                          fun_delay(1,del_s);
 537   3                          while(1){
 538   4                              while(in_hz==1);
 539   4                              fun_delay(25,del_ms);
 540   4                              if(in_hz==0)
 541   4                                  break;
 542   4                          }
 543   3                          while(1){
 544   4                              while(in_hz==0);
 545   4                              fun_delay(25,del_ms);
 546   4                              if(in_hz==1)
 547   4                                  break;
 548   4                          }
 549   3                          while(1){
 550   4                              while(in_hz==1);
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 10  

 551   4                              fun_delay(25,del_ms);
 552   4                              if(in_hz==0)
 553   4                                  break;
 554   4                          }
 555   3                          break;
 556   3                      case dir_left://现在在左面
 557   3                          fun_startdj(mot_dj4,-100);
 558   3                          fun_delay(1,del_s);
 559   3                          while(1){
 560   4                              while(in_hz==1);
 561   4                              fun_delay(25,del_ms);
 562   4                              if(in_hz==0)
 563   4                                  break;
 564   4                          }
 565   3                          break;
 566   3                      case dir_right://现在在右面
 567   3                          fun_startdj(mot_dj4,100);
 568   3                          fun_delay(1,del_s);
 569   3                          while(1){
 570   4                              while(in_hz==1);
 571   4                              fun_delay(25,del_ms);
 572   4                              if(in_hz==0)
 573   4                                  break;
 574   4                          }
 575   3                          break;
 576   3                      default:
 577   3                          break;
 578   3                  }
 579   2                  break;
 580   2              case dir_left://要去左边
 581   2                  switch(str_begin.hzfx){
 582   3                      case dir_up://现在在上面
 583   3                          fun_startdj(mot_dj4,-100);
 584   3                          fun_delay(1,del_s);
 585   3                          while(1){
 586   4                              while(in_hz==1);
 587   4                              fun_delay(25,del_ms);
 588   4                              if(in_hz==0)
 589   4                                  break;
 590   4                          }
 591   3                          break;
 592   3                      case dir_down://现在在下面
 593   3                          fun_startdj(mot_dj4,100);
 594   3                          fun_delay(1,del_s);
 595   3                          while(1){
 596   4                              while(in_hz==1);
 597   4                              fun_delay(25,del_ms);
 598   4                              if(in_hz==0)
 599   4                                  break;
 600   4                          }
 601   3                          break;
 602   3                      case dir_right://现在在右面
 603   3                          fun_startdj(mot_dj4,-100);
 604   3                          fun_delay(1,del_s);
 605   3                          while(1){
 606   4                              while(in_hz==1);
 607   4                              fun_delay(25,del_ms);
 608   4                              if(in_hz==0)
 609   4                                  break;
 610   4                          }
 611   3                          while(1){
 612   4                              while(in_hz==0);
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 11  

 613   4                              fun_delay(25,del_ms);
 614   4                              if(in_hz==1)
 615   4                                  break;
 616   4                          }
 617   3                          while(1){
 618   4                              while(in_hz==1);
 619   4                              fun_delay(25,del_ms);
 620   4                              if(in_hz==0){
 621   5                                  break;
 622   5                              }
 623   4                          }
 624   3                          break;
 625   3                      default:
 626   3                          break;
 627   3                  }
 628   2                  break;
 629   2              case dir_right://要去右面
 630   2                  switch(str_begin.hzfx){
 631   3                      case dir_up://现在在前面
 632   3                          fun_startdj(mot_dj4,100);
 633   3                          fun_delay(1,del_s);
 634   3                          while(1){
 635   4                              while(in_hz==1);
 636   4                              fun_delay(25,del_ms);
 637   4                              if(in_hz==0)
 638   4                                  break;
 639   4                          }
 640   3                          break;
 641   3                      case dir_down://现在在下面
 642   3                          fun_startdj(mot_dj4,-100);
 643   3                          fun_delay(1,del_s);
 644   3                          while(1){
 645   4                              while(in_hz==1);
 646   4                              fun_delay(25,del_ms);
 647   4                              if(in_hz==0)
 648   4                                  break;
 649   4                          }
 650   3                          break;
 651   3                      case dir_left://现在在左面
 652   3                          fun_startdj(mot_dj4,100);
 653   3                          fun_delay(1,del_s);
 654   3                          while(1){
 655   4                              while(in_hz==1);
 656   4                              fun_delay(25,del_ms);
 657   4                              if(in_hz==0)
 658   4                                  break;
 659   4                          }
 660   3                          while(1){
 661   4                              while(in_hz==0);
 662   4                              fun_delay(25,del_ms);
 663   4                              if(in_hz==1)
 664   4                                  break;
 665   4                          }
 666   3                          while(1){
 667   4                              while(in_hz==1);
 668   4                              fun_delay(25,del_ms);
 669   4                              if(in_hz==0){
 670   5                                  break;
 671   5                              }
 672   4                          }
 673   3                          break;
 674   3                      default:
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 12  

 675   3                          break;
 676   3                  }
 677   2                  break;
 678   2              default:
 679   2                  break;
 680   2          }
 681   1          fun_stop(mot_dj4);
 682   1          str_begin.hzfx=par_model;//存储运行结果
 683   1      }//回转单步运动
 684          void fun_pyhz2(enum varENU_tra par_py,enum varENU_dir par_hz){
 685   1          if(str_begin.hzfx!=par_hz){
 686   2              fun_py1(tra_z);
 687   2              switch(par_hz){//启动回转,在位则不启动
 688   3                  case dir_up://回转至前方
 689   3                      switch(str_begin.hzfx){
 690   4                          case dir_down://现在在下方
 691   4                              fun_startdj(mot_dj4,-100);
 692   4                              break;
 693   4                          case dir_left://现在在左边
 694   4                              fun_startdj(mot_dj4,100);
 695   4                              break;
 696   4                          case dir_right://现在在右边
 697   4                              fun_startdj(mot_dj4,-100);
 698   4                              break;
 699   4                          default:
 700   4                              break;
 701   4                      }
 702   3                      break;
 703   3                  case dir_down://要去下面
 704   3                      switch(str_begin.hzfx){
 705   4                          case dir_up://现在在上面
 706   4                              fun_startdj(mot_dj4,100);
 707   4                              break;
 708   4                          case dir_left://现在在左面
 709   4                              fun_startdj(mot_dj4,-100);
 710   4                              break;
 711   4                          case dir_right://现在在右面
 712   4                              fun_startdj(mot_dj4,100);
 713   4                              break;
 714   4                          default:
 715   4                              break;
 716   4                      }
 717   3                      break;
 718   3                  case dir_left://要去左边
 719   3                      switch(str_begin.hzfx){
 720   4                          case dir_up://现在在上面
 721   4                              fun_startdj(mot_dj4,-100);
 722   4                              break;
 723   4                          case dir_down://现在在下面
 724   4                              fun_startdj(mot_dj4,100);
 725   4                              break;
 726   4                          case dir_right://现在在右面
 727   4                              fun_startdj(mot_dj4,-100);
 728   4                              break;
 729   4                          default:
 730   4                              break;
 731   4                      }
 732   3                      break;
 733   3                  case dir_right://要去右面
 734   3                      switch(str_begin.hzfx){
 735   4                          case dir_up://现在在前面
 736   4                              fun_startdj(mot_dj4,100);
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 13  

 737   4                              break;
 738   4                          case dir_down://现在在下面
 739   4                              fun_startdj(mot_dj4,-100);
 740   4                              break;
 741   4                          case dir_left://现在在左面
 742   4                              fun_startdj(mot_dj4,100);
 743   4                              break;
 744   4                          default:
 745   4                              break;
 746   4                      }
 747   3                      break;
 748   3                  default:
 749   3                      break;
 750   3              }
 751   2          }
 752   1          switch(par_py){
 753   2              case tra_q://前平移(没有电机的呢个方向)
 754   2                  while(1){
 755   3                      fun_startdj(mot_dj2,100);
 756   3                      while(in_qpy==1);
 757   3                      fun_delay(20,del_ms);
 758   3                      if(in_qpy==0){
 759   4                          fun_delay(20,del_ms);
 760   4                          break;
 761   4                      }
 762   3                  }
 763   2                  break;
 764   2              case tra_kq:
 765   2                  fun_startdj(mot_dj2,100);
 766   2                  fun_delay(str_cod.py1kqz,del_ms);
 767   2                  break;
 768   2              case tra_kh:
 769   2                  fun_startdj(mot_dj2,-100);
 770   2                  fun_delay(str_cod.py1zkh,del_ms);
 771   2                  break;
 772   2              case tra_h://后平移(有电机的呢个方向)
 773   2                  while(1){
 774   3                      fun_startdj(mot_dj2,-100);
 775   3                      while(in_hpy==1);
 776   3                      fun_delay(20,del_ms);
 777   3                      if(in_hpy==0){
 778   4                          fun_delay(20,del_ms);
 779   4                          break;
 780   4                      }
 781   3                  }
 782   2                  break;
 783   2              default:
 784   2                  break;
 785   2          }
 786   1          fun_stop(mot_dj2);
 787   1          str_begin.pywz=par_py;//存储平移位置
 788   1          if(str_begin.hzfx!=par_hz){
 789   2              fun_select(sel_912);
 790   2              switch(par_hz){
 791   3                  case dir_up://回转至前方
 792   3                      switch(str_begin.hzfx){
 793   4                          case dir_down://现在在下方
 794   4                              while(1){
 795   5                                  while(in_hz==1);
 796   5                                  fun_delay(25,del_ms);
 797   5                                  if(in_hz==0)
 798   5                                      break;
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 14  

 799   5                              }
 800   4                              while(1){
 801   5                                  while(in_hz==0);
 802   5                                  fun_delay(1,del_s);
 803   5                                  if(in_hz==1)
 804   5                                      break;
 805   5                              }
 806   4                              while(1){
 807   5                                  while(in_hz==1);
 808   5                                  fun_delay(25,del_ms);
 809   5                                  if(in_hz==0)
 810   5                                      break;
 811   5                              }
 812   4                              break;
 813   4                          case dir_left://现在在左边
 814   4                              while(1){
 815   5                                  while(in_hz==1);
 816   5                                  fun_delay(25,del_ms);
 817   5                                  if(in_hz==0)
 818   5                                      break;
 819   5                              }
 820   4                              break;
 821   4                          case dir_right://现在在右边
 822   4                              while(1){
 823   5                                  while(in_hz==1);
 824   5                                  fun_delay(25,del_ms);
 825   5                                  if(in_hz==0)
 826   5                                      break;
 827   5                              }
 828   4                              break;
 829   4                          default:
 830   4                              break;
 831   4                      }
 832   3                      break;
 833   3                  case dir_down://要去下面
 834   3                      switch(str_begin.hzfx){
 835   4                          case dir_up://现在在上面
 836   4                              while(1){
 837   5                                  while(in_hz==1);
 838   5                                  fun_delay(25,del_ms);
 839   5                                  if(in_hz==0)
 840   5                                      break;
 841   5                              }
 842   4                              while(1){
 843   5                                  while(in_hz==0);
 844   5                                  fun_delay(1,del_s);
 845   5                                  if(in_hz==1)
 846   5                                      break;
 847   5                              }
 848   4                              while(1){
 849   5                                  while(in_hz==1);
 850   5                                  fun_delay(25,del_ms);
 851   5                                  if(in_hz==0)
 852   5                                      break;
 853   5                              }
 854   4                              break;
 855   4                          case dir_left://现在在左面
 856   4                              while(1){
 857   5                                  while(in_hz==1);
 858   5                                  fun_delay(25,del_ms);
 859   5                                  if(in_hz==0)
 860   5                                      break;
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 15  

 861   5                              }
 862   4                              break;
 863   4                          case dir_right://现在在右面
 864   4                              while(1){
 865   5                                  while(in_hz==1);
 866   5                                  fun_delay(25,del_ms);
 867   5                                  if(in_hz==0)
 868   5                                      break;
 869   5                              }
 870   4                              break;
 871   4                          default:
 872   4                              break;
 873   4                      }
 874   3                      break;
 875   3                  case dir_left://要去左边
 876   3                      switch(str_begin.hzfx){
 877   4                          case dir_up://现在在上面
 878   4                              while(1){
 879   5                                  while(in_hz==1);
 880   5                                  fun_delay(25,del_ms);
 881   5                                  if(in_hz==0)
 882   5                                      break;
 883   5                              }
 884   4                              break;
 885   4                          case dir_down://现在在下面
 886   4                              while(1){
 887   5                                  while(in_hz==1);
 888   5                                  fun_delay(25,del_ms);
 889   5                                  if(in_hz==0)
 890   5                                      break;
 891   5                              }
 892   4                              break;
 893   4                          case dir_right://现在在右面
 894   4                              while(1){
 895   5                                  while(in_hz==1);
 896   5                                  fun_delay(25,del_ms);
 897   5                                  if(in_hz==0)
 898   5                                      break;
 899   5                              }
 900   4                              while(1){
 901   5                                  while(in_hz==0);
 902   5                                  fun_delay(1,del_s);
 903   5                                  if(in_hz==1)
 904   5                                      break;
 905   5                              }
 906   4                              while(1){
 907   5                                  while(in_hz==1);
 908   5                                  fun_delay(25,del_ms);
 909   5                                  if(in_hz==0){
 910   6                                      break;
 911   6                                  }
 912   5                              }
 913   4                              break;
 914   4                          default:
 915   4                              break;
 916   4                      }
 917   3                      break;
 918   3                  case dir_right://要去右面
 919   3                      switch(str_begin.hzfx){
 920   4                          case dir_up://现在在前面
 921   4                              while(1){
 922   5                                  while(in_hz==1);
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 16  

 923   5                                  fun_delay(25,del_ms);
 924   5                                  if(in_hz==0)
 925   5                                      break;
 926   5                              }
 927   4                              break;
 928   4                          case dir_down://现在在下面
 929   4                              while(1){
 930   5                                  while(in_hz==1);
 931   5                                  fun_delay(25,del_ms);
 932   5                                  if(in_hz==0)
 933   5                                      break;
 934   5                              }
 935   4                              break;
 936   4                          case dir_left://现在在左面
 937   4                              while(1){
 938   5                                  while(in_hz==1);
 939   5                                  fun_delay(25,del_ms);
 940   5                                  if(in_hz==0)
 941   5                                      break;
 942   5                              }
 943   4                              while(1){
 944   5                                  while(in_hz==0);
 945   5                                  fun_delay(1,del_s);
 946   5                                  if(in_hz==1)
 947   5                                      break;
 948   5                              }
 949   4                              while(1){
 950   5                                  while(in_hz==1);
 951   5                                  fun_delay(25,del_ms);
 952   5                                  if(in_hz==0){
 953   6                                      break;
 954   6                                  }
 955   5                              }
 956   4                              break;
 957   4                          default:
 958   4                              break;
 959   4                      }
 960   3                      break;
 961   3                  default:
 962   3                      break;
 963   3              }
 964   2              fun_stop(mot_dj4);
 965   2              str_begin.hzfx=par_hz;//存储回转位置
 966   2          }
 967   1      }//回转单步运动
 968          void fun_mptline(uc par_num,uc par_sd,enum varENU_dir par_model){
 969   1          bit loc_flag=0;
 970   1          ui loc_i;
 971   1          uc loc_con=0;
 972   1          uc loc_l=par_sd,loc_r=par_sd;
 973   1          for(loc_i=2;loc_i<par_sd;fun_startdj(mot_rl,loc_i++))//软起动
 974   1              fun_delay(str_cod.mlinerqd/par_sd,del_ms);
 975   1          while(1){
 976   2              loc_l=par_sd;//恢复默认参数
 977   2              loc_r=par_sd;
 978   2              if((in_ls1&&in_ls7)||(in_ls2&&in_ls8)){//巡线计数
 979   3                  loc_flag=1;
 980   3                  if(loc_con>=par_num){
 981   4                      if(par_model==dir_left){//左转
 982   5                          fun_startdj(mot_l,-20);
 983   5                          fun_delay(500,del_ms);
 984   5                          while(1){
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 17  

 985   6                              while(!in_ls4||!in_ls5);
 986   6                              fun_delay(100,del_us);
 987   6                              if(in_ls4&&in_ls5){
 988   7                                  fun_stop(mot_rl);
 989   7                                  return;
 990   7                              }
 991   6                          }
 992   5                      }
 993   4                      else if(par_model==dir_right){
 994   5                          fun_startdj(mot_r,-20);
 995   5                          fun_delay(500,del_ms);
 996   5                          while(1){
 997   6                              while(!in_ls4||!in_ls5);
 998   6                              fun_delay(100,del_us);
 999   6                              if(in_ls4&&in_ls5){
1000   7                                  fun_stop(mot_rl);
1001   7                                  return;
1002   7                              }
1003   6                          }
1004   5                      }
1005   4                  }
1006   3              }
1007   2              else if(loc_flag==1){
1008   3                  if(++loc_con>=par_num){
1009   4                      if(par_model==dir_up){
1010   5                          for(loc_i=0;loc_i<str_cod.mlineqc;loc_i++){
1011   6                              loc_l=par_sd*0.7;//恢复默认参数
1012   6                              loc_r=par_sd*0.7;
1013   6                              if(in_ls3){//纠偏
1014   7                                  loc_l*=0.9;
1015   7                                  loc_r*=1.1;
1016   7                              }
1017   6                              if(in_ls6){
1018   7                                  loc_l*=1.1;
1019   7                                  loc_r*=0.9;
1020   7                              }
1021   6                              if(in_ls2){
1022   7                                  loc_l*=0.8;
1023   7                                  loc_r*=1.2;
1024   7                              }
1025   6                              if(in_ls7){
1026   7                                  loc_l*=1.2;
1027   7                                  loc_r*=0.8;
1028   7                              }
1029   6                              if(in_ls1){
1030   7                                  loc_l*=0.7;
1031   7                                  loc_r*=1.3;
1032   7                              }
1033   6                              if(in_ls8){
1034   7                                  loc_l*=1.3;
1035   7                                  loc_r*=0.7;
1036   7                              }
1037   6                              fun_startdj(mot_l,loc_l);//更新电机参数
1038   6                              fun_startdj(mot_r,loc_r);
1039   6                              fun_delay(1,del_ms);
1040   6                          }
1041   5                          fun_stop(mot_rl);
1042   5                          return;
1043   5                      }
1044   4                  }
1045   3                  loc_flag=0;
1046   3              }
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 18  

1047   2              if(in_ls3){//纠偏
1048   3                  loc_l*=0.9;
1049   3                  loc_r*=1.1;
1050   3              }
1051   2              if(in_ls6){
1052   3                  loc_l*=1.1;
1053   3                  loc_r*=0.9;
1054   3              }  
1055   2              if(in_ls2){
1056   3                  loc_l*=0.8;
1057   3                  loc_r*=1.2;
1058   3              }
1059   2              if(in_ls7){
1060   3                  loc_l*=1.2;
1061   3                  loc_r*=0.8;
1062   3              }
1063   2              if(in_ls1){
1064   3                  loc_l*=0.7;
1065   3                  loc_r*=1.3;
1066   3              }
1067   2              if(in_ls8){
1068   3                  loc_l*=1.3;
1069   3                  loc_r*=0.7;
1070   3              }
1071   2              fun_startdj(mot_l,loc_l);//更新电机参数
1072   2              fun_startdj(mot_r,loc_r);
1073   2          }
1074   1      }//主函数普通巡线
1075          void fun_stope2prom(){
1076   1          IAP_CONTR = 0;                  //关闭IAP功能
1077   1          IAP_CMD = 0;                    //清除命令
1078   1          IAP_TRIG = 0;                   //清除触发寄存器
1079   1          IAP_ADDRH = 0x80;               //数据指针指向非EEPROM区
1080   1          IAP_ADDRL = 0;                  //清除IAP地址
1081   1      }//关闭EEPROM功能(IapIdle)
1082          uc fun_reade2prom(ui par_add){
1083   1          uc loc_dat;                     //数据缓冲区
1084   1          IAP_CONTR = 0x83;               //打开EEPROM功能,设置等待时间
1085   1          IAP_CMD = 1;                    //设置EEPROM读命令
1086   1          IAP_ADDRL = par_add;            //设置EEPROM地址低八位
1087   1          IAP_ADDRH = par_add >> 8;       //设置EEPROM地址高八位
1088   1          IAP_TRIG = 0x5a;                //触发
1089   1          IAP_TRIG = 0xa5;                //再次触发
1090   1          fun_delay(10,del_us);           //稍等一会儿
1091   1          loc_dat = IAP_DATA;             //读出EEPROM中的数据
1092   1          fun_stope2prom();               //关闭EEPROM功能
1093   1          return loc_dat;                 //返回读取结果
1094   1      }//读取EEPROM数据
1095          void fun_writee2prom(ui par_add,uc par_dat){
1096   1          IAP_CONTR = 0x83;               //打开EEPROM功能,设置等待时间
1097   1          IAP_CMD = 2;                    //设置EEPROM写入命令
1098   1          IAP_ADDRL = par_add;            //设置EEPROM地址低八位
1099   1          IAP_ADDRH = par_add >> 8;       //设置EEPROM地址高八位
1100   1          IAP_DATA = par_dat;             //写入数据
1101   1          IAP_TRIG = 0x5a;                //触发
1102   1          IAP_TRIG = 0xa5;                //再次触发
1103   1          fun_delay(10,del_us);           //稍等一会儿
1104   1          fun_stope2prom();               //关闭EEPROM功能
1105   1      }//写EEPROM数据
1106          void fun_cleane2prom(ui par_add){
1107   1          IAP_CONTR = 0x83;               //打开EEPROM功能,设置等待时间
1108   1          IAP_CMD = 3;                    //设置EEPROM擦除命令
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 19  

1109   1          IAP_ADDRL = par_add;            //设置EEPROM地址低八位
1110   1          IAP_ADDRH = par_add >> 8;       //设置EEPROM地址高八位
1111   1          IAP_TRIG = 0x5a;                //触发
1112   1          IAP_TRIG = 0xa5;                //再次触发
1113   1          fun_delay(10,del_us);           //稍等一会儿
1114   1          fun_stope2prom();               //关闭EEPROM功能
1115   1      }//清除EEPROM数据
1116          void fun_calibration(){
1117   1          // fun_sj1(sjp_wz1);//升到最上位
1118   1          fun_py1(tra_q);//移动到最前端
1119   1          fun_py1(tra_h);//移动到最后端
1120   1          def_timer0start//开始定时器
1121   1          fun_py1(tra_q);//移动到前端并计时
1122   1          fun_py1(tra_h);//移动到后端
1123   1          def_timer0stop//停止定时器
1124   1          var_timer0*=0.39;
1125   1          str_cod.py1zh=str_cod.py1qz=var_timer0*0.5;
1126   1          str_cod.py1qkh=str_cod.py1kqh=var_timer0*0.75;
1127   1          str_cod.py1qkq=str_cod.py1khh=var_timer0*0.25;
1128   1          str_cod.py1kqz=str_cod.py1zkh=var_timer0*0.25;
1129   1          str_cod.py1kqkh=var_timer0*0.5;
1130   1          var_timer0=0;
1131   1          OUT(var_timer0)
1132   1      }//自动校准参数
1133          void fun_port(){
1134   1          PCON|=0x80;       //使能波特率倍速位SMOD
1135   1          SCON=0x50;        //8位数据,可变波特率
1136   1          AUXR|=0x04;       //独立波特率发生器时钟为Fosc,即1T
1137   1          BRT=0xD9;     //设定独立波特率发生器重装值
1138   1          AUXR|=0x01;       //串口1选择独立波特率发生器为波特率发生器
1139   1          AUXR|=0x10;       //启动独立波特率发生器
1140   1          TI=1;//打开串口传输功能
1141   1      }//串口初始化
1142          void fun_zhuajian(
1143              uc par_01,uc par_02,uc par_03,uc par_04,uc par_41,uc par_42,uc par_43,uc par_44,
1144              uc par_31,uc par_32,uc par_33,uc par_34,uc par_71,uc par_72,uc par_73,uc par_74){
1145   1      
1146   1          xdata uc loc_data[8][5][2];//三维数组,8个区,5个高度
1147   1          xdata uc loc_high[8];
1148   1          xdata uc loc_high03;
1149   1          xdata uc loc_high47;
1150   1          xdata uc loc_high07;
1151   1          xdata uc loc_xh1,loc_xh2;
1152   1      
1153   1          memset(loc_data,0,sizeof(loc_data));//清空数组
1154   1          //起始区件号
1155   1          loc_data[0][1][0]=par_01;//传入形参:区0的第1号件件号(最高位)
1156   1          loc_data[0][2][0]=par_02;//传入形参:区0的第2号件件号
1157   1          loc_data[0][3][0]=par_03;//传入形参:区0的第3号件件号
1158   1          loc_data[0][4][0]=par_04;//传入形参:区0的第4号件件号(最低位)
1159   1          loc_data[4][1][0]=par_41;//传入形参:区4的第1号件件号(最高位)
1160   1          loc_data[4][2][0]=par_42;//传入形参:区4的第2号件件号
1161   1          loc_data[4][3][0]=par_43;//传入形参:区4的第3号件件号
1162   1          loc_data[4][4][0]=par_44;//传入形参:区4的第4号件件号(最低位)
1163   1          //目的区件号
1164   1          loc_data[3][1][0]=par_31;//传入形参:区0的第1号件件号(最高位)
1165   1          loc_data[3][2][0]=par_32;//传入形参:区0的第2号件件号
1166   1          loc_data[3][3][0]=par_33;//传入形参:区0的第3号件件号
1167   1          loc_data[3][4][0]=par_34;//传入形参:区0的第4号件件号(最低位)
1168   1          loc_data[7][1][0]=par_71;//传入形参:区4的第1号件件号(最高位)
1169   1          loc_data[7][2][0]=par_72;//传入形参:区4的第2号件件号
1170   1          loc_data[7][3][0]=par_73;//传入形参:区4的第3号件件号
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 20  

1171   1          loc_data[7][4][0]=par_74;//传入形参:区4的第4号件件号(最低位)
1172   1          //目的次序
1173   1          loc_data[3][1][1]=1;//标准次序:区3的第1号目的次序号(最高位)
1174   1          loc_data[3][2][1]=2;//标准次序:区3的第2号目的次序号
1175   1          loc_data[3][3][1]=3;//标准次序:区3的第3号目的次序号
1176   1          loc_data[3][4][1]=4;//标准次序:区3的第4号目的次序号(最低位)
1177   1          loc_data[7][1][1]=5;//标准次序:区7的第1号目的次序号(最高位)
1178   1          loc_data[7][2][1]=6;//标准次序:区7的第2号目的次序号
1179   1          loc_data[7][3][1]=7;//标准次序:区7的第3号目的次序号
1180   1          loc_data[7][4][1]=8;//标准次序:区7的第4号目的次序号(最低位)
1181   1          //根据形参统一次序
1182   1          for(loc_xh1=4;loc_xh1>0;loc_xh1--){
1183   2                   if((loc_data[0][loc_xh1][0]==loc_data[3][1][0])&&(loc_data[0][loc_xh1][0]!=0))
1184   2                  loc_data[0][loc_xh1][1]=loc_data[3][1][1];
1185   2              else if((loc_data[0][loc_xh1][0]==loc_data[3][2][0])&&(loc_data[0][loc_xh1][0]!=0))
1186   2                  loc_data[0][loc_xh1][1]=loc_data[3][2][1];
1187   2              else if((loc_data[0][loc_xh1][0]==loc_data[3][3][0])&&(loc_data[0][loc_xh1][0]!=0))
1188   2                  loc_data[0][loc_xh1][1]=loc_data[3][3][1];
1189   2              else if((loc_data[0][loc_xh1][0]==loc_data[3][4][0])&&(loc_data[0][loc_xh1][0]!=0))
1190   2                  loc_data[0][loc_xh1][1]=loc_data[3][4][1];
1191   2              else if((loc_data[0][loc_xh1][0]==loc_data[7][1][0])&&(loc_data[0][loc_xh1][0]!=0))
1192   2                  loc_data[0][loc_xh1][1]=loc_data[7][1][1];
1193   2              else if((loc_data[0][loc_xh1][0]==loc_data[7][2][0])&&(loc_data[0][loc_xh1][0]!=0))
1194   2                  loc_data[0][loc_xh1][1]=loc_data[7][2][1];
1195   2              else if((loc_data[0][loc_xh1][0]==loc_data[7][3][0])&&(loc_data[0][loc_xh1][0]!=0))
1196   2                  loc_data[0][loc_xh1][1]=loc_data[7][3][1];
1197   2              else if((loc_data[0][loc_xh1][0]==loc_data[7][4][0])&&(loc_data[0][loc_xh1][0]!=0))
1198   2                  loc_data[0][loc_xh1][1]=loc_data[7][4][1];
1199   2      
1200   2                   if((loc_data[4][loc_xh1][0]==loc_data[3][1][0])&&(loc_data[4][loc_xh1][0]!=0))
1201   2                  loc_data[4][loc_xh1][1]=loc_data[3][1][1];
1202   2              else if((loc_data[4][loc_xh1][0]==loc_data[3][2][0])&&(loc_data[4][loc_xh1][0]!=0))
1203   2                  loc_data[4][loc_xh1][1]=loc_data[3][2][1];
1204   2              else if((loc_data[4][loc_xh1][0]==loc_data[3][3][0])&&(loc_data[4][loc_xh1][0]!=0))
1205   2                  loc_data[4][loc_xh1][1]=loc_data[3][3][1];
1206   2              else if((loc_data[4][loc_xh1][0]==loc_data[3][4][0])&&(loc_data[4][loc_xh1][0]!=0))
1207   2                  loc_data[4][loc_xh1][1]=loc_data[3][4][1];
1208   2              else if((loc_data[4][loc_xh1][0]==loc_data[7][1][0])&&(loc_data[4][loc_xh1][0]!=0))
1209   2                  loc_data[4][loc_xh1][1]=loc_data[7][1][1];
1210   2              else if((loc_data[4][loc_xh1][0]==loc_data[7][2][0])&&(loc_data[4][loc_xh1][0]!=0))
1211   2                  loc_data[4][loc_xh1][1]=loc_data[7][2][1];
1212   2              else if((loc_data[4][loc_xh1][0]==loc_data[7][3][0])&&(loc_data[4][loc_xh1][0]!=0))
1213   2                  loc_data[4][loc_xh1][1]=loc_data[7][3][1];
1214   2              else if((loc_data[4][loc_xh1][0]==loc_data[7][4][0])&&(loc_data[4][loc_xh1][0]!=0))
1215   2                  loc_data[4][loc_xh1][1]=loc_data[7][4][1];
1216   2          }
1217   1          //清空形参表(实际件序)
1218   1          for(loc_xh1=0;loc_xh1<=7;loc_xh1++)
1219   1              for(loc_xh2=0;loc_xh2<=4;loc_xh2++)
1220   1                  loc_data[loc_xh1][loc_xh2][0]=0;
1221   1          //转移04的序号
1222   1          for(loc_xh1=0;loc_xh1<=4;loc_xh1++){
1223   2              loc_data[0][loc_xh1][0]=loc_data[0][loc_xh1][1];
1224   2              loc_data[4][loc_xh1][0]=loc_data[4][loc_xh1][1];
1225   2          }
1226   1          //目的区除了3.7区全部清零
1227   1          for(loc_xh1=0;loc_xh1<=4;loc_xh1++){
1228   2              loc_data[0][loc_xh1][1]=0;
1229   2              loc_data[1][loc_xh1][1]=0;
1230   2              loc_data[2][loc_xh1][1]=0;
1231   2              loc_data[4][loc_xh1][1]=0;
1232   2              loc_data[5][loc_xh1][1]=0;
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 21  

1233   2              loc_data[6][loc_xh1][1]=0;
1234   2          }
1235   1          //8个区的循环
1236   1          for(loc_xh1=0;loc_xh1<=7;loc_xh1++){
1237   2              loc_high[loc_xh1]=4;//默认为没有件
1238   2              for(loc_xh2=0;loc_xh2<=4;loc_xh2++){//5个高度的循环
1239   3                  if(loc_data[loc_xh1][loc_xh2][0]!=0){//如果放了件了
1240   4                      loc_high[loc_xh1]=loc_xh2-1;//记录这个区最高空闲位置
1241   4                      break;//继续区的循环
1242   4                  }
1243   3              }
1244   2          }
1245   1      
1246   1          fun_sj1(sjp_wz1);
1247   1          fun_sz1(han_s);
1248   1      
1249   1          while(1){
1250   2              loc_high03=fun_min4(loc_high[0],loc_high[1],loc_high[2],loc_high[3]);
1251   2              loc_high47=fun_min4(loc_high[4],loc_high[5],loc_high[6],loc_high[7]);
1252   2              loc_high07=fun_min2(loc_high03,loc_high47);
1253   2              if(str_begin.hzfx==dir_left){
1254   3                  if(loc_high[0]<4){//如果区0有件
1255   4                      if(loc_data[0][loc_high[0]+1][0]==loc_data[3][loc_high[3]][1]){//如果区0最高位等于
             -区3最高位件
1256   5                          fun_sj1zt(loc_high03);//上升到03方最高位
1257   5                          fun_pyhz2(tra_h,dir_left);//抓件位置0
1258   5                          fun_sj1zt(loc_high[0]+1);//下降到区0最高位
1259   5                          fun_sz1(han_j);//抓件
1260   5                          fun_sj1zt(loc_high03);//上升到03方最高位
1261   5                          fun_pyhz2(tra_q,dir_left);//抓件位置3
1262   5                          fun_sj1zt(loc_high[3]);//下降到区3最高位
1263   5                          fun_sz1(han_s);//松件
1264   5      
1265   5                          loc_data[3][loc_high[3]+1][0]=loc_data[0][loc_high[0]+1][0];//件已经从0区拿到
             -3区
1266   5                          loc_data[0][loc_high[0]+1][0]=0;//0区木有了
1267   5                          loc_high[0]++;//更新区0最高位
1268   5                          loc_high[3]--;//更新区3最高位
1269   5                      }
1270   4                      else if(loc_data[0][loc_high[0]+1][0]==loc_data[7][loc_high[7]][1]){//如果区0最高位
             -于区7最高位件
1271   5                          fun_sj1zt(loc_high03);//上升到03方最高位
1272   5                          fun_pyhz2(tra_h,dir_left);//抓件位置0
1273   5                          fun_sj1zt(loc_high[0]+1);//下降到区0最高位
1274   5                          fun_sz1(han_j);//抓件
1275   5                          fun_sj1zt(loc_high07);//上升到07方最高位
1276   5                          fun_pyhz2(tra_h,dir_right);//抓件位置7
1277   5                          fun_sj1zt(loc_high[7]);//下降到区7最高位
1278   5                          fun_sz1(han_s);//松件
1279   5      
1280   5                          loc_data[7][loc_high[7]+1][0]=loc_data[0][loc_high[0]+1][0];//件已经从0区拿到
             -7区
1281   5                          loc_data[0][loc_high[0]+1][0]=0;//0区木有了
1282   5                          loc_high[0]++;//更新区0最高位
1283   5                          loc_high[7]--;//更新区7最高位
1284   5                      }
1285   4                      else{
1286   5                          if((loc_high[1]>=4)||(loc_data[0][loc_high[0]+1][0]>loc_data[1][loc_high[1]][0])){//
             -果区1能放得下,放在区1
1287   6                              fun_sj1zt(loc_high03);//上升到03方最高位
1288   6                              fun_pyhz2(tra_h,dir_left);//抓件位置0
1289   6                              fun_sj1zt(loc_high[0]+1);//下降到区0最高位
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 22  

1290   6                              fun_sz1(han_j);//抓件
1291   6                              fun_sj1zt(loc_high03);//上升到03方最高位
1292   6                              fun_pyhz2(tra_kh,dir_left);//抓件位置1
1293   6                              fun_sj1zt(loc_high[1]);//下降到区1最高位
1294   6                              fun_sz1(han_s);//松件
1295   6      
1296   6                              loc_data[1][loc_high[1]+1][0]=loc_data[0][loc_high[0]+1][0];//件已经从0区拿
             -了3区
1297   6                              loc_data[0][loc_high[0]+1][0]=0;//0区木有了
1298   6                              loc_high[0]++;//更新区0最高位
1299   6                              loc_high[1]--;//更新区3最高位
1300   6                          }
1301   5                          else{//否则放在区2
1302   6                              fun_sj1zt(loc_high03);//上升到03方最高位
1303   6                              fun_pyhz2(tra_h,dir_left);//抓件位置0
1304   6                              fun_sj1zt(loc_high[0]+1);//下降到区0最高位
1305   6                              fun_sz1(han_j);//抓件
1306   6                              fun_sj1zt(loc_high03);//上升到03方最高位
1307   6                              fun_pyhz2(tra_kq,dir_left);//抓件位置2
1308   6                              fun_sj1zt(loc_high[2]);//下降到区2最高位
1309   6                              fun_sz1(han_s);//松件
1310   6      
1311   6                              loc_data[2][loc_high[2]+1][0]=loc_data[0][loc_high[0]+1][0];//件已经从0区拿
             -了3区
1312   6                              loc_data[0][loc_high[0]+1][0]=0;//0区木有了
1313   6                              loc_high[0]++;//更新区0最高位
1314   6                              loc_high[2]--;//更新区3最高位
1315   6                          }
1316   5                      }
1317   4                  }
1318   3                  else if(loc_high[1]<4){//如果区1有件
1319   4                      if(loc_data[1][loc_high[1]+1][0]==loc_data[3][loc_high[3]][1]){//如果区1最高位等于
             -区3最高位件
1320   5                          fun_sj1zt(loc_high03);//上升到03方最高位
1321   5                          fun_pyhz2(tra_kh,dir_left);//抓件位置1
1322   5                          fun_sj1zt(loc_high[1]+1);//下降到区1最高位
1323   5                          fun_sz1(han_j);//抓件
1324   5                          fun_sj1zt(loc_high03);//上升到03方最高位
1325   5                          fun_pyhz2(tra_q,dir_left);//抓件位置2
1326   5                          fun_sj1zt(loc_high[3]);//下降到区2最高位
1327   5                          fun_sz1(han_s);//松件
1328   5      
1329   5                          loc_data[3][loc_high[3]+1][0]=loc_data[1][loc_high[1]+1][0];//件已经从1区拿到
             -3区
1330   5                          loc_data[1][loc_high[1]+1][0]=0;//1区木有了
1331   5                          loc_high[1]++;//更新区1最高位
1332   5                          loc_high[3]--;//更新区3最高位
1333   5                      }
1334   4                      else if(loc_data[1][loc_high[1]+1][0]==loc_data[7][loc_high[7]][1]){//如果区1最高位
             -于区7最高位件
1335   5                          fun_sj1zt(loc_high03);//上升到03方最高位
1336   5                          fun_pyhz2(tra_kh,dir_left);//抓件位置1
1337   5                          fun_sj1zt(loc_high[1]+1);//下降到区1最高位
1338   5                          fun_sz1(han_j);//抓件
1339   5                          fun_sj1zt(loc_high07);//上升到07方最高位
1340   5                          fun_pyhz2(tra_h,dir_right);//抓件位置7
1341   5                          fun_sj1zt(loc_high[7]);//下降到区7最高位
1342   5                          fun_sz1(han_s);//松件
1343   5      
1344   5                          loc_data[7][loc_high[7]+1][0]=loc_data[1][loc_high[1]+1][0];//件已经从1区拿到
             -7区
1345   5                          loc_data[1][loc_high[1]+1][0]=0;//1区木有了
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 23  

1346   5                          loc_high[1]++;//更新区1最高位
1347   5                          loc_high[7]--;//更新区3最高位
1348   5                      }
1349   4                      else if(loc_data[1][loc_high[1]+1][0]>loc_data[2][loc_high[2]][0]){//如果区2能放得
             -,放在区2
1350   5                          fun_sj1zt(loc_high03);//上升到03方最高位
1351   5                          fun_pyhz2(tra_kh,dir_left);//抓件位置1
1352   5                          fun_sj1zt(loc_high[1]+1);//下降到区1最高位
1353   5                          fun_sz1(han_j);//抓件
1354   5                          fun_sj1zt(loc_high03);//上升到03方最高位
1355   5                          fun_pyhz2(tra_kq,dir_left);//抓件位置2
1356   5                          fun_sj1zt(loc_high[2]);//下降到区2最高位
1357   5                          fun_sz1(han_s);//松件
1358   5      
1359   5                          loc_data[2][loc_high[2]+1][0]=loc_data[1][loc_high[1]+1][0];//件已经从1区拿到
             -2区
1360   5                          loc_data[1][loc_high[1]+1][0]=0;//1区木有了
1361   5                          loc_high[1]++;//更新区1最高位
1362   5                          loc_high[2]--;//更新区3最高位
1363   5                      }
1364   4                  }
1365   3                  else if(loc_high[2]<4){//如果区2有件
1366   4                      if(loc_data[2][loc_high[2]+1][0]==loc_data[3][loc_high[3]][1]){//如果区2最高位等于
             -区3最高位件
1367   5                          fun_sj1zt(loc_high03);//上升到03方最高位
1368   5                          fun_pyhz2(tra_kq,dir_left);//抓件位置2
1369   5                          fun_sj1zt(loc_high[2]+1);//下降到区2最高位
1370   5                          fun_sz1(han_j);//抓件
1371   5                          fun_sj1zt(loc_high03);//上升到03方最高位
1372   5                          fun_pyhz2(tra_q,dir_left);//抓件位置3
1373   5                          fun_sj1zt(loc_high[2]);//下降到区3最高位
1374   5                          fun_sz1(han_s);//松件
1375   5      
1376   5                          loc_data[3][loc_high[3]+1][0]=loc_data[2][loc_high[2]+1][0];//件已经从2区拿到
             -3区
1377   5                          loc_data[2][loc_high[2]+1][0]=0;//2区木有了
1378   5                          loc_high[2]++;//更新区2最高位
1379   5                          loc_high[3]--;//更新区3最高位
1380   5                      }
1381   4                      else if(loc_data[2][loc_high[2]+1][0]==loc_data[7][loc_high[7]][1]){//如果区2最高位
             -于区7最高位件
1382   5                          fun_sj1zt(loc_high03);//上升到03方最高位
1383   5                          fun_pyhz2(tra_kq,dir_left);//抓件位置2
1384   5                          fun_sj1zt(loc_high[2]+1);//下降到区2最高位
1385   5                          fun_sz1(han_j);//抓件
1386   5                          fun_sj1zt(loc_high07);//上升到07方最高位
1387   5                          fun_pyhz2(tra_h,dir_right);//抓件位置7
1388   5                          fun_sj1zt(loc_high[7]);//下降到区7最高位
1389   5                          fun_sz1(han_s);//松件
1390   5      
1391   5                          loc_data[7][loc_high[7]+1][0]=loc_data[2][loc_high[2]+1][0];//件已经从2区拿到
             -7区
1392   5                          loc_data[2][loc_high[2]+1][0]=0;//2区木有了
1393   5                          loc_high[2]++;//更新区2最高位
1394   5                          loc_high[7]--;//更新区7最高位
1395   5                      }
1396   4                  }
1397   3                  if((loc_data[3][4][0]==loc_data[3][4][1])&&
1398   3                     (loc_data[3][3][0]==loc_data[3][3][1])&&
1399   3                     (loc_data[3][2][0]==loc_data[3][2][1])&&
1400   3                     (loc_data[3][1][0]==loc_data[3][1][1])){
1401   4                      if((loc_data[7][4][0]==loc_data[7][4][1])&&
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 24  

1402   4                         (loc_data[7][3][0]==loc_data[7][3][1])&&
1403   4                         (loc_data[7][2][0]==loc_data[7][2][1])&&
1404   4                         (loc_data[7][1][0]==loc_data[7][1][1])){
1405   5                          return;
1406   5                      }
1407   4                      else
1408   4                          fun_hz1(dir_right);
1409   4                  }
1410   3              }
1411   2              else if(str_begin.hzfx==dir_right){
1412   3                  if(loc_high[4]<4){//如果区4有件
1413   4                      if(loc_data[4][loc_high[4]+1][0]==loc_data[7][loc_high[7]][1]){//如果区4最高位等于
             -区7最高位件
1414   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1415   5                          fun_pyhz2(tra_q,dir_right);//抓件位置4
1416   5                          fun_sj1zt(loc_high[4]+1);//下降到区4最高位
1417   5                          fun_sz1(han_j);//抓件
1418   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1419   5                          fun_pyhz2(tra_h,dir_right);//抓件位置7
1420   5                          fun_sj1zt(loc_high[7]);//下降到区7最高位
1421   5                          fun_sz1(han_s);//松件
1422   5      
1423   5                          loc_data[7][loc_high[7]+1][0]=loc_data[4][loc_high[4]+1][0];//件已经从4区拿到
             -7区
1424   5                          loc_data[4][loc_high[4]+1][0]=0;//4区木有了
1425   5                          loc_high[4]++;//更新区4最高位
1426   5                          loc_high[7]--;//更新区7最高位
1427   5                      }
1428   4                      else if(loc_data[4][loc_high[4]+1][0]==loc_data[3][loc_high[3]][1]){//如果区4最高位
             -于区3最高位件
1429   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1430   5                          fun_pyhz2(tra_q,dir_right);//抓件位置4
1431   5                          fun_sj1zt(loc_high[4]+1);//下降到区4最高位
1432   5                          fun_sz1(han_j);//抓件
1433   5                          fun_sj1zt(loc_high07);//上升到07方最高位
1434   5                          fun_pyhz2(tra_q,dir_left);//抓件位置3
1435   5                          fun_sj1zt(loc_high[3]);//下降到区3最高位
1436   5                          fun_sz1(han_s);//松件
1437   5      
1438   5                          loc_data[3][loc_high[3]+1][0]=loc_data[4][loc_high[4]+1][0];//件已经从4区拿到
             -3区
1439   5                          loc_data[4][loc_high[4]+1][0]=0;//4区木有了
1440   5                          loc_high[4]++;//更新区4最高位
1441   5                          loc_high[3]--;//更新区7最高位
1442   5                      }
1443   4                      else{
1444   5                          if((loc_high[6]>=4)||(loc_data[4][loc_high[4]+1][0]>loc_data[6][loc_high[6]][0])){//
             -果区6能放得下,放在区6
1445   6                              fun_sj1zt(loc_high47);//上升到47方最高位
1446   6                              fun_pyhz2(tra_q,dir_right);//抓件位置4
1447   6                              fun_sj1zt(loc_high[4]+1);//下降到区4最高位
1448   6                              fun_sz1(han_j);//抓件
1449   6                              fun_sj1zt(loc_high07);//上升到07方最高位
1450   6                              fun_pyhz2(tra_kq,dir_right);//抓件位置6
1451   6                              fun_sj1zt(loc_high[6]);//下降到区6最高位
1452   6                              fun_sz1(han_s);//松件
1453   6      
1454   6                              loc_data[6][loc_high[6]+1][0]=loc_data[4][loc_high[4]+1][0];//件已经从4区拿
             -了6区
1455   6                              loc_data[4][loc_high[4]+1][0]=0;//4区木有了
1456   6                              loc_high[4]++;//更新区4最高位
1457   6                              loc_high[6]--;//更新区6最高位
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 25  

1458   6                          }
1459   5                          else{//否则放在区5
1460   6                              fun_sj1zt(loc_high47);//上升到47方最高位
1461   6                              fun_pyhz2(tra_q,dir_right);//抓件位置4
1462   6                              fun_sj1zt(loc_high[4]+1);//下降到区4最高位
1463   6                              fun_sz1(han_j);//抓件
1464   6                              fun_sj1zt(loc_high47);//上升到47方最高位
1465   6                              fun_pyhz2(tra_kq,dir_right);//抓件位置2
1466   6                              fun_sj1zt(loc_high[5]);//下降到区5最高位
1467   6                              fun_sz1(han_s);//松件
1468   6      
1469   6                              loc_data[5][loc_high[5]+1][0]=loc_data[4][loc_high[4]+1][0];//件已经从4区拿
             -了5区
1470   6                              loc_data[4][loc_high[4]+1][0]=0;//4区木有了
1471   6                              loc_high[4]++;//更新区4最高位
1472   6                              loc_high[5]--;//更新区6最高位
1473   6                          }
1474   5                      }
1475   4                  }
1476   3                  else if(loc_high[5]<4){//如果区5有件
1477   4                      if(loc_data[5][loc_high[5]+1][0]==loc_data[7][loc_high[7]][1]){//如果区5最高位等于
             -区7最高位件
1478   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1479   5                          fun_pyhz2(tra_kq,dir_right);//抓件位置5
1480   5                          fun_sj1zt(loc_high[5]+1);//下降到区5最高位
1481   5                          fun_sz1(han_j);//抓件
1482   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1483   5                          fun_pyhz2(tra_h,dir_right);//抓件位置2
1484   5                          fun_sj1zt(loc_high[7]);//下降到区7最高位
1485   5                          fun_sz1(han_s);//松件
1486   5      
1487   5                          loc_data[7][loc_high[7]+1][0]=loc_data[5][loc_high[5]+1][0];//件已经从5区拿到
             -7区
1488   5                          loc_data[5][loc_high[5]+1][0]=0;//5区木有了
1489   5                          loc_high[5]++;//更新区5最高位
1490   5                          loc_high[7]--;//更新区7最高位
1491   5                      }
1492   4                      else if(loc_data[5][loc_high[5]+1][0]==loc_data[3][loc_high[3]][1]){//如果区5最高位
             -于区3最高位件
1493   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1494   5                          fun_pyhz2(tra_kq,dir_right);//抓件位置5
1495   5                          fun_sj1zt(loc_high[5]+1);//下降到区5最高位
1496   5                          fun_sz1(han_j);//抓件
1497   5                          fun_sj1zt(loc_high07);//上升到07方最高位
1498   5                          fun_pyhz2(tra_q,dir_left);//抓件位置3
1499   5                          fun_sj1zt(loc_high[3]);//下降到区3最高位
1500   5                          fun_sz1(han_s);//松件
1501   5      
1502   5                          loc_data[3][loc_high[3]+1][0]=loc_data[5][loc_high[5]+1][0];//件已经从5区拿到
             -3区
1503   5                          loc_data[5][loc_high[5]+1][0]=0;//5区木有了
1504   5                          loc_high[5]++;//更新区5最高位
1505   5                          loc_high[3]--;//更新区3最高位
1506   5                      }
1507   4                      else if(loc_data[5][loc_high[5]+1][0]>loc_data[6][loc_high[6]][0]){//如果区6能放得
             -,放在区6
1508   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1509   5                          fun_pyhz2(tra_kq,dir_right);//抓件位置5
1510   5                          fun_sj1zt(loc_high[5]+1);//下降到区5最高位
1511   5                          fun_sz1(han_j);//抓件
1512   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1513   5                          fun_pyhz2(tra_kh,dir_right);//抓件位置2
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 26  

1514   5                          fun_sj1zt(loc_high[6]);//下降到区7最高位
1515   5                          fun_sz1(han_s);//松件
1516   5      
1517   5                          loc_data[6][loc_high[6]+1][0]=loc_data[5][loc_high[5]+1][0];//件已经从5区拿到
             -6区
1518   5                          loc_data[5][loc_high[5]+1][0]=0;//5区木有了
1519   5                          loc_high[5]++;//更新区5最高位
1520   5                          loc_high[6]--;//更新区7最高位
1521   5                      }
1522   4                  }
1523   3                  else if(loc_high[6]<4){//如果区6有件
1524   4                      if(loc_data[6][loc_high[6]+1][0]==loc_data[7][loc_high[7]][1]){//如果区6最高位等于
             -区7最高位件
1525   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1526   5                          fun_pyhz2(tra_kh,dir_right);//抓件位置6
1527   5                          fun_sj1zt(loc_high[6]+1);//下降到区6最高位
1528   5                          fun_sz1(han_j);//抓件
1529   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1530   5                          fun_pyhz2(tra_h,dir_right);//抓件位置7
1531   5                          fun_sj1zt(loc_high[7]);//下降到区7最高位
1532   5                          fun_sz1(han_s);//松件
1533   5      
1534   5                          loc_data[7][loc_high[7]+1][0]=loc_data[6][loc_high[6]+1][0];//件已经从6区拿到
             -7区
1535   5                          loc_data[6][loc_high[6]+1][0]=0;//2区木有了
1536   5                          loc_high[6]++;//更新区2最高位
1537   5                          loc_high[7]--;//更新区7最高位
1538   5                      }
1539   4                      else if(loc_data[6][loc_high[6]+1][0]==loc_data[3][loc_high[3]][1]){//如果区6最高位
             -于区3最高位件
1540   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1541   5                          fun_pyhz2(tra_kh,dir_right);//抓件位置6
1542   5                          fun_sj1zt(loc_high[6]+1);//下降到区6最高位
1543   5                          fun_sz1(han_j);//抓件
1544   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1545   5                          fun_pyhz2(tra_q,dir_left);//抓件位置3
1546   5                          fun_sj1zt(loc_high[3]);//下降到区7最高位
1547   5                          fun_sz1(han_s);//松件
1548   5      
1549   5                          loc_data[3][loc_high[3]+1][0]=loc_data[6][loc_high[6]+1][0];//件已经从6区拿到
             -3区
1550   5                          loc_data[6][loc_high[6]+1][0]=0;//2区木有了
1551   5                          loc_high[6]++;//更新区2最高位
1552   5                          loc_high[3]--;//更新区7最高位
1553   5                      }
1554   4                  }
1555   3                  if((loc_data[7][4][0]==loc_data[7][4][1])&&
1556   3                     (loc_data[7][3][0]==loc_data[7][3][1])&&
1557   3                     (loc_data[7][2][0]==loc_data[7][2][1])&&
1558   3                     (loc_data[7][1][0]==loc_data[7][1][1])){
1559   4                      if((loc_data[3][4][0]==loc_data[3][4][1])&&
1560   4                         (loc_data[3][3][0]==loc_data[3][3][1])&&
1561   4                         (loc_data[3][2][0]==loc_data[3][2][1])&&
1562   4                         (loc_data[3][1][0]==loc_data[3][1][1])){
1563   5                          return;
1564   5                      }
1565   4                      else
1566   4                          fun_hz1(dir_left);
1567   4                  }
1568   3              }
1569   2              else{
1570   3                  fun_hz1(dir_left);
C51 COMPILER V9.01   8023                                                                  03/06/2015 18:13:47 PAGE 27  

1571   3              }
1572   2          }
1573   1      }//自动抓奸
1574          uc fun_min4(uc par_num1,uc par_num2,uc par_num3,uc par_num4){
1575   1          return 
1576   1          par_num1<par_num2?par_num1:par_num2<par_num2<par_num3?par_num2:par_num3?
1577   1          par_num1<par_num2?par_num1:par_num2<par_num3<par_num4?par_num3:par_num4?
1578   1          par_num1<par_num2?par_num1:par_num2:par_num3<par_num4?par_num3:par_num4:
1579   1          par_num2<par_num3?par_num2:par_num3<par_num3<par_num4?par_num3:par_num4?
1580   1          par_num2<par_num3?par_num2:par_num3:par_num3<par_num4?par_num3:par_num4;
1581   1      }//求4个数的最小值
1582          uc fun_min2(uc par_num1,uc par_num2){
1583   1          return 
1584   1          par_num1<par_num2?par_num1:par_num2;
1585   1      }//求2个数的最小值
1586          void fun_sj1zt(uc par_value){
1587   1          switch(par_value){
1588   2              case 0:
1589   2                  fun_sj1(sjp_wz1);
1590   2                  break;
1591   2              case 1:
1592   2                  fun_sj1(sjp_wz2);
1593   2                  break;
1594   2              case 2:
1595   2                  fun_sj1(sjp_wz3);
1596   2                  break;
1597   2              case 3:
1598   2                  fun_sj1(sjp_wz4);
1599   2                  break;
1600   2              case 4:
1601   2                  fun_sj1(sjp_wz5);
1602   2                  break;
1603   2              default:
1604   2                  break;
1605   2          }
1606   1      }//状态的升降单步,用来配合自动抓奸
1607          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8438    ----
   CONSTANT SIZE    =      5    ----
   XDATA SIZE       =     47      93
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      38
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
