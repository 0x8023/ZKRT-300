C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE 8023
OBJECT MODULE PLACED IN .\output\8023.obj
COMPILER INVOKED BY: H:\Program\keil\C51\BIN\C51.EXE program\8023.c DEBUG OBJECTEXTEND PRINT(.\8023.lst) OBJECT(.\output
                    -\8023.obj)

line level    source

   1          #include "./output/8023.h"
   2          xdata struct str_state str_begin,str_now,str_next;//分别为:起始状态/当前状态/目标状态
   3          xdata struct str_parameter str_cod={
   4              /*ui str_cod.mlinerqd*/25000,//默认主函数巡线软起动路程为25000
   5              /*ui str_cod.mlineqc*/200,//默认主函数巡线前冲时间为500毫秒
   6          
   7              /*ui str_cod.sj1bzw*/58,
   8              /*ui str_cod.sj1zjw*/800,
   9          
  10              /*ui str_cod.py1qkq*/666,
  11              /*ui str_cod.py1kqz*/684,
  12              /*ui str_cod.py1zkh*/684,
  13              /*ui str_cod.py1khh*/666,
  14              /*ui str_cod.py1qz*/500,
  15              /*ui str_cod.py1zh*/500,
  16              /*ui str_cod.py1kqkh*/1480,
  17              /*ui str_cod.py1qkh*/2122,
  18              /*ui str_cod.py1kqh*/2122,
  19          };
  20          ui var_timer0=0;
  21          void fun_delay(ui par_value,enum varENU_del par_model){
  22   1          ui loc_con=par_value;
  23   1          switch(par_model){
  24   2              case del_us://微秒级延时
  25   2                  while(loc_con-->0){
  26   3                      _nop_();
  27   3                      _nop_();
  28   3                  }
  29   2                  return;
  30   2              case del_ms://毫秒级延时
  31   2                  while(loc_con-->0){
  32   3                      uc loc_i, loc_j;
  33   3                      _nop_();
  34   3                      _nop_();
  35   3                      loc_i=12;
  36   3                      loc_j=168;
  37   3                      do{
  38   4                          while(--loc_j);
  39   4                      }while(--loc_i);
  40   3                  }
  41   2                  return;
  42   2              case del_s://秒级延时
  43   2                  while(loc_con-->0){
  44   3                      uc loc_i, loc_j, loc_k;
  45   3                      loc_i=46;
  46   3                      loc_j=153;
  47   3                      loc_k=245;
  48   3                      do{
  49   4                          do{
  50   5                              while(--loc_k);
  51   5                          }while(--loc_j);
  52   4                      }while(--loc_i);
  53   3                  }
  54   2                  return;
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 2   

  55   2              default:return;
  56   2          }
  57   1      }//延时
  58          void fun_timer0init(){
  59   1          AUXR|=0x80;       //定时器时钟1T模式
  60   1          TMOD&=0xF0;       //设置定时器模式
  61   1          TMOD|=0x01;       //设置定时器模式
  62   1          TL0=0x20;     //设置定时初值
  63   1          TH0=0xD1;     //设置定时初值
  64   1          TF0=0;        //清除TF0标志
  65   1          ET0=1;
  66   1          EA=1;
  67   1      }//1毫秒定时器0初始化
  68          void fun_timer1init(){
  69   1          AUXR&=0xBF;
  70   1          TMOD&=0x0F;
  71   1          TMOD|=0x10;
  72   1          TL1=0xE0;
  73   1          TH1=0xB1;
  74   1          TF1=0;
  75   1          ET1=1;
  76   1          EA=1;
  77   1      }//20毫秒定时器1初始化
  78          void fun_timer0(){
  79   1          TL0=0x20;
  80   1          TH0=0xD1;
  81   1          _nop_();
  82   1          var_timer0++;
  83   1      }//1毫秒定时器0处理函数
  84          void fun_timer1(){
  85   1          TL1=0xE0;
  86   1          TH1=0xB1;
  87   1          _nop_();
  88   1      }//20毫秒定时器1处理函数
  89          void fun_wait(){
  90   1          while(in_start==1);
  91   1          fun_delay(20,del_ms);
  92   1          while(in_start==0);
  93   1          fun_delay(256,del_ms);
  94   1      }//等待按键
  95          void fun_select(enum varENU_sel par_model){
  96   1          if(par_model==sel_58)
  97   1              out_switchselect=0;
  98   1          else if(par_model==sel_912)
  99   1              out_switchselect=1;
 100   1      }//传感器片选
 101          void fun_initialization(){
 102   1          CLK_DIV=0x00;//不分频
 103   1      
 104   1          P0M1=0xff;//P0用于输入
 105   1          P0M0=0x00;//P0不能输出
 106   1          
 107   1          P1M1=0x00;//P1口0-1双向，2中断输入，3-6输入，7输出
 108   1          P1M0=0xfc;//P1口2-7输出
 109   1      
 110   1          P2M1=0xf0;//P2口4-7输入
 111   1          P2M0=0x0f;//P2口0-3输出
 112   1      
 113   1          //PS_2=1;//手抓松传感器置1 $?$
 114   1          //PS_11=1;//升降位置3传感器置1 $?$
 115   1      
 116   1          out_en1=1;//电机1/3使能 $?$
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 3   

 117   1          out_en2=1;//电机2/4使能 $?$
 118   1          //out_motorselect=1;//电机片选为1 $?$
 119   1          //fun_delay(del_ms,1);//延时1毫秒 $?$
 120   1          out_motorselect=0;//电机片选为0 $?$
 121   1          //PS_5=PS_1;// $?$
 122   1      
 123   1          fun_pwminit();//PWM的初始化设置
 124   1          fun_timer0init();//初始化定时器0
 125   1          fun_timer1init();//初始化定时器1
 126   1          fun_port();//初始化串口
 127   1          in_start=1;//按键置1
 128   1      
 129   1          fun_wait();
 130   1      }//初始化
 131          void fun_pwminit(){
 132   1          CCON=0x00;
 133   1          CH=0;
 134   1          CL=0;
 135   1          CMOD=0x00;
 136   1      }//PWM初始化
 137          void fun_pwmr(uc par_value){
 138   1          CCAP0H=CCAP0L=par_value*2.5;//控制输出的占空比
 139   1          CCAPM0=0X42;//8位PWM输出，无中断
 140   1          PCA_PWM0=0x00;
 141   1      }//右路PWM输出
 142          void fun_pwml(uc par_value){
 143   1          CCAP1H=CCAP1L=par_value*2.5;//控制输出的占空比
 144   1          CCAPM1=0X42;//8位PWM输出，无中断
 145   1          PCA_PWM1=0x00;
 146   1      }//左路PWM输出
 147          void fun_startdj(enum varENU_mot par_model,char par_speed){
 148   1          if(par_speed==0)
 149   1              return;
 150   1          else if(par_speed>100)
 151   1              par_speed=100;
 152   1          else if(par_speed<-100)
 153   1              par_speed=-100;
 154   1          switch(par_model){
 155   2              case mot_l://左轮电机
 156   2                  CR=1;
 157   2                  if(par_speed>0){
 158   3                      fun_pwml(par_speed);out_pwml=0;
 159   3                  }
 160   2                  else if(par_speed<0){
 161   3                      fun_pwml(cabs(par_speed));out_pwml=1;
 162   3                  }
 163   2                  break;
 164   2              case mot_r://右轮电机
 165   2                  CR=1;
 166   2                  if(par_speed>0){
 167   3                      fun_pwmr(par_speed);out_pwmr=0;
 168   3                  }
 169   2                  else if(par_speed<0){
 170   3                      fun_pwmr(cabs(par_speed));out_pwmr=1;
 171   3                  }
 172   2                  break;
 173   2              case mot_rl://左右轮同步
 174   2                  CR=1;
 175   2                  if(par_speed>0){
 176   3                      fun_pwml(par_speed);out_pwml=0;
 177   3                      fun_pwmr(par_speed);out_pwmr=0;
 178   3                  }
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 4   

 179   2                  else if(par_speed<0){
 180   3                      fun_pwml(cabs(par_speed));out_pwml=1;
 181   3                      fun_pwmr(cabs(par_speed));out_pwmr=1;
 182   3                  }
 183   2                  break;
 184   2              case mot_dj1://正转为抓紧，反转为松开
 185   2                  out_motorselect=1;
 186   2                  if(par_speed>0)
 187   2                      out_dir1=1;
 188   2                  else if(par_speed<0)
 189   2                      out_dir1=0;
 190   2                  out_en1=0;
 191   2                  break;
 192   2              case mot_dj2://正转是向无电机一方转,反转为向有电机一方转
 193   2                  out_motorselect=1;
 194   2                  if(par_speed>0)
 195   2                      out_dir2=1;
 196   2                  else if(par_speed<0)
 197   2                      out_dir2=0;
 198   2                  out_en2=0;
 199   2                  break;
 200   2              case mot_dj3://向上为正转,向下为反转
 201   2                  out_motorselect=0;
 202   2                  if(par_speed>0)
 203   2                      out_dir1=0;
 204   2                  else if(par_speed<0)
 205   2                      out_dir1=1;
 206   2                  out_en1=0;
 207   2                  break;
 208   2              case mot_dj4://顺时针为正转,逆时针为反转
 209   2                  out_motorselect=0;
 210   2                  if(par_speed>0)
 211   2                      out_dir2=0;
 212   2                  else if(par_speed<0)
 213   2                      out_dir2=1;
 214   2                  out_en2=0;
 215   2                  break;
 216   2              default:
 217   2                  break;
 218   2          }
 219   1      }//启动电机
 220          void fun_stop(enum varENU_mot par_model){
 221   1          switch(par_model){
 222   2              case mot_l:
 223   2                  fun_pwml(0);out_pwml=0;break;
 224   2              case mot_r:
 225   2                  fun_pwmr(0);out_pwmr=0;break;
 226   2              case mot_rl:
 227   2                  CR=0;
 228   2                  fun_pwmr(0);out_pwmr=0;
 229   2                  fun_pwml(0);out_pwml=0;
 230   2                  break;
 231   2              case mot_dj1:
 232   2                  out_motorselect=1;out_dir1=0;out_en1=1;break;
 233   2              case mot_dj2:
 234   2                  out_motorselect=1;out_dir2=0;out_en2=1;break;
 235   2              case mot_dj3:
 236   2                  out_motorselect=0;out_dir1=0;out_en1=1;break;
 237   2              case mot_dj4:
 238   2                  out_motorselect=0;out_dir2=0;out_en2=1;break;
 239   2              default:
 240   2                  break;
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 5   

 241   2          }
 242   1      }//停止电机
 243          void fun_sz1(enum varENU_han par_model){
 244   1          if(par_model==han_s){//手抓松
 245   2              while(1){
 246   3                  fun_startdj(mot_dj1,-100);
 247   3                  while(in_s==1);
 248   3                  fun_delay(20,del_ms);
 249   3                  if(in_s==0)
 250   3                      break;
 251   3              }
 252   2          }
 253   1          else{//手抓紧
 254   2              while(1){
 255   3                  fun_startdj(mot_dj1,100);
 256   3                  while(in_j==1);
 257   3                  fun_delay(20,del_ms);
 258   3                  if(in_j==0)
 259   3                      break;
 260   3              }
 261   2          }
 262   1          fun_stop(mot_dj1);
 263   1          str_begin.szzt=par_model;//存储运行结果
 264   1      }//手抓单步运动
 265          void fun_sj1(enum varENU_sjp par_model){
 266   1          if(par_model==str_begin.sjwz)
 267   1             return;
 268   1          switch(par_model){
 269   2              case sjp_wz1://升降位置1(最上位)
 270   2                  fun_startdj(mot_dj3,100);
 271   2                  fun_select(sel_58);
 272   2                  fun_delay(50,del_ms);
 273   2                  while(1){//只有向上
 274   3                      while(in_wz1==1);
 275   3                      fun_delay(20,del_ms);
 276   3                      if(in_wz1==0){
 277   4                          fun_delay(20,del_ms);
 278   4                          break;                    
 279   4                      }
 280   3                  }
 281   2                  break;
 282   2              case sjp_wz12:
 283   2                  if(par_model>str_begin.sjwz){
 284   3                      fun_startdj(mot_dj3,-100);
 285   3                      fun_delay(str_cod.sj1zjw,del_ms);
 286   3                  }
 287   2                  else{//要去的地方在上面，向上走
 288   3                      fun_sj1(sjp_wz2);
 289   3                      fun_startdj(mot_dj3,100);
 290   3                      fun_delay(str_cod.sj1zjw,del_ms);
 291   3                  }
 292   2                  break;
 293   2              case sjp_wz2://升降位置2
 294   2                  if(par_model>str_begin.sjwz)
 295   2                      fun_startdj(mot_dj3,-100);
 296   2                  else
 297   2                      fun_startdj(mot_dj3,100);
 298   2                  fun_select(sel_58);
 299   2                  fun_delay(50,del_ms);
 300   2                  while(1){//要去的地方比较靠下,向下走                    
 301   3                      while(in_wz2==1);
 302   3                      fun_delay(20,del_ms);
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 6   

 303   3                      if(in_wz2==0){
 304   4                          fun_delay(str_cod.sj1bzw,del_ms);
 305   4                          break;
 306   4                      }
 307   3                  }
 308   2                  break;
 309   2              case sjp_wz23:
 310   2                  if(par_model>str_begin.sjwz){
 311   3                      fun_sj1(sjp_wz2);
 312   3                      fun_startdj(mot_dj3,-100);
 313   3                      fun_delay(str_cod.sj1zjw,del_ms);
 314   3                  }
 315   2                  else{//要去的地方在上面，向上走
 316   3                      fun_sj1(sjp_wz3);
 317   3                      fun_startdj(mot_dj3,100);
 318   3                      fun_delay(str_cod.sj1zjw,del_ms);
 319   3                  }
 320   2                  break;
 321   2              case sjp_wz3://升降位置3
 322   2                  if(par_model>str_begin.sjwz)
 323   2                      fun_startdj(mot_dj3,-100);
 324   2                  else
 325   2                      fun_startdj(mot_dj3,100);
 326   2                  fun_select(sel_58);
 327   2                  fun_delay(50,del_ms);
 328   2                  while(1){
 329   3                      while(in_wz3==1);
 330   3                      fun_delay(str_cod.sj1bzw,del_ms);
 331   3                      if(in_wz3==0)
 332   3                          break;
 333   3                  }
 334   2                  break;
 335   2              case sjp_wz34:
 336   2                  if(par_model>str_begin.sjwz){
 337   3                      fun_sj1(sjp_wz3);
 338   3                      fun_startdj(mot_dj3,-100);
 339   3                      fun_delay(str_cod.sj1zjw,del_ms);
 340   3                  }
 341   2                  else{//要去的地方在上面，向上走
 342   3                      fun_sj1(sjp_wz4);
 343   3                      fun_startdj(mot_dj3,100);
 344   3                      fun_delay(str_cod.sj1zjw,del_ms);
 345   3                  }
 346   2                  break;
 347   2              case sjp_wz4://升降位置4
 348   2                  if(par_model>str_begin.sjwz)
 349   2                      fun_startdj(mot_dj3,-100);
 350   2                  else
 351   2                      fun_startdj(mot_dj3,100);
 352   2                  fun_select(sel_58);
 353   2                  fun_delay(50,del_ms);
 354   2                  while(1){
 355   3                      while(in_wz4==1);
 356   3                      fun_delay(str_cod.sj1bzw,del_ms);
 357   3                      if(in_wz4==0)
 358   3                          break;
 359   3                  }
 360   2                  break;
 361   2              case sjp_wz45:
 362   2                  if(par_model>str_begin.sjwz){
 363   3                      fun_sj1(sjp_wz4);
 364   3                      fun_startdj(mot_dj3,-100);
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 7   

 365   3                      fun_delay(str_cod.sj1zjw,del_ms);
 366   3                  }
 367   2                  else{//要去的地方在上面，向上走
 368   3                      fun_startdj(mot_dj3,100);
 369   3                      fun_delay(str_cod.sj1zjw,del_ms);
 370   3                  }
 371   2                  break;
 372   2              case sjp_wz5://升降位置5
 373   2                  fun_startdj(mot_dj3,-100);
 374   2                  fun_select(sel_912);
 375   2                  fun_delay(50,del_ms);
 376   2                  while(1){//要去的地方比较靠下,向下走                
 377   3                      while(in_wz5==1);
 378   3                      fun_delay(20,del_ms);
 379   3                      if(in_wz5==0){
 380   4                          fun_delay(str_cod.sj1bzw,del_ms);
 381   4                          break;
 382   4                      }
 383   3                  }
 384   2                  break;
 385   2              default:
 386   2                  break;
 387   2          }
 388   1          fun_stop(mot_dj3);
 389   1          str_begin.sjwz=par_model;//存储运行结果
 390   1      }//升降单步运动
 391          void fun_py1(enum varENU_tra par_model){
 392   1          switch(par_model){
 393   2              case tra_q://前平移(没有电机的呢个方向)
 394   2                  while(1){
 395   3                      fun_startdj(mot_dj2,100);
 396   3                      while(in_qpy==1);
 397   3                      fun_delay(20,del_ms);
 398   3                      if(in_qpy==0){
 399   4                          fun_delay(20,del_ms);
 400   4                          break;
 401   4                      }
 402   3                  }
 403   2                  break;
 404   2              case tra_kq:
 405   2                  switch(str_begin.pywz){
 406   3                      case tra_q:
 407   3                          fun_startdj(mot_dj2,-100);
 408   3                          fun_delay(str_cod.py1qkq,del_ms);
 409   3                          break;
 410   3                      case tra_z:
 411   3                          fun_startdj(mot_dj2,100);
 412   3                          fun_delay(str_cod.py1kqz,del_ms);
 413   3                          break;
 414   3                      case tra_kh:
 415   3                          fun_startdj(mot_dj2,100);
 416   3                          fun_delay(str_cod.py1kqkh,del_ms);
 417   3                          break;
 418   3                      case tra_h:
 419   3                          fun_startdj(mot_dj2,100);
 420   3                          fun_delay(str_cod.py1kqh,del_ms);
 421   3                          break;
 422   3                  }
 423   2                  break;
 424   2              case tra_z:
 425   2                  switch(str_begin.pywz){
 426   3                      case tra_q:
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 8   

 427   3                          fun_startdj(mot_dj2,-100);
 428   3                          fun_delay(str_cod.py1qz,del_ms);
 429   3                          break;
 430   3                      case tra_kq:
 431   3                          fun_startdj(mot_dj2,-100);
 432   3                          fun_delay(str_cod.py1kqz,del_ms);
 433   3                          break;
 434   3                      case tra_kh:
 435   3                          fun_startdj(mot_dj2,100);
 436   3                          fun_delay(str_cod.py1zkh,del_ms);
 437   3                          break;
 438   3                      case tra_h:
 439   3                          fun_startdj(mot_dj2,100);
 440   3                          fun_delay(str_cod.py1zh,del_ms);
 441   3                          break;
 442   3                  }
 443   2                  break;
 444   2              case tra_kh:
 445   2                  switch(str_begin.pywz){
 446   3                      case tra_q:
 447   3                          fun_startdj(mot_dj2,-100);
 448   3                          fun_delay(str_cod.py1qkh,del_ms);
 449   3                          break;
 450   3                      case tra_kq:
 451   3                          fun_startdj(mot_dj2,-100);
 452   3                          fun_delay(str_cod.py1kqkh,del_ms);
 453   3                          break;
 454   3                      case tra_z:
 455   3                          fun_startdj(mot_dj2,-100);
 456   3                          fun_delay(str_cod.py1zkh,del_ms);
 457   3                          break;
 458   3                      case tra_h:
 459   3                          fun_startdj(mot_dj2,100);
 460   3                          fun_delay(str_cod.py1khh,del_ms);
 461   3                          break;
 462   3                  }
 463   2                  break;
 464   2              case tra_h://后平移(有电机的呢个方向)
 465   2                  while(1){
 466   3                      fun_startdj(mot_dj2,-100);
 467   3                      while(in_hpy==1);
 468   3                      fun_delay(20,del_ms);
 469   3                      if(in_hpy==0){
 470   4                          fun_delay(20,del_ms);
 471   4                          break;
 472   4                      }
 473   3                  }
 474   2                  break;
 475   2              default:
 476   2                  break;
 477   2          }
 478   1          fun_stop(mot_dj2);
 479   1          str_begin.pywz=par_model;//存储运行结果
 480   1      }//平移单步运动
 481          void fun_hz1(enum varENU_dir par_model){
 482   1          fun_select(sel_912);
 483   1          switch(par_model){
 484   2              case dir_up://回转至前方
 485   2                  switch(str_begin.hzfx){
 486   3                      case dir_down://现在在下方
 487   3                          fun_startdj(mot_dj4,-100);
 488   3                          fun_delay(1,del_s);
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 9   

 489   3                          while(1){
 490   4                              while(in_hz==1);
 491   4                              fun_delay(25,del_ms);
 492   4                              if(in_hz==0)
 493   4                                  break;
 494   4                          }
 495   3                          while(1){
 496   4                              while(in_hz==0);
 497   4                              fun_delay(25,del_ms);
 498   4                              if(in_hz==1)
 499   4                                  break;
 500   4                          }
 501   3                          while(1){
 502   4                              while(in_hz==1);
 503   4                              fun_delay(25,del_ms);
 504   4                              if(in_hz==0)
 505   4                                  break;
 506   4                          }
 507   3                          break;
 508   3                      case dir_left://现在在左边
 509   3                          fun_startdj(mot_dj4,100);
 510   3                          fun_delay(1,del_s);
 511   3                          while(1){
 512   4                              while(in_hz==1);
 513   4                              fun_delay(25,del_ms);
 514   4                              if(in_hz==0)
 515   4                                  break;
 516   4                          }
 517   3                          break;
 518   3                      case dir_right://现在在右边
 519   3                          fun_startdj(mot_dj4,-100);
 520   3                          fun_delay(1,del_s);
 521   3                          while(1){
 522   4                              while(in_hz==1);
 523   4                              fun_delay(25,del_ms);
 524   4                              if(in_hz==0)
 525   4                                  break;
 526   4                          }
 527   3                          break;
 528   3                      default:
 529   3                          break;
 530   3                  }
 531   2                  break;
 532   2              case dir_down://要去下面
 533   2                  switch(str_begin.hzfx){
 534   3                      case dir_up://现在在上面
 535   3                          fun_startdj(mot_dj4,100);
 536   3                          fun_delay(1,del_s);
 537   3                          while(1){
 538   4                              while(in_hz==1);
 539   4                              fun_delay(25,del_ms);
 540   4                              if(in_hz==0)
 541   4                                  break;
 542   4                          }
 543   3                          while(1){
 544   4                              while(in_hz==0);
 545   4                              fun_delay(25,del_ms);
 546   4                              if(in_hz==1)
 547   4                                  break;
 548   4                          }
 549   3                          while(1){
 550   4                              while(in_hz==1);
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 10  

 551   4                              fun_delay(25,del_ms);
 552   4                              if(in_hz==0)
 553   4                                  break;
 554   4                          }
 555   3                          break;
 556   3                      case dir_left://现在在左面
 557   3                          fun_startdj(mot_dj4,-100);
 558   3                          fun_delay(1,del_s);
 559   3                          while(1){
 560   4                              while(in_hz==1);
 561   4                              fun_delay(25,del_ms);
 562   4                              if(in_hz==0)
 563   4                                  break;
 564   4                          }
 565   3                          break;
 566   3                      case dir_right://现在在右面
 567   3                          fun_startdj(mot_dj4,100);
 568   3                          fun_delay(1,del_s);
 569   3                          while(1){
 570   4                              while(in_hz==1);
 571   4                              fun_delay(25,del_ms);
 572   4                              if(in_hz==0)
 573   4                                  break;
 574   4                          }
 575   3                          break;
 576   3                      default:
 577   3                          break;
 578   3                  }
 579   2                  break;
 580   2              case dir_left://要去左边
 581   2                  switch(str_begin.hzfx){
 582   3                      case dir_up://现在在上面
 583   3                          fun_startdj(mot_dj4,-100);
 584   3                          fun_delay(1,del_s);
 585   3                          while(1){
 586   4                              while(in_hz==1);
 587   4                              fun_delay(25,del_ms);
 588   4                              if(in_hz==0)
 589   4                                  break;
 590   4                          }
 591   3                          break;
 592   3                      case dir_down://现在在下面
 593   3                          fun_startdj(mot_dj4,100);
 594   3                          fun_delay(1,del_s);
 595   3                          while(1){
 596   4                              while(in_hz==1);
 597   4                              fun_delay(25,del_ms);
 598   4                              if(in_hz==0)
 599   4                                  break;
 600   4                          }
 601   3                          break;
 602   3                      case dir_right://现在在右面
 603   3                          fun_startdj(mot_dj4,-100);
 604   3                          fun_delay(1,del_s);
 605   3                          while(1){
 606   4                              while(in_hz==1);
 607   4                              fun_delay(25,del_ms);
 608   4                              if(in_hz==0)
 609   4                                  break;
 610   4                          }
 611   3                          while(1){
 612   4                              while(in_hz==0);
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 11  

 613   4                              fun_delay(25,del_ms);
 614   4                              if(in_hz==1)
 615   4                                  break;
 616   4                          }
 617   3                          while(1){
 618   4                              while(in_hz==1);
 619   4                              fun_delay(25,del_ms);
 620   4                              if(in_hz==0){
 621   5                                  break;
 622   5                              }
 623   4                          }
 624   3                          break;
 625   3                      default:
 626   3                          break;
 627   3                  }
 628   2                  break;
 629   2              case dir_right://要去右面
 630   2                  switch(str_begin.hzfx){
 631   3                      case dir_up://现在在前面
 632   3                          fun_startdj(mot_dj4,100);
 633   3                          fun_delay(1,del_s);
 634   3                          while(1){
 635   4                              while(in_hz==1);
 636   4                              fun_delay(25,del_ms);
 637   4                              if(in_hz==0)
 638   4                                  break;
 639   4                          }
 640   3                          break;
 641   3                      case dir_down://现在在下面
 642   3                          fun_startdj(mot_dj4,-100);
 643   3                          fun_delay(1,del_s);
 644   3                          while(1){
 645   4                              while(in_hz==1);
 646   4                              fun_delay(25,del_ms);
 647   4                              if(in_hz==0)
 648   4                                  break;
 649   4                          }
 650   3                          break;
 651   3                      case dir_left://现在在左面
 652   3                          fun_startdj(mot_dj4,100);
 653   3                          fun_delay(1,del_s);
 654   3                          while(1){
 655   4                              while(in_hz==1);
 656   4                              fun_delay(25,del_ms);
 657   4                              if(in_hz==0)
 658   4                                  break;
 659   4                          }
 660   3                          while(1){
 661   4                              while(in_hz==0);
 662   4                              fun_delay(25,del_ms);
 663   4                              if(in_hz==1)
 664   4                                  break;
 665   4                          }
 666   3                          while(1){
 667   4                              while(in_hz==1);
 668   4                              fun_delay(25,del_ms);
 669   4                              if(in_hz==0){
 670   5                                  break;
 671   5                              }
 672   4                          }
 673   3                          break;
 674   3                      default:
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 12  

 675   3                          break;
 676   3                  }
 677   2                  break;
 678   2              default:
 679   2                  break;
 680   2          }
 681   1          fun_stop(mot_dj4);
 682   1          str_begin.hzfx=par_model;//存储运行结果
 683   1      }//回转单步运动
 684          void fun_pyhz2(enum varENU_tra par_py,enum varENU_dir par_hz){
 685   1          if(str_begin.hzfx!=par_hz){
 686   2              fun_py1(tra_z);
 687   2              switch(par_hz){//启动回转,在位则不启动
 688   3                  case dir_up://回转至前方
 689   3                      switch(str_begin.hzfx){
 690   4                          case dir_down://现在在下方
 691   4                              fun_startdj(mot_dj4,-100);
 692   4                              break;
 693   4                          case dir_left://现在在左边
 694   4                              fun_startdj(mot_dj4,100);
 695   4                              break;
 696   4                          case dir_right://现在在右边
 697   4                              fun_startdj(mot_dj4,-100);
 698   4                              break;
 699   4                          default:
 700   4                              break;
 701   4                      }
 702   3                      break;
 703   3                  case dir_down://要去下面
 704   3                      switch(str_begin.hzfx){
 705   4                          case dir_up://现在在上面
 706   4                              fun_startdj(mot_dj4,100);
 707   4                              break;
 708   4                          case dir_left://现在在左面
 709   4                              fun_startdj(mot_dj4,-100);
 710   4                              break;
 711   4                          case dir_right://现在在右面
 712   4                              fun_startdj(mot_dj4,100);
 713   4                              break;
 714   4                          default:
 715   4                              break;
 716   4                      }
 717   3                      break;
 718   3                  case dir_left://要去左边
 719   3                      switch(str_begin.hzfx){
 720   4                          case dir_up://现在在上面
 721   4                              fun_startdj(mot_dj4,-100);
 722   4                              break;
 723   4                          case dir_down://现在在下面
 724   4                              fun_startdj(mot_dj4,100);
 725   4                              break;
 726   4                          case dir_right://现在在右面
 727   4                              fun_startdj(mot_dj4,-100);
 728   4                              break;
 729   4                          default:
 730   4                              break;
 731   4                      }
 732   3                      break;
 733   3                  case dir_right://要去右面
 734   3                      switch(str_begin.hzfx){
 735   4                          case dir_up://现在在前面
 736   4                              fun_startdj(mot_dj4,100);
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 13  

 737   4                              break;
 738   4                          case dir_down://现在在下面
 739   4                              fun_startdj(mot_dj4,-100);
 740   4                              break;
 741   4                          case dir_left://现在在左面
 742   4                              fun_startdj(mot_dj4,100);
 743   4                              break;
 744   4                          default:
 745   4                              break;
 746   4                      }
 747   3                      break;
 748   3                  default:
 749   3                      break;
 750   3              }
 751   2          }
 752   1          switch(par_py){
 753   2              case tra_q://前平移(没有电机的呢个方向)
 754   2                  while(1){
 755   3                      fun_startdj(mot_dj2,100);
 756   3                      while(in_qpy==1);
 757   3                      fun_delay(20,del_ms);
 758   3                      if(in_qpy==0){
 759   4                          fun_delay(20,del_ms);
 760   4                          break;
 761   4                      }
 762   3                  }
 763   2                  break;
 764   2              case tra_kq:
 765   2                  fun_startdj(mot_dj2,100);
 766   2                  fun_delay(str_cod.py1kqz,del_ms);
 767   2                  break;
 768   2              case tra_kh:
 769   2                  fun_startdj(mot_dj2,-100);
 770   2                  fun_delay(str_cod.py1zkh,del_ms);
 771   2                  break;
 772   2              case tra_h://后平移(有电机的呢个方向)
 773   2                  while(1){
 774   3                      fun_startdj(mot_dj2,-100);
 775   3                      while(in_hpy==1);
 776   3                      fun_delay(20,del_ms);
 777   3                      if(in_hpy==0){
 778   4                          fun_delay(20,del_ms);
 779   4                          break;
 780   4                      }
 781   3                  }
 782   2                  break;
 783   2              default:
 784   2                  break;
 785   2          }
 786   1          fun_stop(mot_dj2);
 787   1          str_begin.pywz=par_py;//存储平移位置
 788   1          if(str_begin.hzfx!=par_hz){
 789   2              fun_select(sel_912);
 790   2              switch(par_hz){
 791   3                  case dir_up://回转至前方
 792   3                      switch(str_begin.hzfx){
 793   4                          case dir_down://现在在下方
 794   4                              while(1){
 795   5                                  while(in_hz==1);
 796   5                                  fun_delay(25,del_ms);
 797   5                                  if(in_hz==0)
 798   5                                      break;
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 14  

 799   5                              }
 800   4                              while(1){
 801   5                                  while(in_hz==0);
 802   5                                  fun_delay(1,del_s);
 803   5                                  if(in_hz==1)
 804   5                                      break;
 805   5                              }
 806   4                              while(1){
 807   5                                  while(in_hz==1);
 808   5                                  fun_delay(25,del_ms);
 809   5                                  if(in_hz==0)
 810   5                                      break;
 811   5                              }
 812   4                              break;
 813   4                          case dir_left://现在在左边
 814   4                              while(1){
 815   5                                  while(in_hz==1);
 816   5                                  fun_delay(25,del_ms);
 817   5                                  if(in_hz==0)
 818   5                                      break;
 819   5                              }
 820   4                              break;
 821   4                          case dir_right://现在在右边
 822   4                              while(1){
 823   5                                  while(in_hz==1);
 824   5                                  fun_delay(25,del_ms);
 825   5                                  if(in_hz==0)
 826   5                                      break;
 827   5                              }
 828   4                              break;
 829   4                          default:
 830   4                              break;
 831   4                      }
 832   3                      break;
 833   3                  case dir_down://要去下面
 834   3                      switch(str_begin.hzfx){
 835   4                          case dir_up://现在在上面
 836   4                              while(1){
 837   5                                  while(in_hz==1);
 838   5                                  fun_delay(25,del_ms);
 839   5                                  if(in_hz==0)
 840   5                                      break;
 841   5                              }
 842   4                              while(1){
 843   5                                  while(in_hz==0);
 844   5                                  fun_delay(1,del_s);
 845   5                                  if(in_hz==1)
 846   5                                      break;
 847   5                              }
 848   4                              while(1){
 849   5                                  while(in_hz==1);
 850   5                                  fun_delay(25,del_ms);
 851   5                                  if(in_hz==0)
 852   5                                      break;
 853   5                              }
 854   4                              break;
 855   4                          case dir_left://现在在左面
 856   4                              while(1){
 857   5                                  while(in_hz==1);
 858   5                                  fun_delay(25,del_ms);
 859   5                                  if(in_hz==0)
 860   5                                      break;
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 15  

 861   5                              }
 862   4                              break;
 863   4                          case dir_right://现在在右面
 864   4                              while(1){
 865   5                                  while(in_hz==1);
 866   5                                  fun_delay(25,del_ms);
 867   5                                  if(in_hz==0)
 868   5                                      break;
 869   5                              }
 870   4                              break;
 871   4                          default:
 872   4                              break;
 873   4                      }
 874   3                      break;
 875   3                  case dir_left://要去左边
 876   3                      switch(str_begin.hzfx){
 877   4                          case dir_up://现在在上面
 878   4                              while(1){
 879   5                                  while(in_hz==1);
 880   5                                  fun_delay(25,del_ms);
 881   5                                  if(in_hz==0)
 882   5                                      break;
 883   5                              }
 884   4                              break;
 885   4                          case dir_down://现在在下面
 886   4                              while(1){
 887   5                                  while(in_hz==1);
 888   5                                  fun_delay(25,del_ms);
 889   5                                  if(in_hz==0)
 890   5                                      break;
 891   5                              }
 892   4                              break;
 893   4                          case dir_right://现在在右面
 894   4                              while(1){
 895   5                                  while(in_hz==1);
 896   5                                  fun_delay(25,del_ms);
 897   5                                  if(in_hz==0)
 898   5                                      break;
 899   5                              }
 900   4                              while(1){
 901   5                                  while(in_hz==0);
 902   5                                  fun_delay(1,del_s);
 903   5                                  if(in_hz==1)
 904   5                                      break;
 905   5                              }
 906   4                              while(1){
 907   5                                  while(in_hz==1);
 908   5                                  fun_delay(25,del_ms);
 909   5                                  if(in_hz==0){
 910   6                                      break;
 911   6                                  }
 912   5                              }
 913   4                              break;
 914   4                          default:
 915   4                              break;
 916   4                      }
 917   3                      break;
 918   3                  case dir_right://要去右面
 919   3                      switch(str_begin.hzfx){
 920   4                          case dir_up://现在在前面
 921   4                              while(1){
 922   5                                  while(in_hz==1);
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 16  

 923   5                                  fun_delay(25,del_ms);
 924   5                                  if(in_hz==0)
 925   5                                      break;
 926   5                              }
 927   4                              break;
 928   4                          case dir_down://现在在下面
 929   4                              while(1){
 930   5                                  while(in_hz==1);
 931   5                                  fun_delay(25,del_ms);
 932   5                                  if(in_hz==0)
 933   5                                      break;
 934   5                              }
 935   4                              break;
 936   4                          case dir_left://现在在左面
 937   4                              while(1){
 938   5                                  while(in_hz==1);
 939   5                                  fun_delay(25,del_ms);
 940   5                                  if(in_hz==0)
 941   5                                      break;
 942   5                              }
 943   4                              while(1){
 944   5                                  while(in_hz==0);
 945   5                                  fun_delay(1,del_s);
 946   5                                  if(in_hz==1)
 947   5                                      break;
 948   5                              }
 949   4                              while(1){
 950   5                                  while(in_hz==1);
 951   5                                  fun_delay(25,del_ms);
 952   5                                  if(in_hz==0){
 953   6                                      break;
 954   6                                  }
 955   5                              }
 956   4                              break;
 957   4                          default:
 958   4                              break;
 959   4                      }
 960   3                      break;
 961   3                  default:
 962   3                      break;
 963   3              }
 964   2              fun_stop(mot_dj4);
 965   2              str_begin.hzfx=par_hz;//存储回转位置
 966   2          }
 967   1      }//回转单步运动
 968          void fun_mptline(uc par_num,uc par_sd,enum varENU_dir par_model){
 969   1          bit loc_flag=0;
 970   1          ui loc_xh=str_cod.mlinerqd/(0.5*(par_sd*par_sd+par_sd));
 971   1          uc loc_con;
 972   1          uc loc_l=par_sd,loc_r=par_sd;
 973   1          for(loc_con=1;loc_con<par_sd;fun_delay(loc_xh,del_ms)){//确定路程的软启动程序
 974   2              loc_r=loc_l=loc_con++;//恢复默认参数
 975   2              if(in_ls3){//纠偏
 976   3                  loc_l*=0.9;
 977   3                  loc_r*=1.1;
 978   3              }
 979   2              if(in_ls6){
 980   3                  loc_l*=1.1;
 981   3                  loc_r*=0.9;
 982   3              }  
 983   2              if(in_ls2){
 984   3                  loc_l*=0.8;
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 17  

 985   3                  loc_r*=1.2;
 986   3              }
 987   2              if(in_ls7){
 988   3                  loc_l*=1.2;
 989   3                  loc_r*=0.8;
 990   3              }
 991   2              if(in_ls1){
 992   3                  loc_l*=0.7;
 993   3                  loc_r*=1.3;
 994   3              }
 995   2              if(in_ls8){
 996   3                  loc_l*=1.3;
 997   3                  loc_r*=0.7;
 998   3              }
 999   2              fun_startdj(mot_r,loc_r);
1000   2              fun_startdj(mot_l,loc_l);
1001   2          }
1002   1          loc_con=0;
1003   1          while(1){
1004   2              if(((in_ls1)&&(in_ls7))||((in_ls2)&&(in_ls8)))
1005   2                  loc_flag=1;
1006   2              else if(loc_flag==1){
1007   3                  loc_con++;
1008   3                  loc_flag=0;
1009   3                  if(loc_con>=par_num){
1010   4                      if(par_model!=dir_up){
1011   5                          if(par_model==dir_left){//左转
1012   6                              fun_startdj(mot_r,par_sd);
1013   6                              fun_startdj(mot_l,-10);
1014   6                              fun_delay(500,del_ms);
1015   6                              while(1){
1016   7                                  while(!in_ls4||!in_ls5);
1017   7                                  fun_delay(100,del_us);
1018   7                                  if(in_ls4&&in_ls5){
1019   8                                      fun_stop(mot_rl);
1020   8                                      return;
1021   8                                  }
1022   7                              }
1023   6                          }
1024   5                          else if(par_model==dir_right){
1025   6                              fun_startdj(mot_l,par_sd);
1026   6                              fun_startdj(mot_r,-10);
1027   6                              fun_delay(500,del_ms);
1028   6                              while(1){
1029   7                                  while(!in_ls4||!in_ls5);
1030   7                                  fun_delay(100,del_us);
1031   7                                  if(in_ls4&&in_ls5){
1032   8                                      fun_stop(mot_rl);
1033   8                                      return;
1034   8                                  }
1035   7                              }
1036   6                          }
1037   5                      }
1038   4                      else{
1039   5                          for(loc_con=par_sd;loc_con>0;fun_delay(loc_xh,del_ms)){//确定路程的软启动程
             -
1040   6                              loc_r=loc_l=loc_con--;//恢复默认参数
1041   6                              if(in_ls3){//纠偏
1042   7                                  loc_l*=0.9;
1043   7                                  loc_r*=1.1;
1044   7                              }
1045   6                              if(in_ls6){
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 18  

1046   7                                  loc_l*=1.1;
1047   7                                  loc_r*=0.9;
1048   7                              }  
1049   6                              if(in_ls2){
1050   7                                  loc_l*=0.8;
1051   7                                  loc_r*=1.2;
1052   7                              }
1053   6                              if(in_ls7){
1054   7                                  loc_l*=1.2;
1055   7                                  loc_r*=0.8;
1056   7                              }
1057   6                              if(in_ls1){
1058   7                                  loc_l*=0.7;
1059   7                                  loc_r*=1.3;
1060   7                              }
1061   6                              if(in_ls8){
1062   7                                  loc_l*=1.3;
1063   7                                  loc_r*=0.7;
1064   7                              }
1065   6                              fun_startdj(mot_r,loc_r);
1066   6                              fun_startdj(mot_l,loc_l);
1067   6                          }
1068   5                          fun_stop(mot_rl);
1069   5                          return;
1070   5                      }
1071   4                  }
1072   3              }
1073   2              loc_r=loc_l=par_sd;
1074   2              if(in_ls3){//纠偏
1075   3                  loc_l*=0.9;
1076   3                  loc_r*=1.1;
1077   3              }
1078   2              if(in_ls6){
1079   3                  loc_l*=1.1;
1080   3                  loc_r*=0.9;
1081   3              }  
1082   2              if(in_ls2){
1083   3                  loc_l*=0.8;
1084   3                  loc_r*=1.2;
1085   3              }
1086   2              if(in_ls7){
1087   3                  loc_l*=1.2;
1088   3                  loc_r*=0.8;
1089   3              }
1090   2              if(in_ls1){
1091   3                  loc_l*=0.7;
1092   3                  loc_r*=1.3;
1093   3              }
1094   2              if(in_ls8){
1095   3                  loc_l*=1.3;
1096   3                  loc_r*=0.7;
1097   3              }
1098   2              fun_startdj(mot_l,loc_l);//更新电机参数
1099   2              fun_startdj(mot_r,loc_r);
1100   2          }
1101   1      }//主函数普通巡线
1102          void fun_stope2prom(){
1103   1          IAP_CONTR = 0;                  //关闭IAP功能
1104   1          IAP_CMD = 0;                    //清除命令
1105   1          IAP_TRIG = 0;                   //清除触发寄存器
1106   1          IAP_ADDRH = 0x80;               //数据指针指向非EEPROM区
1107   1          IAP_ADDRL = 0;                  //清除IAP地址
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 19  

1108   1      }//关闭EEPROM功能(IapIdle)
1109          uc fun_reade2prom(ui par_add){
1110   1          uc loc_dat;                     //数据缓冲区
1111   1          IAP_CONTR = 0x83;               //打开EEPROM功能,设置等待时间
1112   1          IAP_CMD = 1;                    //设置EEPROM读命令
1113   1          IAP_ADDRL = par_add;            //设置EEPROM地址低八位
1114   1          IAP_ADDRH = par_add >> 8;       //设置EEPROM地址高八位
1115   1          IAP_TRIG = 0x5a;                //触发
1116   1          IAP_TRIG = 0xa5;                //再次触发
1117   1          fun_delay(10,del_us);           //稍等一会儿
1118   1          loc_dat = IAP_DATA;             //读出EEPROM中的数据
1119   1          fun_stope2prom();               //关闭EEPROM功能
1120   1          return loc_dat;                 //返回读取结果
1121   1      }//读取EEPROM数据
1122          void fun_writee2prom(ui par_add,uc par_dat){
1123   1          IAP_CONTR = 0x83;               //打开EEPROM功能,设置等待时间
1124   1          IAP_CMD = 2;                    //设置EEPROM写入命令
1125   1          IAP_ADDRL = par_add;            //设置EEPROM地址低八位
1126   1          IAP_ADDRH = par_add >> 8;       //设置EEPROM地址高八位
1127   1          IAP_DATA = par_dat;             //写入数据
1128   1          IAP_TRIG = 0x5a;                //触发
1129   1          IAP_TRIG = 0xa5;                //再次触发
1130   1          fun_delay(10,del_us);           //稍等一会儿
1131   1          fun_stope2prom();               //关闭EEPROM功能
1132   1      }//写EEPROM数据
1133          void fun_cleane2prom(ui par_add){
1134   1          IAP_CONTR = 0x83;               //打开EEPROM功能,设置等待时间
1135   1          IAP_CMD = 3;                    //设置EEPROM擦除命令
1136   1          IAP_ADDRL = par_add;            //设置EEPROM地址低八位
1137   1          IAP_ADDRH = par_add >> 8;       //设置EEPROM地址高八位
1138   1          IAP_TRIG = 0x5a;                //触发
1139   1          IAP_TRIG = 0xa5;                //再次触发
1140   1          fun_delay(10,del_us);           //稍等一会儿
1141   1          fun_stope2prom();               //关闭EEPROM功能
1142   1      }//清除EEPROM数据
1143          void fun_calibration(){
1144   1          // fun_sj1(sjp_wz1);//升到最上位
1145   1          fun_py1(tra_q);//移动到最前端
1146   1          fun_py1(tra_h);//移动到最后端
1147   1          def_timer0start//开始定时器
1148   1          fun_py1(tra_q);//移动到前端并计时
1149   1          fun_py1(tra_h);//移动到后端
1150   1          def_timer0stop//停止定时器
1151   1          var_timer0*=0.39;
1152   1          str_cod.py1zh=str_cod.py1qz=var_timer0*0.5;
1153   1          str_cod.py1qkh=str_cod.py1kqh=var_timer0*0.75;
1154   1          str_cod.py1qkq=str_cod.py1khh=var_timer0*0.25;
1155   1          str_cod.py1kqz=str_cod.py1zkh=var_timer0*0.25;
1156   1          str_cod.py1kqkh=var_timer0*0.5;
1157   1          var_timer0=0;
1158   1          OUT(var_timer0)
1159   1      }//自动校准参数
1160          void fun_port(){
1161   1          PCON|=0x80;       //使能波特率倍速位SMOD
1162   1          SCON=0x50;        //8位数据,可变波特率
1163   1          AUXR|=0x04;       //独立波特率发生器时钟为Fosc,即1T
1164   1          BRT=0xD9;     //设定独立波特率发生器重装值
1165   1          AUXR|=0x01;       //串口1选择独立波特率发生器为波特率发生器
1166   1          AUXR|=0x10;       //启动独立波特率发生器
1167   1          TI=1;//打开串口传输功能
1168   1      }//串口初始化
1169          void fun_zhuajian(
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 20  

1170              uc par_01,uc par_02,uc par_03,uc par_04,uc par_41,uc par_42,uc par_43,uc par_44,
1171              uc par_31,uc par_32,uc par_33,uc par_34,uc par_71,uc par_72,uc par_73,uc par_74){
1172   1      
1173   1          xdata uc loc_data[8][5][2];//三维数组,8个区,5个高度
1174   1          xdata uc loc_high[8];
1175   1          xdata uc loc_high03;
1176   1          xdata uc loc_high47;
1177   1          xdata uc loc_high07;
1178   1          xdata uc loc_xh1,loc_xh2;
1179   1      
1180   1          memset(loc_data,0,sizeof(loc_data));//清空数组
1181   1          //起始区件号
1182   1          loc_data[0][1][0]=par_01;//传入形参:区0的第1号件件号(最高位)
1183   1          loc_data[0][2][0]=par_02;//传入形参:区0的第2号件件号
1184   1          loc_data[0][3][0]=par_03;//传入形参:区0的第3号件件号
1185   1          loc_data[0][4][0]=par_04;//传入形参:区0的第4号件件号(最低位)
1186   1          loc_data[4][1][0]=par_41;//传入形参:区4的第1号件件号(最高位)
1187   1          loc_data[4][2][0]=par_42;//传入形参:区4的第2号件件号
1188   1          loc_data[4][3][0]=par_43;//传入形参:区4的第3号件件号
1189   1          loc_data[4][4][0]=par_44;//传入形参:区4的第4号件件号(最低位)
1190   1          //目的区件号
1191   1          loc_data[3][1][0]=par_31;//传入形参:区0的第1号件件号(最高位)
1192   1          loc_data[3][2][0]=par_32;//传入形参:区0的第2号件件号
1193   1          loc_data[3][3][0]=par_33;//传入形参:区0的第3号件件号
1194   1          loc_data[3][4][0]=par_34;//传入形参:区0的第4号件件号(最低位)
1195   1          loc_data[7][1][0]=par_71;//传入形参:区4的第1号件件号(最高位)
1196   1          loc_data[7][2][0]=par_72;//传入形参:区4的第2号件件号
1197   1          loc_data[7][3][0]=par_73;//传入形参:区4的第3号件件号
1198   1          loc_data[7][4][0]=par_74;//传入形参:区4的第4号件件号(最低位)
1199   1          //目的次序
1200   1          loc_data[3][1][1]=1;//标准次序:区3的第1号目的次序号(最高位)
1201   1          loc_data[3][2][1]=2;//标准次序:区3的第2号目的次序号
1202   1          loc_data[3][3][1]=3;//标准次序:区3的第3号目的次序号
1203   1          loc_data[3][4][1]=4;//标准次序:区3的第4号目的次序号(最低位)
1204   1          loc_data[7][1][1]=5;//标准次序:区7的第1号目的次序号(最高位)
1205   1          loc_data[7][2][1]=6;//标准次序:区7的第2号目的次序号
1206   1          loc_data[7][3][1]=7;//标准次序:区7的第3号目的次序号
1207   1          loc_data[7][4][1]=8;//标准次序:区7的第4号目的次序号(最低位)
1208   1          //根据形参统一次序
1209   1          for(loc_xh1=4;loc_xh1>0;loc_xh1--){
1210   2                   if((loc_data[0][loc_xh1][0]==loc_data[3][1][0])&&(loc_data[0][loc_xh1][0]!=0))
1211   2                  loc_data[0][loc_xh1][1]=loc_data[3][1][1];
1212   2              else if((loc_data[0][loc_xh1][0]==loc_data[3][2][0])&&(loc_data[0][loc_xh1][0]!=0))
1213   2                  loc_data[0][loc_xh1][1]=loc_data[3][2][1];
1214   2              else if((loc_data[0][loc_xh1][0]==loc_data[3][3][0])&&(loc_data[0][loc_xh1][0]!=0))
1215   2                  loc_data[0][loc_xh1][1]=loc_data[3][3][1];
1216   2              else if((loc_data[0][loc_xh1][0]==loc_data[3][4][0])&&(loc_data[0][loc_xh1][0]!=0))
1217   2                  loc_data[0][loc_xh1][1]=loc_data[3][4][1];
1218   2              else if((loc_data[0][loc_xh1][0]==loc_data[7][1][0])&&(loc_data[0][loc_xh1][0]!=0))
1219   2                  loc_data[0][loc_xh1][1]=loc_data[7][1][1];
1220   2              else if((loc_data[0][loc_xh1][0]==loc_data[7][2][0])&&(loc_data[0][loc_xh1][0]!=0))
1221   2                  loc_data[0][loc_xh1][1]=loc_data[7][2][1];
1222   2              else if((loc_data[0][loc_xh1][0]==loc_data[7][3][0])&&(loc_data[0][loc_xh1][0]!=0))
1223   2                  loc_data[0][loc_xh1][1]=loc_data[7][3][1];
1224   2              else if((loc_data[0][loc_xh1][0]==loc_data[7][4][0])&&(loc_data[0][loc_xh1][0]!=0))
1225   2                  loc_data[0][loc_xh1][1]=loc_data[7][4][1];
1226   2      
1227   2                   if((loc_data[4][loc_xh1][0]==loc_data[3][1][0])&&(loc_data[4][loc_xh1][0]!=0))
1228   2                  loc_data[4][loc_xh1][1]=loc_data[3][1][1];
1229   2              else if((loc_data[4][loc_xh1][0]==loc_data[3][2][0])&&(loc_data[4][loc_xh1][0]!=0))
1230   2                  loc_data[4][loc_xh1][1]=loc_data[3][2][1];
1231   2              else if((loc_data[4][loc_xh1][0]==loc_data[3][3][0])&&(loc_data[4][loc_xh1][0]!=0))
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 21  

1232   2                  loc_data[4][loc_xh1][1]=loc_data[3][3][1];
1233   2              else if((loc_data[4][loc_xh1][0]==loc_data[3][4][0])&&(loc_data[4][loc_xh1][0]!=0))
1234   2                  loc_data[4][loc_xh1][1]=loc_data[3][4][1];
1235   2              else if((loc_data[4][loc_xh1][0]==loc_data[7][1][0])&&(loc_data[4][loc_xh1][0]!=0))
1236   2                  loc_data[4][loc_xh1][1]=loc_data[7][1][1];
1237   2              else if((loc_data[4][loc_xh1][0]==loc_data[7][2][0])&&(loc_data[4][loc_xh1][0]!=0))
1238   2                  loc_data[4][loc_xh1][1]=loc_data[7][2][1];
1239   2              else if((loc_data[4][loc_xh1][0]==loc_data[7][3][0])&&(loc_data[4][loc_xh1][0]!=0))
1240   2                  loc_data[4][loc_xh1][1]=loc_data[7][3][1];
1241   2              else if((loc_data[4][loc_xh1][0]==loc_data[7][4][0])&&(loc_data[4][loc_xh1][0]!=0))
1242   2                  loc_data[4][loc_xh1][1]=loc_data[7][4][1];
1243   2          }
1244   1          //清空形参表(实际件序)
1245   1          for(loc_xh1=0;loc_xh1<=7;loc_xh1++)
1246   1              for(loc_xh2=0;loc_xh2<=4;loc_xh2++)
1247   1                  loc_data[loc_xh1][loc_xh2][0]=0;
1248   1          //转移04的序号
1249   1          for(loc_xh1=0;loc_xh1<=4;loc_xh1++){
1250   2              loc_data[0][loc_xh1][0]=loc_data[0][loc_xh1][1];
1251   2              loc_data[4][loc_xh1][0]=loc_data[4][loc_xh1][1];
1252   2          }
1253   1          //目的区除了3.7区全部清零
1254   1          for(loc_xh1=0;loc_xh1<=4;loc_xh1++){
1255   2              loc_data[0][loc_xh1][1]=0;
1256   2              loc_data[1][loc_xh1][1]=0;
1257   2              loc_data[2][loc_xh1][1]=0;
1258   2              loc_data[4][loc_xh1][1]=0;
1259   2              loc_data[5][loc_xh1][1]=0;
1260   2              loc_data[6][loc_xh1][1]=0;
1261   2          }
1262   1          //8个区的循环
1263   1          for(loc_xh1=0;loc_xh1<=7;loc_xh1++){
1264   2              loc_high[loc_xh1]=4;//默认为没有件
1265   2              for(loc_xh2=0;loc_xh2<=4;loc_xh2++){//5个高度的循环
1266   3                  if(loc_data[loc_xh1][loc_xh2][0]!=0){//如果放了件了
1267   4                      loc_high[loc_xh1]=loc_xh2-1;//记录这个区最高空闲位置
1268   4                      break;//继续区的循环
1269   4                  }
1270   3              }
1271   2          }
1272   1      
1273   1          fun_sj1(sjp_wz1);
1274   1          fun_sz1(han_s);
1275   1      
1276   1          while(1){
1277   2              loc_high03=fun_min4(loc_high[0],loc_high[1],loc_high[2],loc_high[3]);
1278   2              loc_high47=fun_min4(loc_high[4],loc_high[5],loc_high[6],loc_high[7]);
1279   2              loc_high07=fun_min2(loc_high03,loc_high47);
1280   2              if(str_begin.hzfx==dir_left){
1281   3                  if(loc_high[0]<4){//如果区0有件
1282   4                      if(loc_data[0][loc_high[0]+1][0]==loc_data[3][loc_high[3]][1]){//如果区0最高位等于
             -区3最高位件
1283   5                          fun_sj1zt(loc_high03);//上升到03方最高位
1284   5                          fun_pyhz2(tra_h,dir_left);//抓件位置0
1285   5                          fun_sj1zt(loc_high[0]+1);//下降到区0最高位
1286   5                          fun_sz1(han_j);//抓件
1287   5                          fun_sj1zt(loc_high03);//上升到03方最高位
1288   5                          fun_pyhz2(tra_q,dir_left);//抓件位置3
1289   5                          fun_sj1zt(loc_high[3]);//下降到区3最高位
1290   5                          fun_sz1(han_s);//松件
1291   5      
1292   5                          loc_data[3][loc_high[3]+1][0]=loc_data[0][loc_high[0]+1][0];//件已经从0区拿到
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 22  

             -3区
1293   5                          loc_data[0][loc_high[0]+1][0]=0;//0区木有了
1294   5                          loc_high[0]++;//更新区0最高位
1295   5                          loc_high[3]--;//更新区3最高位
1296   5                      }
1297   4                      else if(loc_data[0][loc_high[0]+1][0]==loc_data[7][loc_high[7]][1]){//如果区0最高位
             -于区7最高位件
1298   5                          fun_sj1zt(loc_high03);//上升到03方最高位
1299   5                          fun_pyhz2(tra_h,dir_left);//抓件位置0
1300   5                          fun_sj1zt(loc_high[0]+1);//下降到区0最高位
1301   5                          fun_sz1(han_j);//抓件
1302   5                          fun_sj1zt(loc_high07);//上升到07方最高位
1303   5                          fun_pyhz2(tra_h,dir_right);//抓件位置7
1304   5                          fun_sj1zt(loc_high[7]);//下降到区7最高位
1305   5                          fun_sz1(han_s);//松件
1306   5      
1307   5                          loc_data[7][loc_high[7]+1][0]=loc_data[0][loc_high[0]+1][0];//件已经从0区拿到
             -7区
1308   5                          loc_data[0][loc_high[0]+1][0]=0;//0区木有了
1309   5                          loc_high[0]++;//更新区0最高位
1310   5                          loc_high[7]--;//更新区7最高位
1311   5                      }
1312   4                      else{
1313   5                          if((loc_high[1]>=4)||(loc_data[0][loc_high[0]+1][0]>loc_data[1][loc_high[1]][0])){//
             -果区1能放得下,放在区1
1314   6                              fun_sj1zt(loc_high03);//上升到03方最高位
1315   6                              fun_pyhz2(tra_h,dir_left);//抓件位置0
1316   6                              fun_sj1zt(loc_high[0]+1);//下降到区0最高位
1317   6                              fun_sz1(han_j);//抓件
1318   6                              fun_sj1zt(loc_high03);//上升到03方最高位
1319   6                              fun_pyhz2(tra_kh,dir_left);//抓件位置1
1320   6                              fun_sj1zt(loc_high[1]);//下降到区1最高位
1321   6                              fun_sz1(han_s);//松件
1322   6      
1323   6                              loc_data[1][loc_high[1]+1][0]=loc_data[0][loc_high[0]+1][0];//件已经从0区拿
             -了3区
1324   6                              loc_data[0][loc_high[0]+1][0]=0;//0区木有了
1325   6                              loc_high[0]++;//更新区0最高位
1326   6                              loc_high[1]--;//更新区3最高位
1327   6                          }
1328   5                          else{//否则放在区2
1329   6                              fun_sj1zt(loc_high03);//上升到03方最高位
1330   6                              fun_pyhz2(tra_h,dir_left);//抓件位置0
1331   6                              fun_sj1zt(loc_high[0]+1);//下降到区0最高位
1332   6                              fun_sz1(han_j);//抓件
1333   6                              fun_sj1zt(loc_high03);//上升到03方最高位
1334   6                              fun_pyhz2(tra_kq,dir_left);//抓件位置2
1335   6                              fun_sj1zt(loc_high[2]);//下降到区2最高位
1336   6                              fun_sz1(han_s);//松件
1337   6      
1338   6                              loc_data[2][loc_high[2]+1][0]=loc_data[0][loc_high[0]+1][0];//件已经从0区拿
             -了3区
1339   6                              loc_data[0][loc_high[0]+1][0]=0;//0区木有了
1340   6                              loc_high[0]++;//更新区0最高位
1341   6                              loc_high[2]--;//更新区3最高位
1342   6                          }
1343   5                      }
1344   4                  }
1345   3                  else if(loc_high[1]<4){//如果区1有件
1346   4                      if(loc_data[1][loc_high[1]+1][0]==loc_data[3][loc_high[3]][1]){//如果区1最高位等于
             -区3最高位件
1347   5                          fun_sj1zt(loc_high03);//上升到03方最高位
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 23  

1348   5                          fun_pyhz2(tra_kh,dir_left);//抓件位置1
1349   5                          fun_sj1zt(loc_high[1]+1);//下降到区1最高位
1350   5                          fun_sz1(han_j);//抓件
1351   5                          fun_sj1zt(loc_high03);//上升到03方最高位
1352   5                          fun_pyhz2(tra_q,dir_left);//抓件位置2
1353   5                          fun_sj1zt(loc_high[3]);//下降到区2最高位
1354   5                          fun_sz1(han_s);//松件
1355   5      
1356   5                          loc_data[3][loc_high[3]+1][0]=loc_data[1][loc_high[1]+1][0];//件已经从1区拿到
             -3区
1357   5                          loc_data[1][loc_high[1]+1][0]=0;//1区木有了
1358   5                          loc_high[1]++;//更新区1最高位
1359   5                          loc_high[3]--;//更新区3最高位
1360   5                      }
1361   4                      else if(loc_data[1][loc_high[1]+1][0]==loc_data[7][loc_high[7]][1]){//如果区1最高位
             -于区7最高位件
1362   5                          fun_sj1zt(loc_high03);//上升到03方最高位
1363   5                          fun_pyhz2(tra_kh,dir_left);//抓件位置1
1364   5                          fun_sj1zt(loc_high[1]+1);//下降到区1最高位
1365   5                          fun_sz1(han_j);//抓件
1366   5                          fun_sj1zt(loc_high07);//上升到07方最高位
1367   5                          fun_pyhz2(tra_h,dir_right);//抓件位置7
1368   5                          fun_sj1zt(loc_high[7]);//下降到区7最高位
1369   5                          fun_sz1(han_s);//松件
1370   5      
1371   5                          loc_data[7][loc_high[7]+1][0]=loc_data[1][loc_high[1]+1][0];//件已经从1区拿到
             -7区
1372   5                          loc_data[1][loc_high[1]+1][0]=0;//1区木有了
1373   5                          loc_high[1]++;//更新区1最高位
1374   5                          loc_high[7]--;//更新区3最高位
1375   5                      }
1376   4                      else if(loc_data[1][loc_high[1]+1][0]>loc_data[2][loc_high[2]][0]){//如果区2能放得
             -,放在区2
1377   5                          fun_sj1zt(loc_high03);//上升到03方最高位
1378   5                          fun_pyhz2(tra_kh,dir_left);//抓件位置1
1379   5                          fun_sj1zt(loc_high[1]+1);//下降到区1最高位
1380   5                          fun_sz1(han_j);//抓件
1381   5                          fun_sj1zt(loc_high03);//上升到03方最高位
1382   5                          fun_pyhz2(tra_kq,dir_left);//抓件位置2
1383   5                          fun_sj1zt(loc_high[2]);//下降到区2最高位
1384   5                          fun_sz1(han_s);//松件
1385   5      
1386   5                          loc_data[2][loc_high[2]+1][0]=loc_data[1][loc_high[1]+1][0];//件已经从1区拿到
             -2区
1387   5                          loc_data[1][loc_high[1]+1][0]=0;//1区木有了
1388   5                          loc_high[1]++;//更新区1最高位
1389   5                          loc_high[2]--;//更新区3最高位
1390   5                      }
1391   4                  }
1392   3                  else if(loc_high[2]<4){//如果区2有件
1393   4                      if(loc_data[2][loc_high[2]+1][0]==loc_data[3][loc_high[3]][1]){//如果区2最高位等于
             -区3最高位件
1394   5                          fun_sj1zt(loc_high03);//上升到03方最高位
1395   5                          fun_pyhz2(tra_kq,dir_left);//抓件位置2
1396   5                          fun_sj1zt(loc_high[2]+1);//下降到区2最高位
1397   5                          fun_sz1(han_j);//抓件
1398   5                          fun_sj1zt(loc_high03);//上升到03方最高位
1399   5                          fun_pyhz2(tra_q,dir_left);//抓件位置3
1400   5                          fun_sj1zt(loc_high[2]);//下降到区3最高位
1401   5                          fun_sz1(han_s);//松件
1402   5      
1403   5                          loc_data[3][loc_high[3]+1][0]=loc_data[2][loc_high[2]+1][0];//件已经从2区拿到
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 24  

             -3区
1404   5                          loc_data[2][loc_high[2]+1][0]=0;//2区木有了
1405   5                          loc_high[2]++;//更新区2最高位
1406   5                          loc_high[3]--;//更新区3最高位
1407   5                      }
1408   4                      else if(loc_data[2][loc_high[2]+1][0]==loc_data[7][loc_high[7]][1]){//如果区2最高位
             -于区7最高位件
1409   5                          fun_sj1zt(loc_high03);//上升到03方最高位
1410   5                          fun_pyhz2(tra_kq,dir_left);//抓件位置2
1411   5                          fun_sj1zt(loc_high[2]+1);//下降到区2最高位
1412   5                          fun_sz1(han_j);//抓件
1413   5                          fun_sj1zt(loc_high07);//上升到07方最高位
1414   5                          fun_pyhz2(tra_h,dir_right);//抓件位置7
1415   5                          fun_sj1zt(loc_high[7]);//下降到区7最高位
1416   5                          fun_sz1(han_s);//松件
1417   5      
1418   5                          loc_data[7][loc_high[7]+1][0]=loc_data[2][loc_high[2]+1][0];//件已经从2区拿到
             -7区
1419   5                          loc_data[2][loc_high[2]+1][0]=0;//2区木有了
1420   5                          loc_high[2]++;//更新区2最高位
1421   5                          loc_high[7]--;//更新区7最高位
1422   5                      }
1423   4                  }
1424   3                  if((loc_data[3][4][0]==loc_data[3][4][1])&&
1425   3                     (loc_data[3][3][0]==loc_data[3][3][1])&&
1426   3                     (loc_data[3][2][0]==loc_data[3][2][1])&&
1427   3                     (loc_data[3][1][0]==loc_data[3][1][1])){
1428   4                      if((loc_data[7][4][0]==loc_data[7][4][1])&&
1429   4                         (loc_data[7][3][0]==loc_data[7][3][1])&&
1430   4                         (loc_data[7][2][0]==loc_data[7][2][1])&&
1431   4                         (loc_data[7][1][0]==loc_data[7][1][1])){
1432   5                          return;
1433   5                      }
1434   4                      else
1435   4                          fun_hz1(dir_right);
1436   4                  }
1437   3              }
1438   2              else if(str_begin.hzfx==dir_right){
1439   3                  if(loc_high[4]<4){//如果区4有件
1440   4                      if(loc_data[4][loc_high[4]+1][0]==loc_data[7][loc_high[7]][1]){//如果区4最高位等于
             -区7最高位件
1441   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1442   5                          fun_pyhz2(tra_q,dir_right);//抓件位置4
1443   5                          fun_sj1zt(loc_high[4]+1);//下降到区4最高位
1444   5                          fun_sz1(han_j);//抓件
1445   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1446   5                          fun_pyhz2(tra_h,dir_right);//抓件位置7
1447   5                          fun_sj1zt(loc_high[7]);//下降到区7最高位
1448   5                          fun_sz1(han_s);//松件
1449   5      
1450   5                          loc_data[7][loc_high[7]+1][0]=loc_data[4][loc_high[4]+1][0];//件已经从4区拿到
             -7区
1451   5                          loc_data[4][loc_high[4]+1][0]=0;//4区木有了
1452   5                          loc_high[4]++;//更新区4最高位
1453   5                          loc_high[7]--;//更新区7最高位
1454   5                      }
1455   4                      else if(loc_data[4][loc_high[4]+1][0]==loc_data[3][loc_high[3]][1]){//如果区4最高位
             -于区3最高位件
1456   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1457   5                          fun_pyhz2(tra_q,dir_right);//抓件位置4
1458   5                          fun_sj1zt(loc_high[4]+1);//下降到区4最高位
1459   5                          fun_sz1(han_j);//抓件
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 25  

1460   5                          fun_sj1zt(loc_high07);//上升到07方最高位
1461   5                          fun_pyhz2(tra_q,dir_left);//抓件位置3
1462   5                          fun_sj1zt(loc_high[3]);//下降到区3最高位
1463   5                          fun_sz1(han_s);//松件
1464   5      
1465   5                          loc_data[3][loc_high[3]+1][0]=loc_data[4][loc_high[4]+1][0];//件已经从4区拿到
             -3区
1466   5                          loc_data[4][loc_high[4]+1][0]=0;//4区木有了
1467   5                          loc_high[4]++;//更新区4最高位
1468   5                          loc_high[3]--;//更新区7最高位
1469   5                      }
1470   4                      else{
1471   5                          if((loc_high[6]>=4)||(loc_data[4][loc_high[4]+1][0]>loc_data[6][loc_high[6]][0])){//
             -果区6能放得下,放在区6
1472   6                              fun_sj1zt(loc_high47);//上升到47方最高位
1473   6                              fun_pyhz2(tra_q,dir_right);//抓件位置4
1474   6                              fun_sj1zt(loc_high[4]+1);//下降到区4最高位
1475   6                              fun_sz1(han_j);//抓件
1476   6                              fun_sj1zt(loc_high07);//上升到07方最高位
1477   6                              fun_pyhz2(tra_kq,dir_right);//抓件位置6
1478   6                              fun_sj1zt(loc_high[6]);//下降到区6最高位
1479   6                              fun_sz1(han_s);//松件
1480   6      
1481   6                              loc_data[6][loc_high[6]+1][0]=loc_data[4][loc_high[4]+1][0];//件已经从4区拿
             -了6区
1482   6                              loc_data[4][loc_high[4]+1][0]=0;//4区木有了
1483   6                              loc_high[4]++;//更新区4最高位
1484   6                              loc_high[6]--;//更新区6最高位
1485   6                          }
1486   5                          else{//否则放在区5
1487   6                              fun_sj1zt(loc_high47);//上升到47方最高位
1488   6                              fun_pyhz2(tra_q,dir_right);//抓件位置4
1489   6                              fun_sj1zt(loc_high[4]+1);//下降到区4最高位
1490   6                              fun_sz1(han_j);//抓件
1491   6                              fun_sj1zt(loc_high47);//上升到47方最高位
1492   6                              fun_pyhz2(tra_kq,dir_right);//抓件位置2
1493   6                              fun_sj1zt(loc_high[5]);//下降到区5最高位
1494   6                              fun_sz1(han_s);//松件
1495   6      
1496   6                              loc_data[5][loc_high[5]+1][0]=loc_data[4][loc_high[4]+1][0];//件已经从4区拿
             -了5区
1497   6                              loc_data[4][loc_high[4]+1][0]=0;//4区木有了
1498   6                              loc_high[4]++;//更新区4最高位
1499   6                              loc_high[5]--;//更新区6最高位
1500   6                          }
1501   5                      }
1502   4                  }
1503   3                  else if(loc_high[5]<4){//如果区5有件
1504   4                      if(loc_data[5][loc_high[5]+1][0]==loc_data[7][loc_high[7]][1]){//如果区5最高位等于
             -区7最高位件
1505   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1506   5                          fun_pyhz2(tra_kq,dir_right);//抓件位置5
1507   5                          fun_sj1zt(loc_high[5]+1);//下降到区5最高位
1508   5                          fun_sz1(han_j);//抓件
1509   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1510   5                          fun_pyhz2(tra_h,dir_right);//抓件位置2
1511   5                          fun_sj1zt(loc_high[7]);//下降到区7最高位
1512   5                          fun_sz1(han_s);//松件
1513   5      
1514   5                          loc_data[7][loc_high[7]+1][0]=loc_data[5][loc_high[5]+1][0];//件已经从5区拿到
             -7区
1515   5                          loc_data[5][loc_high[5]+1][0]=0;//5区木有了
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 26  

1516   5                          loc_high[5]++;//更新区5最高位
1517   5                          loc_high[7]--;//更新区7最高位
1518   5                      }
1519   4                      else if(loc_data[5][loc_high[5]+1][0]==loc_data[3][loc_high[3]][1]){//如果区5最高位
             -于区3最高位件
1520   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1521   5                          fun_pyhz2(tra_kq,dir_right);//抓件位置5
1522   5                          fun_sj1zt(loc_high[5]+1);//下降到区5最高位
1523   5                          fun_sz1(han_j);//抓件
1524   5                          fun_sj1zt(loc_high07);//上升到07方最高位
1525   5                          fun_pyhz2(tra_q,dir_left);//抓件位置3
1526   5                          fun_sj1zt(loc_high[3]);//下降到区3最高位
1527   5                          fun_sz1(han_s);//松件
1528   5      
1529   5                          loc_data[3][loc_high[3]+1][0]=loc_data[5][loc_high[5]+1][0];//件已经从5区拿到
             -3区
1530   5                          loc_data[5][loc_high[5]+1][0]=0;//5区木有了
1531   5                          loc_high[5]++;//更新区5最高位
1532   5                          loc_high[3]--;//更新区3最高位
1533   5                      }
1534   4                      else if(loc_data[5][loc_high[5]+1][0]>loc_data[6][loc_high[6]][0]){//如果区6能放得
             -,放在区6
1535   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1536   5                          fun_pyhz2(tra_kq,dir_right);//抓件位置5
1537   5                          fun_sj1zt(loc_high[5]+1);//下降到区5最高位
1538   5                          fun_sz1(han_j);//抓件
1539   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1540   5                          fun_pyhz2(tra_kh,dir_right);//抓件位置2
1541   5                          fun_sj1zt(loc_high[6]);//下降到区7最高位
1542   5                          fun_sz1(han_s);//松件
1543   5      
1544   5                          loc_data[6][loc_high[6]+1][0]=loc_data[5][loc_high[5]+1][0];//件已经从5区拿到
             -6区
1545   5                          loc_data[5][loc_high[5]+1][0]=0;//5区木有了
1546   5                          loc_high[5]++;//更新区5最高位
1547   5                          loc_high[6]--;//更新区7最高位
1548   5                      }
1549   4                  }
1550   3                  else if(loc_high[6]<4){//如果区6有件
1551   4                      if(loc_data[6][loc_high[6]+1][0]==loc_data[7][loc_high[7]][1]){//如果区6最高位等于
             -区7最高位件
1552   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1553   5                          fun_pyhz2(tra_kh,dir_right);//抓件位置6
1554   5                          fun_sj1zt(loc_high[6]+1);//下降到区6最高位
1555   5                          fun_sz1(han_j);//抓件
1556   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1557   5                          fun_pyhz2(tra_h,dir_right);//抓件位置7
1558   5                          fun_sj1zt(loc_high[7]);//下降到区7最高位
1559   5                          fun_sz1(han_s);//松件
1560   5      
1561   5                          loc_data[7][loc_high[7]+1][0]=loc_data[6][loc_high[6]+1][0];//件已经从6区拿到
             -7区
1562   5                          loc_data[6][loc_high[6]+1][0]=0;//2区木有了
1563   5                          loc_high[6]++;//更新区2最高位
1564   5                          loc_high[7]--;//更新区7最高位
1565   5                      }
1566   4                      else if(loc_data[6][loc_high[6]+1][0]==loc_data[3][loc_high[3]][1]){//如果区6最高位
             -于区3最高位件
1567   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1568   5                          fun_pyhz2(tra_kh,dir_right);//抓件位置6
1569   5                          fun_sj1zt(loc_high[6]+1);//下降到区6最高位
1570   5                          fun_sz1(han_j);//抓件
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 27  

1571   5                          fun_sj1zt(loc_high47);//上升到47方最高位
1572   5                          fun_pyhz2(tra_q,dir_left);//抓件位置3
1573   5                          fun_sj1zt(loc_high[3]);//下降到区7最高位
1574   5                          fun_sz1(han_s);//松件
1575   5      
1576   5                          loc_data[3][loc_high[3]+1][0]=loc_data[6][loc_high[6]+1][0];//件已经从6区拿到
             -3区
1577   5                          loc_data[6][loc_high[6]+1][0]=0;//2区木有了
1578   5                          loc_high[6]++;//更新区2最高位
1579   5                          loc_high[3]--;//更新区7最高位
1580   5                      }
1581   4                  }
1582   3                  if((loc_data[7][4][0]==loc_data[7][4][1])&&
1583   3                     (loc_data[7][3][0]==loc_data[7][3][1])&&
1584   3                     (loc_data[7][2][0]==loc_data[7][2][1])&&
1585   3                     (loc_data[7][1][0]==loc_data[7][1][1])){
1586   4                      if((loc_data[3][4][0]==loc_data[3][4][1])&&
1587   4                         (loc_data[3][3][0]==loc_data[3][3][1])&&
1588   4                         (loc_data[3][2][0]==loc_data[3][2][1])&&
1589   4                         (loc_data[3][1][0]==loc_data[3][1][1])){
1590   5                          return;
1591   5                      }
1592   4                      else
1593   4                          fun_hz1(dir_left);
1594   4                  }
1595   3              }
1596   2              else{
1597   3                  fun_hz1(dir_left);
1598   3              }
1599   2          }
1600   1      }//自动抓奸
1601          uc fun_min4(uc par_num1,uc par_num2,uc par_num3,uc par_num4){
1602   1          return 
1603   1          par_num1<par_num2?par_num1:par_num2<par_num2<par_num3?par_num2:par_num3?
1604   1          par_num1<par_num2?par_num1:par_num2<par_num3<par_num4?par_num3:par_num4?
1605   1          par_num1<par_num2?par_num1:par_num2:par_num3<par_num4?par_num3:par_num4:
1606   1          par_num2<par_num3?par_num2:par_num3<par_num3<par_num4?par_num3:par_num4?
1607   1          par_num2<par_num3?par_num2:par_num3:par_num3<par_num4?par_num3:par_num4;
1608   1      }//求4个数的最小值
1609          uc fun_min2(uc par_num1,uc par_num2){
1610   1          return 
1611   1          par_num1<par_num2?par_num1:par_num2;
1612   1      }//求2个数的最小值
1613          void fun_sj1zt(uc par_value){
1614   1          switch(par_value){
1615   2              case 0:
1616   2                  fun_sj1(sjp_wz1);
1617   2                  break;
1618   2              case 1:
1619   2                  fun_sj1(sjp_wz2);
1620   2                  break;
1621   2              case 2:
1622   2                  fun_sj1(sjp_wz3);
1623   2                  break;
1624   2              case 3:
1625   2                  fun_sj1(sjp_wz4);
1626   2                  break;
1627   2              case 4:
1628   2                  fun_sj1(sjp_wz5);
1629   2                  break;
1630   2              default:
1631   2                  break;
C51 COMPILER V9.01   8023                                                                  03/07/2015 15:53:43 PAGE 28  

1632   2          }
1633   1      }//状态的升降单步,用来配合自动抓奸
1634          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8745    ----
   CONSTANT SIZE    =      5    ----
   XDATA SIZE       =     47      93
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      38
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
