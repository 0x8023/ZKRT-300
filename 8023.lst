C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE 8023
OBJECT MODULE PLACED IN .\output\8023.obj
COMPILER INVOKED BY: D:\MyProgram\keil\C51\BIN\C51.EXE program\8023.c OPTIMIZE(8,SPEED) DEBUG OBJECTEXTEND PRINT(.\8023.
                    -lst) OBJECT(.\output\8023.obj)

line level    source

   1          #include "./output/8023.h"
   2          xdata struct str_state str_begin,str_now,str_next;//分别为:起始状态/当前状态/目标状态
   3          xdata struct str_parameter str_cod={
   4              /*ui str_cod.mlinerqd*/25000,//默认主函数巡线软起动路程为25000
   5              /*ui str_cod.mlineqc*/200,   //默认主函数巡线前冲时间为500毫秒
   6          
   7              /*ui str_cod.sj1bzw*/58,     //升降标准位延时
   8              /*ui str_cod.sj1zjw*/800,    //升降中间位延时
   9          
  10              /*ui str_cod.py1bz*/45,      //fun_py1标准位延时
  11              /*ui str_cod.py1qkq*/600,    //fun_py1前到靠前延时参数
  12              /*ui str_cod.py1kqz*/525,    //fun_py1靠前到中间延时
  13              /*ui str_cod.py1zkh*/525,    //fun_py1中间到靠后延时
  14              /*ui str_cod.py1khh*/540,    //fun_py1靠后到后延时
  15              /*ui str_cod.py1qz*/1155,    //fun_py1前到中间延时
  16              /*ui str_cod.py1zh*/1090,    //fun_py1中间到后延时
  17              /*ui str_cod.py1kqkh*/1105,  //fun_py1靠前到靠后延时
  18              /*ui str_cod.py1khkq*/1050,  //fun_py1靠后到靠前延时
  19              /*ui str_cod.py1qkh*/1735,   //fun_py1前到靠后延时
  20              /*ui str_cod.py1kqh*/1635,   //fun_py1靠前到后延时
  21          
  22              /*ui str_cod.hz1bz*/20,      //fun_hz1标准位延时
  23          
  24              /*ui turn90;*/500,           //90度转弯屏蔽延时
  25              /*ui turn180;*/2000          //180度转弯屏蔽延时
  26          };
  27          xdata struct str_timerfolline str_tfl;
  28          ul var_timer=0;
  29          void fun_delay(ui par_value,enum varENU_del par_model){
  30   1          ui loc_con=par_value;
  31   1          switch(par_model){
  32   2              case del_us://微秒级延时
  33   2                  #ifdef Debug
                              printf("fun_delay(%d,del_us);\n",par_value);
                          #else
  36   2                      while(loc_con-->0){
  37   3                          _nop_();
  38   3                          _nop_();
  39   3                      }
  40   2                  #endif
  41   2                  return;
  42   2              case del_ms://毫秒级延时
  43   2                  #ifdef Debug
                              printf("fun_delay(%d,del_ms);\n",par_value);
                          #else
  46   2                      while(loc_con-->0){
  47   3                          uc loc_i, loc_j;
  48   3                          _nop_();
  49   3                          _nop_();
  50   3                          loc_i=12;
  51   3                          loc_j=168;
  52   3                          do{
  53   4                              while(--loc_j);
  54   4                          }while(--loc_i);
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 2   

  55   3                      }
  56   2                  #endif
  57   2                  return;
  58   2              case del_s://秒级延时
  59   2                  #ifdef Debug
                              printf("fun_delay(%d,del_s);\n",par_value);
                          #else
  62   2                      while(loc_con-->0){
  63   3                          uc loc_i, loc_j, loc_k;
  64   3                          loc_i=46;
  65   3                          loc_j=153;
  66   3                          loc_k=245;
  67   3                          do{
  68   4                              do{
  69   5                                  while(--loc_k);
  70   5                              }while(--loc_j);
  71   4                          }while(--loc_i);
  72   3                      }
  73   2                  #endif
  74   2                  return;
  75   2              default:return;
  76   2          }
  77   1      }//延时
  78          void fun_timer0init(){
  79   1          #ifdef Debug
                      printf("fun_timer0init();\n");
                  #endif
  82   1          AUXR|=0x80;   //定时器时钟1T模式
  83   1          TMOD&=0xF0;   //定时器模式:16位
  84   1          TMOD|=0x01;   //定时器模式:16位
  85   1          TL0=0x20;     //定时初值:1ms
  86   1          TH0=0xD1;     //定时初值:1ms
  87   1          TF0=0;        //清除TF0标志
  88   1          ET0=1;
  89   1          EA=1;         //开启总中断
  90   1      }//1毫秒定时器0初始化
  91          void fun_timer1init(){
  92   1          #ifdef Debug
                      printf("fun_timer1init();\n");
                  #endif
  95   1          AUXR&=0xBF;     //定时器时钟12T模式
  96   1          TMOD&=0x0F;     //定时器模式:16位
  97   1          TMOD|=0x10;     //定时器模式:16位
  98   1          TL1=0xE0;       //定时初值:20ms
  99   1          TH1=0xB1;       //定时初值:20ms
 100   1          TF1=0;          //清除TF1标志
 101   1          ET1=1;
 102   1          EA=1;           //开启总中断
 103   1      }//20毫秒定时器1初始化
 104          void fun_timer0(){
 105   1          TL0=0x20;
 106   1          TH0=0xD1;//定时器初值恢复至1ms
 107   1          var_timer++;//全局计时器开始计时
 108   1          if(str_tfl.doing==tf_ture)//如果正在移动
 109   1              fun_timermove();//定时器移动
 110   1      }//1毫秒定时器0处理函数
 111          void fun_timer1(){
 112   1          TL1=0xE0;
 113   1          TH1=0xB1;
 114   1      }//20毫秒定时器1处理函数
 115          void fun_wait(){
 116   1          #ifdef Debug
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 3   

                      printf("fun_wait();\n");
                  #else
 119   1              while(in_start==1);
 120   1              fun_delay(20,del_ms);
 121   1              while(in_start==0);
 122   1              fun_delay(256,del_ms);
 123   1          #endif
 124   1      }//等待按键
 125          void fun_pwminit(){
 126   1          #ifdef Debug
                      printf("fun_pwminit();\n");
                  #endif
 129   1          CCON=0x00;//PAC寄存控制器
 130   1          CH=0;//重置PAC计时器
 131   1          CL=0;
 132   1          CMOD=0x08;//不分频
 133   1      }//PWM初始化
 134          void fun_pwmr(uc par_value){
 135   1          CCAP0H=CCAP0L=par_value*25/10;//控制输出的占空比
 136   1          CCAPM0=0X42;//8位PWM输出，无中断
 137   1          PCA_PWM0=0x00;
 138   1      }//右路PWM输出
 139          void fun_pwml(uc par_value){
 140   1          CCAP1H=CCAP1L=par_value*25/10;//控制输出的占空比
 141   1          CCAPM1=0X42;//8位PWM输出，无中断
 142   1          PCA_PWM1=0x00;
 143   1      }//左路PWM输出
 144          void fun_motors(enum varENU_mot par_model,char par_speed){
 145   1          if(par_speed>100)
 146   1              par_speed=100;
 147   1          else if(par_speed<-100)
 148   1              par_speed=-100;//速度最多100,最少-100
 149   1          switch(par_model){
 150   2              case mot_l://左轮电机
 151   2                  if(str_begin.leftsd==par_speed)
 152   2                      return;
 153   2                  else
 154   2                      str_begin.leftsd=par_speed;
 155   2                  if(par_speed==0){
 156   3                      fun_pwml(0);out_pwml=0;
 157   3                  }
 158   2                  else if(par_speed>0){
 159   3                      CR=1;fun_pwml(par_speed);out_pwml=0;
 160   3                  }
 161   2                  else if(par_speed<0){
 162   3                      CR=1;fun_pwml(cabs(par_speed));out_pwml=1;
 163   3                  }
 164   2                  break;
 165   2              case mot_r://右轮电机
 166   2                  if(str_begin.rightsd==par_speed)
 167   2                      return;
 168   2                  else
 169   2                      str_begin.rightsd=par_speed;
 170   2                  if(par_speed==0){
 171   3                      fun_pwmr(0);out_pwmr=0;
 172   3                  }
 173   2                  else if(par_speed>0){
 174   3                      CR=1;fun_pwmr(par_speed);out_pwmr=0;
 175   3                  }
 176   2                  else if(par_speed<0){
 177   3                      CR=1;fun_pwmr(cabs(par_speed));out_pwmr=1;
 178   3                  }
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 4   

 179   2                  break;
 180   2              case mot_rl://左右轮同步
 181   2                  if((str_begin.leftsd==par_speed)&&(str_begin.rightsd==par_speed))
 182   2                      return;
 183   2                  else
 184   2                      str_begin.leftsd=str_begin.rightsd=par_speed;
 185   2                  if(par_speed==0){
 186   3                      CR=0;
 187   3                      fun_pwmr(0);out_pwmr=0;
 188   3                      fun_pwml(0);out_pwml=0;
 189   3                  }
 190   2                  else if(par_speed>0){
 191   3                      CR=1;
 192   3                      fun_pwml(par_speed);out_pwml=0;
 193   3                      fun_pwmr(par_speed);out_pwmr=0;
 194   3                  }
 195   2                  else if(par_speed<0){
 196   3                      CR=1;
 197   3                      fun_pwml(cabs(par_speed));out_pwml=1;
 198   3                      fun_pwmr(cabs(par_speed));out_pwmr=1;
 199   3                  }
 200   2                  break;
 201   2              case mot_sz://正转为抓紧，反转为松开
 202   2                  if(str_begin.szsd==par_speed)
 203   2                      return;
 204   2                  else
 205   2                      str_begin.szsd=par_speed;
 206   2                  if(par_speed==0){
 207   3                      out_motorselect=1;out_dir1=0;out_en1=1;
 208   3                  }
 209   2                  else if(par_speed>0){
 210   3                      out_motorselect=1;out_dir1=1;out_en1=0;
 211   3                  }
 212   2                  else if(par_speed<0){
 213   3                      out_motorselect=1;out_dir1=0;out_en1=0;
 214   3                  }
 215   2                  break;
 216   2              case mot_py://正转是向无电机一方转,反转为向有电机一方转
 217   2                  if(str_begin.pysd==par_speed)
 218   2                      return;
 219   2                  else
 220   2                      str_begin.pysd=par_speed;
 221   2                  if(par_speed==0){
 222   3                      out_motorselect=1;out_dir2=0;out_en2=1;
 223   3                  }
 224   2                  else if(par_speed>0){
 225   3                      out_motorselect=1;out_dir2=1;out_en2=0;
 226   3                  }
 227   2                  else if(par_speed<0){
 228   3                      out_motorselect=1;out_dir2=0;out_en2=0;
 229   3                  }
 230   2                  break;
 231   2              case mot_sj://向上为正转,向下为反转
 232   2                  if(str_begin.sjsd==par_speed)
 233   2                      return;
 234   2                  else
 235   2                      str_begin.sjsd=par_speed;
 236   2                  if(par_speed==0){
 237   3                      out_motorselect=0;out_dir1=0;out_en1=1;
 238   3                  }
 239   2                  else if(par_speed>0){
 240   3                      out_motorselect=0;out_dir1=0;out_en1=0;
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 5   

 241   3                  }
 242   2                  else if(par_speed<0){
 243   3                      out_motorselect=0;out_dir1=1;out_en1=0;
 244   3                  }
 245   2                  break;
 246   2              case mot_hz://顺时针为正转,逆时针为反转
 247   2                  if(str_begin.hzsd==par_speed)
 248   2                      return;
 249   2                  else
 250   2                      str_begin.hzsd=par_speed;
 251   2                  if(par_speed==0){
 252   3                      out_motorselect=0;out_dir2=0;out_en2=1;
 253   3                  }
 254   2                  else if(par_speed>0){
 255   3                      out_motorselect=0;out_dir2=0;out_en2=0;
 256   3                  }
 257   2                  else if(par_speed<0){
 258   3                      out_motorselect=0;out_dir2=1;out_en2=0;
 259   3                  }
 260   2                  break;
 261   2              default:
 262   2                  break;
 263   2          }
 264   1      }//主函数操作电机
 265          void fun_motorsrl(enum varENU_mot par_model,char par_speed){
 266   1          if(par_speed>100)
 267   1              par_speed=100;
 268   1          else if(par_speed<-100)
 269   1              par_speed=-100;//速度最多100,最少-100
 270   1          switch(par_model){
 271   2              case mot_l://左轮电机
 272   2                  if(str_begin.leftsd==par_speed)
 273   2                      return;
 274   2                  else
 275   2                      str_begin.leftsd=par_speed;
 276   2                  if(par_speed==0){
 277   3                      fun_pwml(0);out_pwml=0;
 278   3                  }
 279   2                  else if(par_speed>0){
 280   3                      CR=1;fun_pwml(par_speed);out_pwml=0;
 281   3                  }
 282   2                  else if(par_speed<0){
 283   3                      CR=1;fun_pwml(cabs(par_speed));out_pwml=1;
 284   3                  }
 285   2                  break;
 286   2              case mot_r://右轮电机
 287   2                  if(str_begin.rightsd==par_speed)
 288   2                      return;
 289   2                  else
 290   2                      str_begin.rightsd=par_speed;
 291   2                  if(par_speed==0){
 292   3                      fun_pwmr(0);out_pwmr=0;
 293   3                  }
 294   2                  else if(par_speed>0){
 295   3                      CR=1;fun_pwmr(par_speed);out_pwmr=0;
 296   3                  }
 297   2                  else if(par_speed<0){
 298   3                      CR=1;fun_pwmr(cabs(par_speed));out_pwmr=1;
 299   3                  }
 300   2                  break;
 301   2              case mot_rl://左右轮同步
 302   2                  if((str_begin.leftsd==par_speed)&&(str_begin.rightsd==par_speed))
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 6   

 303   2                      return;
 304   2                  else
 305   2                      str_begin.leftsd=str_begin.rightsd=par_speed;
 306   2                  if(par_speed==0){
 307   3                      CR=0;
 308   3                      fun_pwmr(0);out_pwmr=0;
 309   3                      fun_pwml(0);out_pwml=0;
 310   3                  }
 311   2                  else if(par_speed>0){
 312   3                      CR=1;
 313   3                      fun_pwml(par_speed);out_pwml=0;
 314   3                      fun_pwmr(par_speed);out_pwmr=0;
 315   3                  }
 316   2                  else if(par_speed<0){
 317   3                      CR=1;
 318   3                      fun_pwml(cabs(par_speed));out_pwml=1;
 319   3                      fun_pwmr(cabs(par_speed));out_pwmr=1;
 320   3                  }
 321   2                  break;
 322   2              default:
 323   2                  break;
 324   2          }
 325   1      }//定时器操作左右轮
 326          void fun_sz1(enum varENU_han par_model){
 327   1          if(str_begin.szzt==par_model)
 328   1              return;
 329   1          if(par_model==han_s){//手抓松
 330   2              #ifdef Debug
                          printf("fun_sz1(han_s);\n");
                      #else
 333   2                  fun_motors(mot_sz,-100);
 334   2                  while(in_s==1);
 335   2              #endif
 336   2          }
 337   1          else{//手抓紧
 338   2              #ifdef Debug
                          printf("fun_sz1(han_j);\n");
                      #else
 341   2                  fun_motors(mot_sz,100);
 342   2                  while(in_j==1);
 343   2              #endif
 344   2          }
 345   1              fun_delay(20,del_ms);
 346   1              fun_motors(mot_sz,0);
 347   1          str_begin.szzt=par_model;//存储运行结果
 348   1      }//手抓单步运动
 349          void fun_py1(enum varENU_tra par_model){
 350   1          if(str_begin.pywz==par_model)
 351   1              return;
 352   1          switch(par_model){
 353   2              case tra_q://前平移(没有电机的呢个方向)
 354   2                  #ifdef Debug
                              printf("fun_py1(tra_q);\n");
                          #else
 357   2                      fun_motors(mot_py,100);
 358   2                      while(in_qpy==1);
 359   2                      fun_delay(str_cod.py1bz,del_ms);
 360   2                  #endif
 361   2                      break;
 362   2              case tra_kq://靠前平移
 363   2                  #ifdef Debug
                              printf("fun_py1(tra_kq);\n");
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 7   

                          #else
 366   2                      switch(str_begin.pywz){
 367   3                          case tra_q://现在在前面
 368   3                              fun_motors(mot_py,-100);
 369   3                              fun_delay(str_cod.py1qkq,del_ms);
 370   3                              break;
 371   3                          case tra_z://现在在中间
 372   3                              fun_motors(mot_py,100);
 373   3                              fun_delay(str_cod.py1kqz,del_ms);
 374   3                              break;
 375   3                          case tra_kh://现在在靠后
 376   3                              fun_motors(mot_py,100);
 377   3                              fun_delay(str_cod.py1khkq,del_ms);
 378   3                              break;
 379   3                          case tra_h://现在在后
 380   3                              fun_motors(mot_py,100);
 381   3                              fun_delay(str_cod.py1kqh,del_ms);
 382   3                              break;
 383   3                      }
 384   2                  #endif
 385   2                      break;
 386   2              case tra_z://平移到中间
 387   2                  #ifdef Debug
                              printf("fun_py1(tra_z);\n");
                          #else
 390   2                      switch(str_begin.pywz){
 391   3                          case tra_q://现在在前面
 392   3                              fun_motors(mot_py,-100);
 393   3                              fun_delay(str_cod.py1qz,del_ms);
 394   3                              break;
 395   3                          case tra_kq://现在在靠前
 396   3                              fun_motors(mot_py,-100);
 397   3                              fun_delay(str_cod.py1kqz,del_ms);
 398   3                              break;
 399   3                          case tra_kh://现在在靠后
 400   3                              fun_motors(mot_py,100);
 401   3                              fun_delay(str_cod.py1zkh,del_ms);
 402   3                              break;
 403   3                          case tra_h://现在在后面
 404   3                              fun_motors(mot_py,100);
 405   3                              fun_delay(str_cod.py1zh,del_ms);
 406   3                              break;
 407   3                      }
 408   2                  #endif
 409   2                      break;
 410   2              case tra_kh://平移到靠后
 411   2                  #ifdef Debug
                              printf("fun_py1(tra_kh);\n");
                          #else
 414   2                      switch(str_begin.pywz){
 415   3                          case tra_q://现在在前面
 416   3                              fun_motors(mot_py,-100);
 417   3                              fun_delay(str_cod.py1qkh,del_ms);
 418   3                              break;
 419   3                          case tra_kq://现在在靠前
 420   3                              fun_motors(mot_py,-100);
 421   3                              fun_delay(str_cod.py1kqkh,del_ms);
 422   3                              break;
 423   3                          case tra_z://现在在中间
 424   3                              fun_motors(mot_py,-100);
 425   3                              fun_delay(str_cod.py1zkh,del_ms);
 426   3                              break;
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 8   

 427   3                          case tra_h://现在在后面
 428   3                              fun_motors(mot_py,100);
 429   3                              fun_delay(str_cod.py1khh,del_ms);
 430   3                              break;
 431   3                      }
 432   2                  #endif
 433   2                      break;
 434   2              case tra_h://后平移(有电机的呢个方向)
 435   2                  #ifdef Debug
                              printf("fun_py1(tra_h);\n");
                          #else
 438   2                      fun_motors(mot_py,-100);
 439   2                      while(in_hpy==1);
 440   2                      fun_delay(str_cod.py1bz,del_ms);
 441   2                  #endif
 442   2                      break;
 443   2              default:
 444   2                  break;
 445   2          }
 446   1          fun_motors(mot_py,0);
 447   1          str_begin.pywz=par_model;//存储运行结果
 448   1      }//平移单步运动
 449          void fun_sj1(enum varENU_sjp par_model){
 450   1          if(str_begin.sjwz==par_model)
 451   1             return;
 452   1          switch(par_model){
 453   2              case sjp_1://升降位置1(最上位)
 454   2                  #ifdef Debug
                              printf("fun_sj1(sjp_1);\n");
                          #else
 457   2                      fun_motors(mot_sj,100);
 458   2                      def_select(sel_58);
 459   2                      while(in_wz1==1);
 460   2                      fun_delay(str_cod.sj1bzw,del_ms);
 461   2                  #endif
 462   2                      break;
 463   2              case sjp_12:
 464   2                  #ifdef Debug
                              printf("fun_sj1(sjp_12);\n");
                          #else
 467   2                      if(par_model>str_begin.sjwz){
 468   3                          fun_motors(mot_sj,-100);
 469   3                          fun_delay(str_cod.sj1zjw,del_ms);
 470   3                      }
 471   2                      else{//要去的地方在上面，向上走
 472   3                          fun_sj1(sjp_2);
 473   3                          fun_motors(mot_sj,100);
 474   3                          fun_delay(str_cod.sj1zjw,del_ms);
 475   3                      }
 476   2                  #endif
 477   2                      break;
 478   2              case sjp_2://升降位置2
 479   2                  #ifdef Debug
                              printf("fun_sj1(sjp_2);\n");
                          #else
 482   2                      fun_motors(mot_sj,par_model<str_begin.sjwz?100:-100);
 483   2                      def_select(sel_58);
 484   2                      while(in_wz2==1);
 485   2                      fun_delay(str_cod.sj1bzw,del_ms);
 486   2                  #endif
 487   2                      break;
 488   2              case sjp_23:
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 9   

 489   2                  #ifdef Debug
                              printf("fun_sj1(sjp_23);\n");
                          #else
 492   2                      if(par_model>str_begin.sjwz){
 493   3                          fun_sj1(sjp_2);
 494   3                          fun_motors(mot_sj,-100);
 495   3                          fun_delay(str_cod.sj1zjw,del_ms);
 496   3                      }
 497   2                      else{//要去的地方在上面，向上走
 498   3                          fun_sj1(sjp_3);
 499   3                          fun_motors(mot_sj,100);
 500   3                          fun_delay(str_cod.sj1zjw,del_ms);
 501   3                      }
 502   2                  #endif
 503   2                      break;
 504   2              case sjp_3://升降位置3
 505   2                  #ifdef Debug
                              printf("fun_sj1(sjp_3);\n");
                          #else
 508   2                      fun_motors(mot_sj,par_model<str_begin.sjwz?100:-100);
 509   2                      def_select(sel_58);
 510   2                      while(in_wz3==1);
 511   2                      fun_delay(str_cod.sj1bzw,del_ms);
 512   2                  #endif
 513   2                  break;
 514   2              case sjp_34:
 515   2                  #ifdef Debug
                              printf("fun_sj1(sjp_34);\n");
                          #else
 518   2                      if(par_model>str_begin.sjwz){
 519   3                          fun_sj1(sjp_3);
 520   3                          fun_motors(mot_sj,-100);
 521   3                          fun_delay(str_cod.sj1zjw,del_ms);
 522   3                      }
 523   2                      else{//要去的地方在上面，向上走
 524   3                          fun_sj1(sjp_4);
 525   3                          fun_motors(mot_sj,100);
 526   3                          fun_delay(str_cod.sj1zjw,del_ms);
 527   3                      }
 528   2                  #endif
 529   2                      break;
 530   2              case sjp_4://升降位置4
 531   2                  #ifdef Debug
                              printf("fun_sj1(sjp_4);\n");
                          #else
 534   2                      fun_motors(mot_sj,par_model<str_begin.sjwz?100:-100);
 535   2                      def_select(sel_58);
 536   2                      while(in_wz4==1);
 537   2                      fun_delay(str_cod.sj1bzw,del_ms);
 538   2                  #endif
 539   2                      break;
 540   2              case sjp_45:
 541   2                  #ifdef Debug
                              printf("fun_sj1(sjp_45);\n");
                          #else
 544   2                      if(par_model>str_begin.sjwz){
 545   3                          fun_sj1(sjp_4);
 546   3                          fun_motors(mot_sj,-100);
 547   3                          fun_delay(str_cod.sj1zjw,del_ms);
 548   3                      }
 549   2                      else{//要去的地方在上面，向上走
 550   3                          fun_motors(mot_sj,100);
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 10  

 551   3                          fun_delay(str_cod.sj1zjw,del_ms);
 552   3                      }
 553   2                  #endif
 554   2                      break;
 555   2              case sjp_5://升降位置5
 556   2                  #ifdef Debug
                              printf("fun_sj1(sjp_5);\n");
                          #else
 559   2                      fun_motors(mot_sj,-100);
 560   2                      def_select(sel_912);
 561   2                      while(in_wz5==1);
 562   2                      fun_delay(str_cod.sj1bzw,del_ms);
 563   2                  #endif
 564   2                      break;
 565   2              default:
 566   2                  break;
 567   2          }
 568   1          fun_motors(mot_sj,0);
 569   1          str_begin.sjwz=par_model;//存储运行结果
 570   1      }//升降单步运动
 571          void fun_hz1(enum varENU_dir par_model){
 572   1          if(str_begin.hzfx==par_model)
 573   1              return;
 574   1          def_select(sel_912);
 575   1          switch(par_model){
 576   2              case dir_up://回转至前方
 577   2                  #ifdef Debug
                              printf("fun_hz1(dir_up);\n");
                          #else
 580   2                      switch(str_begin.hzfx){
 581   3                          case dir_down://现在在下方
 582   3                              fun_motors(mot_hz,-100);
 583   3                              fun_delay(1,del_s);
 584   3                              while(in_hz==1);
 585   3                              while(in_hz==0);
 586   3                              while(in_hz==1);
 587   3                              fun_delay(str_cod.hz1bz,del_ms);
 588   3                              break;
 589   3                          case dir_left://现在在左边
 590   3                              fun_motors(mot_hz,100);
 591   3                              fun_delay(1,del_s);
 592   3                              while(in_hz==1);
 593   3                              fun_delay(str_cod.hz1bz,del_ms);
 594   3                              break;
 595   3                          case dir_right://现在在右边
 596   3                              fun_motors(mot_hz,-100);
 597   3                              fun_delay(1,del_s);
 598   3                              while(in_hz==1);
 599   3                              fun_delay(str_cod.hz1bz,del_ms);
 600   3                              break;
 601   3                          default:
 602   3                              break;
 603   3                      }
 604   2                  #endif
 605   2                      break;
 606   2              case dir_down://要去下面
 607   2                  #ifdef Debug
                              printf("fun_hz1(dir_down);\n");
                          #else
 610   2                      switch(str_begin.hzfx){
 611   3                          case dir_up://现在在上面
 612   3                              fun_motors(mot_hz,100);
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 11  

 613   3                              fun_delay(1,del_s);
 614   3                              while(in_hz==1);
 615   3                              while(in_hz==0);
 616   3                              while(in_hz==1);
 617   3                              fun_delay(str_cod.hz1bz,del_ms);
 618   3                              break;
 619   3                          case dir_left://现在在左面
 620   3                              fun_motors(mot_hz,-100);
 621   3                              fun_delay(1,del_s);
 622   3                              while(in_hz==1);
 623   3                              fun_delay(str_cod.hz1bz,del_ms);
 624   3                              break;
 625   3                              break;
 626   3                          case dir_right://现在在右面
 627   3                              fun_motors(mot_hz,100);
 628   3                              fun_delay(1,del_s);
 629   3                              while(in_hz==1);
 630   3                              fun_delay(str_cod.hz1bz,del_ms);
 631   3                              break;
 632   3                          default:
 633   3                              break;
 634   3                      }
 635   2                  #endif
 636   2                      break;
 637   2              case dir_left://要去左边
 638   2                  #ifdef Debug
                              printf("fun_hz1(dir_left);\n");
                          #else
 641   2                      switch(str_begin.hzfx){
 642   3                          case dir_up://现在在上面
 643   3                              fun_motors(mot_hz,-100);
 644   3                              fun_delay(1,del_s);
 645   3                              while(in_hz==1);
 646   3                              fun_delay(str_cod.hz1bz,del_ms);
 647   3                              break;
 648   3                              break;
 649   3                          case dir_down://现在在下面
 650   3                              fun_motors(mot_hz,100);
 651   3                              fun_delay(1,del_s);
 652   3                              while(in_hz==1);
 653   3                              fun_delay(str_cod.hz1bz,del_ms);
 654   3                              break;
 655   3                              break;
 656   3                          case dir_right://现在在右面
 657   3                              fun_motors(mot_hz,-100);
 658   3                              fun_delay(1,del_s);
 659   3                              while(in_hz==1);
 660   3                              while(in_hz==0);
 661   3                              while(in_hz==1);
 662   3                              fun_delay(str_cod.hz1bz,del_ms);
 663   3                              break;
 664   3                          default:
 665   3                              break;
 666   3                      }
 667   2                  #endif
 668   2                      break;
 669   2              case dir_right://要去右面
 670   2                  #ifdef Debug
                              printf("fun_hz1(dir_right);\n");
                          #else
 673   2                      switch(str_begin.hzfx){
 674   3                          case dir_up://现在在前面
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 12  

 675   3                              fun_motors(mot_hz,100);
 676   3                              fun_delay(1,del_s);
 677   3                              while(in_hz==1);
 678   3                              fun_delay(str_cod.hz1bz,del_ms);
 679   3                              break;
 680   3                          case dir_down://现在在下面
 681   3                              fun_motors(mot_hz,-100);
 682   3                              fun_delay(1,del_s);
 683   3                              while(in_hz==1);
 684   3                              fun_delay(str_cod.hz1bz,del_ms);
 685   3                              break;
 686   3                          case dir_left://现在在左面
 687   3                              fun_motors(mot_hz,100);
 688   3                              fun_delay(1,del_s);
 689   3                              while(in_hz==1);
 690   3                              while(in_hz==0);
 691   3                              while(in_hz==1);
 692   3                              fun_delay(str_cod.hz1bz,del_ms);
 693   3                              break;
 694   3                          default:
 695   3                              break;
 696   3                      }
 697   2                  #endif
 698   2                      break;
 699   2              default:
 700   2                  break;
 701   2          }
 702   1          fun_motors(mot_hz,0);
 703   1          str_begin.hzfx=par_model;//存储运行结果
 704   1      }//回转单步运动
 705          void fun_pyhz2(enum varENU_tra par_pymodel,enum varENU_dir par_hzmodel){
 706   1          switch(par_hzmodel){//获取想要到达的回转位置
 707   2              case dir_left://要去左边
 708   2                  switch(str_begin.hzfx){
 709   3                      case dir_right://现在在右边
 710   3                          fun_motors(mot_hz,-100);
 711   3                          break;
 712   3                      case dir_up://现在在上面
 713   3                          fun_motors(mot_hz,-100);
 714   3                          break;
 715   3                      case dir_down://现在在下面
 716   3                          fun_motors(mot_hz,100);
 717   3                          break;
 718   3                      default:
 719   3                          break;
 720   3                  }//获取现在回转所在的位置
 721   2                  break;
 722   2              case dir_right://要去右边
 723   2                  switch(str_begin.hzfx){
 724   3                      case dir_left://现在在左边
 725   3                          fun_motors(mot_hz,100);
 726   3                          break;
 727   3                      case dir_up://现在在上面
 728   3                          fun_motors(mot_hz,100);
 729   3                          break;
 730   3                      case dir_down://现在在下面
 731   3                          fun_motors(mot_hz,-100);
 732   3                          break;
 733   3                      default:
 734   3                          break;
 735   3                  }//获取现在回转所在的位置
 736   2                  break;
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 13  

 737   2              case dir_up://要去上面
 738   2                  switch(str_begin.hzfx){
 739   3                      case dir_left://现在在左边
 740   3                          fun_motors(mot_hz,100);
 741   3                          break;
 742   3                      case dir_right://现在在右边
 743   3                          fun_motors(mot_hz,-100);
 744   3                          break;
 745   3                      case dir_down://现在在下面
 746   3                          fun_motors(mot_hz,-100);
 747   3                          break;
 748   3                      default:
 749   3                          break;
 750   3                  }//获取现在回转所在的位置
 751   2                  break;
 752   2              case dir_down://要去下面
 753   2                  switch(str_begin.hzfx){
 754   3                      case dir_left://现在在左边
 755   3                          fun_motors(mot_hz,-100);
 756   3                          break;
 757   3                      case dir_right://现在在右边
 758   3                          fun_motors(mot_hz,100);
 759   3                          break;
 760   3                      case dir_up://现在在上面
 761   3                          fun_motors(mot_hz,100);
 762   3                          break;
 763   3                      default:
 764   3                          break;
 765   3                  }//获取现在回转所在的位置
 766   2                  break;
 767   2              default:
 768   2                  break;
 769   2          }//获取现在要去的回转位置
 770   1          switch(par_pymodel){
 771   2              case tra_q://前平移(没有电机的呢个方向)
 772   2                  fun_motors(mot_py,100);
 773   2                  while(in_qpy==1);
 774   2                  fun_delay(str_cod.py1bz,del_ms);
 775   2                  break;
 776   2              case tra_kq://靠前
 777   2                  switch(str_begin.pywz){
 778   3                      case tra_q://现在在前面
 779   3                          fun_motors(mot_py,-100);
 780   3                          fun_delay(str_cod.py1qkq,del_ms);
 781   3                          break;
 782   3                      case tra_z://现在在中间
 783   3                          fun_motors(mot_py,100);
 784   3                          fun_delay(str_cod.py1kqz,del_ms);
 785   3                          break;
 786   3                      case tra_kh://现在在靠后
 787   3                          fun_motors(mot_py,100);
 788   3                          fun_delay(str_cod.py1khkq,del_ms);
 789   3                          break;
 790   3                      case tra_h://现在在后面
 791   3                          fun_motors(mot_py,100);
 792   3                          fun_delay(str_cod.py1kqh,del_ms);
 793   3                          break;
 794   3                  }
 795   2                  break;
 796   2              case tra_z://中
 797   2                  switch(str_begin.pywz){
 798   3                      case tra_q://现在在前面
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 14  

 799   3                          fun_motors(mot_py,-100);
 800   3                          fun_delay(str_cod.py1qz,del_ms);
 801   3                          break;
 802   3                      case tra_kq://现在在靠前
 803   3                          fun_motors(mot_py,-100);
 804   3                          fun_delay(str_cod.py1kqz,del_ms);
 805   3                          break;
 806   3                      case tra_kh://现在在靠后
 807   3                          fun_motors(mot_py,100);
 808   3                          fun_delay(str_cod.py1zkh,del_ms);
 809   3                          break;
 810   3                      case tra_h://现在在后面
 811   3                          fun_motors(mot_py,100);
 812   3                          fun_delay(str_cod.py1zh,del_ms);
 813   3                          break;
 814   3                  }
 815   2                  break;
 816   2              case tra_kh://靠后
 817   2                  switch(str_begin.pywz){
 818   3                      case tra_q://现在在前面
 819   3                          fun_motors(mot_py,-100);
 820   3                          fun_delay(str_cod.py1qkh,del_ms);
 821   3                          break;
 822   3                      case tra_kq://现在在靠前
 823   3                          fun_motors(mot_py,-100);
 824   3                          fun_delay(str_cod.py1kqkh,del_ms);
 825   3                          break;
 826   3                      case tra_z://现在在中间
 827   3                          fun_motors(mot_py,-100);
 828   3                          fun_delay(str_cod.py1zkh,del_ms);
 829   3                          break;
 830   3                      case tra_h://现在在后面
 831   3                          fun_motors(mot_py,100);
 832   3                          fun_delay(str_cod.py1khh,del_ms);
 833   3                          break;
 834   3                  }
 835   2                  break;
 836   2              case tra_h://后平移(有电机的呢个方向)
 837   2                  fun_motors(mot_py,-100);
 838   2                  while(in_hpy==1);
 839   2                  fun_delay(str_cod.py1bz,del_ms);
 840   2                  break;
 841   2              default:
 842   2                  break;
 843   2          }//获取现在平移所在的位置
 844   1          fun_motors(mot_py,0);//停止平移动作
 845   1          str_begin.pywz=par_pymodel;//存储运行结果
 846   1          switch(par_hzmodel){//获取想要到达的回转位置
 847   2              case dir_up://回转至前方
 848   2                  switch(str_begin.hzfx){
 849   3                      case dir_down://现在在下方
 850   3                          while(in_hz==1);
 851   3                          while(in_hz==0);
 852   3                          while(in_hz==1);
 853   3                          fun_delay(str_cod.hz1bz,del_ms);
 854   3                          break;
 855   3                      case dir_left://现在在左边
 856   3                          while(in_hz==1);
 857   3                          fun_delay(str_cod.hz1bz,del_ms);
 858   3                          break;
 859   3                      case dir_right://现在在右边
 860   3                          while(in_hz==1);
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 15  

 861   3                          fun_delay(str_cod.hz1bz,del_ms);
 862   3                          break;
 863   3                      default:
 864   3                          break;
 865   3                  }
 866   2                  break;
 867   2              case dir_down://要去下面
 868   2                  switch(str_begin.hzfx){
 869   3                      case dir_up://现在在上面
 870   3                          while(in_hz==1);
 871   3                          while(in_hz==0);
 872   3                          while(in_hz==1);
 873   3                          fun_delay(str_cod.hz1bz,del_ms);
 874   3                          break;
 875   3                      case dir_left://现在在左面
 876   3                          while(in_hz==1);
 877   3                          fun_delay(str_cod.hz1bz,del_ms);
 878   3                          break;
 879   3                          break;
 880   3                      case dir_right://现在在右面
 881   3                          while(in_hz==1);
 882   3                          fun_delay(str_cod.hz1bz,del_ms);
 883   3                          break;
 884   3                      default:
 885   3                          break;
 886   3                  }
 887   2                  break;
 888   2              case dir_left://要去左边
 889   2                  switch(str_begin.hzfx){
 890   3                      case dir_up://现在在上面
 891   3                          while(in_hz==1);
 892   3                          fun_delay(str_cod.hz1bz,del_ms);
 893   3                          break;
 894   3                          break;
 895   3                      case dir_down://现在在下面
 896   3                          while(in_hz==1);
 897   3                          fun_delay(str_cod.hz1bz,del_ms);
 898   3                          break;
 899   3                          break;
 900   3                      case dir_right://现在在右面
 901   3                          while(in_hz==1);
 902   3                          while(in_hz==0);
 903   3                          while(in_hz==1);
 904   3                          fun_delay(str_cod.hz1bz,del_ms);
 905   3                          break;
 906   3                      default:
 907   3                          break;
 908   3                  }
 909   2                  break;
 910   2              case dir_right://要去右面
 911   2                  switch(str_begin.hzfx){
 912   3                      case dir_up://现在在前面
 913   3                          while(in_hz==1);
 914   3                          fun_delay(str_cod.hz1bz,del_ms);
 915   3                          break;
 916   3                      case dir_down://现在在下面
 917   3                          while(in_hz==1);
 918   3                          fun_delay(str_cod.hz1bz,del_ms);
 919   3                          break;
 920   3                      case dir_left://现在在左面
 921   3                          while(in_hz==1);
 922   3                          while(in_hz==0);
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 16  

 923   3                          while(in_hz==1);
 924   3                          fun_delay(str_cod.hz1bz,del_ms);
 925   3                          break;
 926   3                      default:
 927   3                          break;
 928   3                  }
 929   2                  break;
 930   2              default:
 931   2                  break;
 932   2          }//获取现在要去的回转位置
 933   1          fun_motors(mot_hz,0);//停止回转动作
 934   1          str_begin.hzfx=par_hzmodel;//存储运行结果
 935   1      }//平移回转同步运动
 936          void fun_jtjp(){
 937   1          while(1){
 938   2              if((!in_ls1&&!in_ls2&&in_ls4&&in_ls5&&!in_ls7&&!in_ls8)&&((in_ls3&&in_ls6)||(!in_ls3&&!in_ls6))){
 939   3                  fun_delay(10,del_ms);
 940   3                  fun_motors(mot_rl,0);
 941   3                  return;
 942   3              }
 943   2              if(in_ls2||in_ls1){
 944   3                  fun_motors(mot_l,16);
 945   3                  fun_motors(mot_r,-16);
 946   3              }
 947   2              else if(in_ls7||in_ls8){
 948   3                  fun_motors(mot_l,-16);
 949   3                  fun_motors(mot_r,16);
 950   3              }
 951   2              else{
 952   3                  if(!in_ls4){
 953   4                      fun_motors(mot_l,-12);
 954   4                      fun_motors(mot_r,12);
 955   4                  }
 956   3                  else if(!in_ls5){
 957   4                      fun_motors(mot_l,12);
 958   4                      fun_motors(mot_r,-12);
 959   4                  }
 960   3                  else{
 961   4                      if(in_ls6&&!in_ls3){
 962   5                          fun_motors(mot_l,-8);
 963   5                          fun_motors(mot_r,8);
 964   5                      }
 965   4                      if(in_ls3&&!in_ls6){
 966   5                          fun_motors(mot_l,8);
 967   5                          fun_motors(mot_r,-8);
 968   5                      }
 969   4                  }
 970   3              }
 971   2          }
 972   1      }//静态纠偏
 973          void fun_timermove(){
 974   1          static uc loc_con=0;//需要分步做的动作需要用到此静态私有分步标志位
 975   1          int loc_sdl,loc_sdr;//左轮速度和右轮速度的局部变量
 976   1          switch(*str_tfl.run){//选择运行方式
 977   2              case def_end://运行结束
 978   2                  fun_motorsrl(mot_rl,0);//再次停止电机运动
 979   2                  str_tfl.doing=tf_false;//移动结束
 980   2                  memset(str_tfl.step,0,sizeof(str_tfl.step));//清空step数组
 981   2                  str_tfl.run=str_tfl.step;//指针指向step的第一个元素
 982   2                  break;
 983   2              case tfl_line://运行巡线
 984   2                  if(*(str_tfl.run+1)){//如果参数为非0数
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 17  

 985   3                      if((in_ls1||in_ls8)&&(in_ls2&&in_ls3&&in_ls4&&in_ls5&in_ls6&&in_ls7)){//如果中间6个
             -全亮,左右亮任意一个
 986   4                          str_tfl.online=tf_ture;//标志位记录在线
 987   4                          fun_motorsrl(mot_rl,str_tfl.gospeed);//按照常规速度过线
 988   4                      }
 989   3                      else if(str_tfl.online==tf_ture){//如果标志位记录在线,而且不符合在线特征
 990   4                          str_tfl.online=tf_false;//标志位记录不在线
 991   4                          (*(str_tfl.run+1))--;//参数值减1,记录已经走了一条线
 992   4                      }
 993   3                      else{
 994   4                          loc_sdl=loc_sdr=str_tfl.gospeed;//巡线速度为str_tfl.gospeed
 995   4                          if(in_ls1&&!in_ls8){//1亮8不亮
 996   5                              loc_sdl*=0.7;//左减速
 997   5                              loc_sdr*=1.3;//右加速
 998   5                          }//向左转
 999   4                          if(in_ls8&&!in_ls1){//8亮1不亮
1000   5                              loc_sdl*=1.3;//左加速
1001   5                              loc_sdr*=0.7;//右减速
1002   5                          }//向右转
1003   4                          if(in_ls2&&!in_ls7){//2亮7不亮
1004   5                              loc_sdl*=0.8;//左减速
1005   5                              loc_sdr*=1.2;//右加速
1006   5                          }//向左转
1007   4                          if(in_ls7&&!in_ls2){//7亮2不亮
1008   5                              loc_sdl*=1.2;//左加速
1009   5                              loc_sdr*=0.8;//右减速
1010   5                          }//向右转
1011   4                          if(in_ls3&&!in_ls6){//3亮6不亮
1012   5                              loc_sdl*=0.9;//左减速
1013   5                              loc_sdr*=1.1;//右加速
1014   5                          }//向左转
1015   4                          if(in_ls6&&!in_ls3){//6亮3不亮
1016   5                              loc_sdl*=1.1;//左加速
1017   5                              loc_sdr*=0.9;//右减速
1018   5                          }//向右转
1019   4                          fun_motorsrl(mot_r,loc_sdr);
1020   4                          fun_motorsrl(mot_l,loc_sdl);
1021   4                      }
1022   3                  }
1023   2                  else{//如果线走完了
1024   3                      str_tfl.run+=2;//指针指向下一组过程
1025   3                      fun_motorsrl(mot_rl,0);//停止电机运动
1026   3                  }
1027   2                  break;
1028   2              case tfl_turn://运行转弯
1029   2                  switch(loc_con){//分步运行标志位
1030   3                      case 0://第一步
1031   3                          switch(*(str_tfl.run+1)){//获取参数
1032   4                              case tur_r90://右转90
1033   4                                  fun_motorsrl(mot_l,str_tfl.turnspeed);//左轮向前
1034   4                                  fun_motorsrl(mot_r,-str_tfl.turnspeed);//右轮向后
1035   4                                  str_tfl.delay=var_timer+str_cod.turn90;//计时
1036   4                                  break;
1037   4                              case tur_l90://左转90
1038   4                                  fun_motorsrl(mot_l,-str_tfl.turnspeed);//左轮向后
1039   4                                  fun_motorsrl(mot_r,str_tfl.turnspeed);//右轮向前
1040   4                                  str_tfl.delay=var_timer+str_cod.turn90;//计时
1041   4                                  break;
1042   4                              case tur_r180://右转180
1043   4                                  fun_motorsrl(mot_l,str_tfl.turnspeed);//左轮向前
1044   4                                  fun_motorsrl(mot_r,-str_tfl.turnspeed);//右轮向后
1045   4                                  str_tfl.delay=var_timer+str_cod.turn180;//计时
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 18  

1046   4                                  break;
1047   4                              case tur_l180://左转180
1048   4                                  fun_motorsrl(mot_l,-str_tfl.turnspeed);//左轮向后
1049   4                                  fun_motorsrl(mot_r,str_tfl.turnspeed);//左轮向前
1050   4                                  str_tfl.delay=var_timer+str_cod.turn180;//计时
1051   4                                  break;
1052   4                          }
1053   3                          loc_con++;//执行下一步
1054   3                          break;
1055   3                      case 1://第二步
1056   3                          if(str_tfl.delay<=var_timer)//计时时间到
1057   3                              loc_con++;//执行下一步
1058   3                          break;
1059   3                      case 2://第三步
1060   3                          if(in_ls4&&in_ls5){//如果中间两个灯亮
1061   4                              fun_motorsrl(mot_rl,0);//停止电机
1062   4                              str_tfl.run+=2;//指针指向下一组过程
1063   4                              str_tfl.delay=0;//延时计数器归零
1064   4                              loc_con=0;//分步运行标志位归零
1065   4                          }
1066   3                          break;
1067   3                  }
1068   2                  break;
1069   2              case tfl_cache://运行前冲
1070   2                  switch(loc_con){
1071   3                      case 0://第一步
1072   3                          str_tfl.delay=var_timer+((*(str_tfl.run+1))*10);//延时时间(毫秒)为参数的10
             -
1073   3                          loc_con++;//执行下一步
1074   3                          break;
1075   3                      case 1://第二步
1076   3                          if(str_tfl.delay<=var_timer){//计时时间到
1077   4                              fun_motorsrl(mot_rl,0);//停止电机
1078   4                              str_tfl.run+=2;//指针指向下一组过程
1079   4                              str_tfl.delay=0;//延时计数器归零
1080   4                              loc_con=0;//分步运行标志位归零
1081   4                          }
1082   3                          else{
1083   4                              loc_sdl=loc_sdr=str_tfl.cachespeed;//前冲速度为str_tfl.cachespeed
1084   4                              if(in_ls1&&!in_ls8){//1亮8不亮
1085   5                                  loc_sdl*=0.5;//左减速
1086   5                                  loc_sdr*=1.5;//右加速
1087   5                              }//向左转
1088   4                              if(in_ls8&&!in_ls1){//8亮1不亮
1089   5                                  loc_sdl*=1.5;//左加速
1090   5                                  loc_sdr*=0.5;//右减速
1091   5                              }//向右转
1092   4                              if(in_ls2&&!in_ls7){//2亮7不亮
1093   5                                  loc_sdl*=0.7;//左减速
1094   5                                  loc_sdr*=1.3;//右加速
1095   5                              }//向左转
1096   4                              if(in_ls7&&!in_ls2){//7亮2不亮
1097   5                                  loc_sdl*=1.3;//左加速
1098   5                                  loc_sdr*=0.7;//右减速
1099   5                              }//向右转
1100   4                              if(in_ls3&&!in_ls6){//3亮6不亮
1101   5                                  loc_sdl*=0.9;//左减速
1102   5                                  loc_sdr*=1.1;//右加速
1103   5                              }//向左转
1104   4                              if(in_ls6&&!in_ls3){//6亮3不亮
1105   5                                  loc_sdl*=1.1;//左加速
1106   5                                  loc_sdr*=0.9;//右减速
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 19  

1107   5                              }//向右转
1108   4                              fun_motorsrl(mot_r,loc_sdr);
1109   4                              fun_motorsrl(mot_l,loc_sdl);
1110   4                          }
1111   3                          break;
1112   3                  }
1113   2                  break;
1114   2              case tfl_start://运行带加速的前冲
1115   2      
1116   2                  break;
1117   2              case tfl_end://运行带减速的前冲
1118   2      
1119   2                  break;
1120   2          }
1121   1      }//定时器移动
1122          void fun_folline(uc par_con,uc par_speed){
1123   1          uc loc_con=par_con;//巡线条数标志位
1124   1          uc loc_sdr,loc_sdl;//左右轮速度
1125   1          uc loc_online;//在线标志位
1126   1          while(loc_con){
1127   2              if((in_ls1||in_ls8)&&(in_ls2&&in_ls3&&in_ls4&&in_ls5&in_ls6&&in_ls7)){//如果中间6个灯全亮,
             -左右亮任意一个
1128   3                  loc_online=tf_ture;//标志位记录在线
1129   3                  fun_motors(mot_rl,par_speed);//按照常规速度过线
1130   3              }
1131   2              else if(loc_online==tf_ture){//如果标志位记录在线,而且不符合在线特征
1132   3                  loc_online=tf_false;//标志位记录不在线
1133   3                  loc_con--;//参数值减1,记录已经走了一条线
1134   3              }
1135   2              else{
1136   3                  loc_sdr=loc_sdl=par_speed;
1137   3                  if(in_ls1&&!in_ls8){//1亮8不亮
1138   4                      loc_sdl*=0.5;//左减速
1139   4                      loc_sdr*=1.5;//右加速
1140   4                  }//向左转
1141   3                  if(in_ls8&&!in_ls1){//8亮1不亮
1142   4                      loc_sdl*=1.5;//左加速
1143   4                      loc_sdr*=0.5;//右减速
1144   4                  }//向右转
1145   3                  if(in_ls2&&!in_ls7){//2亮7不亮
1146   4                      loc_sdl*=0.7;//左减速
1147   4                      loc_sdr*=1.3;//右加速
1148   4                  }//向左转
1149   3                  if(in_ls7&&!in_ls2){//7亮2不亮
1150   4                      loc_sdl*=1.3;//左加速
1151   4                      loc_sdr*=0.7;//右减速
1152   4                  }//向右转
1153   3                  if(in_ls3&&!in_ls6){//3亮6不亮
1154   4                      loc_sdl*=0.9;//左减速
1155   4                      loc_sdr*=1.1;//右加速
1156   4                  }//向左转
1157   3                  if(in_ls6&&!in_ls3){//6亮3不亮
1158   4                      loc_sdl*=1.1;//左加速
1159   4                      loc_sdr*=0.9;//右减速
1160   4                  }//向右转
1161   3                  fun_motors(mot_r,loc_sdr);
1162   3                  fun_motors(mot_l,loc_sdl);
1163   3                  fun_delay(1,del_ms);
1164   3              }
1165   2          }//如果巡线条数不为0
1166   1          fun_qc(65,40);
1167   1      }//主函数巡线
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 20  

1168          void fun_turn(enum varENU_tur par_model,uc par_speed){
1169   1          switch(par_model){//获取参数
1170   2              case tur_r90://右转90
1171   2                  fun_motors(mot_l,par_speed);//左轮向前
1172   2                  fun_motors(mot_r,-par_speed);//右轮向后
1173   2                  fun_delay(str_cod.turn90,del_ms);//计时
1174   2                  break;
1175   2              case tur_l90://左转90
1176   2                  fun_motors(mot_l,-par_speed);//左轮向后
1177   2                  fun_motors(mot_r,par_speed);//右轮向前
1178   2                  fun_delay(str_cod.turn90,del_ms);//计时
1179   2                  break;
1180   2              case tur_r180://右转180
1181   2                  fun_motors(mot_l,par_speed);//左轮向前
1182   2                  fun_motors(mot_r,-par_speed);//右轮向后
1183   2                  fun_delay(str_cod.turn180,del_ms);//计时
1184   2                  break;
1185   2              case tur_l180://左转180
1186   2                  fun_motors(mot_l,-par_speed);//左轮向后
1187   2                  fun_motors(mot_r,par_speed);//左轮向前
1188   2                  fun_delay(str_cod.turn180,del_ms);//计时
1189   2                  break;
1190   2          }
1191   1          while(!in_ls4||!in_ls5);
1192   1          fun_motors(mot_rl,0);//停止电机
1193   1      }//主函数转弯
1194          void fun_qc(uc par_time,uc par_speed){
1195   1          uc loc_sdr,loc_sdl;//左右轮速度
1196   1          str_tfl.delay=var_timer+par_time*10;//延时时间(毫秒)为参数的10倍
1197   1          while(str_tfl.delay>var_timer){
1198   2              loc_sdr=loc_sdl=par_speed;
1199   2              if(in_ls1&&!in_ls8){//1亮8不亮
1200   3                  loc_sdl*=0.7;//左减速
1201   3                  loc_sdr*=1.3;//右加速
1202   3              }//向左转
1203   2              if(in_ls8&&!in_ls1){//8亮1不亮
1204   3                  loc_sdl*=1.3;//左加速
1205   3                  loc_sdr*=0.7;//右减速
1206   3              }//向右转
1207   2              if(in_ls2&&!in_ls7){//2亮7不亮
1208   3                  loc_sdl*=0.8;//左减速
1209   3                  loc_sdr*=1.2;//右加速
1210   3              }//向左转
1211   2              if(in_ls7&&!in_ls2){//7亮2不亮
1212   3                  loc_sdl*=1.2;//左加速
1213   3                  loc_sdr*=0.8;//右减速
1214   3              }//向右转
1215   2              if(in_ls3&&!in_ls6){//3亮6不亮
1216   3                  loc_sdl*=0.9;//左减速
1217   3                  loc_sdr*=1.1;//右加速
1218   3              }//向左转
1219   2              if(in_ls6&&!in_ls3){//6亮3不亮
1220   3                  loc_sdl*=1.1;//左加速
1221   3                  loc_sdr*=0.9;//右减速
1222   3              }//向右转
1223   2              fun_motors(mot_r,loc_sdr);
1224   2              fun_motors(mot_l,loc_sdl);
1225   2              fun_delay(1,del_ms);
1226   2          }
1227   1          fun_motors(mot_rl,0);//停止电机
1228   1      }//主函数前冲
1229          void fun_stope2prom(){
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 21  

1230   1          IAP_CONTR = 0;                  //关闭IAP功能
1231   1          IAP_CMD = 0;                    //清除命令
1232   1          IAP_TRIG = 0;                   //清除触发寄存器
1233   1          IAP_ADDRH = 0x80;               //数据指针指向非EEPROM区
1234   1          IAP_ADDRL = 0;                  //清除IAP地址
1235   1      }//关闭EEPROM功能(IapIdle)
1236          uc fun_reade2prom(ui par_add){
1237   1          uc loc_dat;                     //数据缓冲区
1238   1          IAP_CONTR = 0x83;               //打开EEPROM功能,设置等待时间
1239   1          IAP_CMD = 1;                    //设置EEPROM读命令
1240   1          IAP_ADDRL = par_add;            //设置EEPROM地址低八位
1241   1          IAP_ADDRH = par_add >> 8;       //设置EEPROM地址高八位
1242   1          IAP_TRIG = 0x5a;                //触发
1243   1          IAP_TRIG = 0xa5;                //再次触发
1244   1          fun_delay(10,del_us);           //稍等一会儿
1245   1          loc_dat = IAP_DATA;             //读出EEPROM中的数据
1246   1          fun_stope2prom();               //关闭EEPROM功能
1247   1          return loc_dat;                 //返回读取结果
1248   1      }//读取EEPROM数据
1249          void fun_writee2prom(ui par_add,uc par_dat){
1250   1          IAP_CONTR = 0x83;               //打开EEPROM功能,设置等待时间
1251   1          IAP_CMD = 2;                    //设置EEPROM写入命令
1252   1          IAP_ADDRL = par_add;            //设置EEPROM地址低八位
1253   1          IAP_ADDRH = par_add >> 8;       //设置EEPROM地址高八位
1254   1          IAP_DATA = par_dat;             //写入数据
1255   1          IAP_TRIG = 0x5a;                //触发
1256   1          IAP_TRIG = 0xa5;                //再次触发
1257   1          fun_delay(10,del_us);           //稍等一会儿
1258   1          fun_stope2prom();               //关闭EEPROM功能
1259   1      }//写EEPROM数据
1260          void fun_cleane2prom(ui par_add){
1261   1          IAP_CONTR = 0x83;               //打开EEPROM功能,设置等待时间
1262   1          IAP_CMD = 3;                    //设置EEPROM擦除命令
1263   1          IAP_ADDRL = par_add;            //设置EEPROM地址低八位
1264   1          IAP_ADDRH = par_add >> 8;       //设置EEPROM地址高八位
1265   1          IAP_TRIG = 0x5a;                //触发
1266   1          IAP_TRIG = 0xa5;                //再次触发
1267   1          fun_delay(10,del_us);           //稍等一会儿
1268   1          fun_stope2prom();               //关闭EEPROM功能
1269   1      }//清除EEPROM数据
1270          void fun_calibration(){
1271   1          // fun_sj1(sjp_1);//升到最上位
1272   1          ul loc_time;
1273   1          fun_py1(tra_q);//移动到最前端
1274   1          fun_py1(tra_h);//移动到最后端
1275   1          loc_time=var_timer;
1276   1          fun_py1(tra_q);//移动到前端并计时
1277   1          fun_py1(tra_h);//移动到后端
1278   1          loc_time=var_timer-loc_time;
1279   1          loc_time*=0.5;
1280   1          str_cod.py1zh=loc_time*0.5;//从后到中间
1281   1          str_cod.py1qz=loc_time*0.5;//从前到中间
1282   1          str_cod.py1qkh=loc_time*0.75;//从前到靠后
1283   1          str_cod.py1kqh=loc_time*0.564;//从靠前到后
1284   1          str_cod.py1qkq=loc_time*0.34;//从前到靠前
1285   1          str_cod.py1khh=loc_time*0.2701;//从后到靠后
1286   1          str_cod.py1kqz=loc_time*0.189;//从靠前到中间
1287   1          str_cod.py1zkh=loc_time*0.20;//从靠后到中间
1288   1          str_cod.py1kqkh=loc_time*0.5;//从靠前到靠后
1289   1          str_cod.py1khkq=loc_time*0.5;//从靠后到靠前
1290   1      }//自动校准平移参数
1291          void fun_port(){
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 22  

1292   1          //19200bps@12.000MHz
1293   1          PCON |= 0x80;       //使能波特率倍速位SMOD
1294   1          SCON = 0x50;        //8位数据,可变波特率
1295   1          AUXR |= 0x04;       //独立波特率发生器时钟为Fosc,即1T
1296   1          BRT = 0xD9;         //设定独立波特率发生器重装值
1297   1          AUXR |= 0x01;       //串口1选择独立波特率发生器为波特率发生器
1298   1          AUXR |= 0x10;       //启动独立波特率发生器
1299   1      }//串口初始化
1300          void fun_test(){
1301   1          fun_sz1(han_j);
1302   1          fun_delay(1,del_s);
1303   1          fun_sz1(han_s);
1304   1          fun_delay(1,del_s);
1305   1          fun_sz1(han_j);
1306   1          fun_delay(1,del_s);
1307   1          fun_sz1(han_s);
1308   1          fun_delay(1,del_s);
1309   1      
1310   1          str_begin.pywz=tra_h;
1311   1          fun_py1(tra_q);
1312   1          fun_delay(1,del_s);
1313   1          fun_py1(tra_h);
1314   1          fun_delay(1,del_s);
1315   1          fun_py1(tra_q);
1316   1          fun_delay(1,del_s);
1317   1          fun_py1(tra_h);
1318   1          fun_delay(1,del_s);
1319   1      
1320   1          fun_sj1(sjp_1);
1321   1          fun_delay(1,del_s);
1322   1          fun_sj1(sjp_2);
1323   1          fun_delay(1,del_s);
1324   1          fun_sj1(sjp_3);
1325   1          fun_delay(1,del_s);
1326   1          fun_sj1(sjp_4);
1327   1          fun_delay(1,del_s);
1328   1          fun_sj1(sjp_5);
1329   1          fun_delay(1,del_s);
1330   1          fun_sj1(sjp_4);
1331   1          fun_delay(1,del_s);
1332   1          fun_sj1(sjp_3);
1333   1          fun_delay(1,del_s);
1334   1          fun_sj1(sjp_2);
1335   1          fun_delay(1,del_s);
1336   1          fun_sj1(sjp_1);
1337   1      
1338   1          str_now.hzfx=str_begin.hzfx;
1339   1          str_begin.hzfx=dir_up;
1340   1          fun_hz1(dir_right);
1341   1          fun_delay(1,del_s);
1342   1          fun_hz1(dir_up);
1343   1          fun_delay(1,del_s);
1344   1          fun_hz1(dir_right);
1345   1          fun_delay(1,del_s);
1346   1          fun_hz1(dir_up);
1347   1          fun_delay(1,del_s);
1348   1          str_begin.hzfx=str_now.hzfx;
1349   1      
1350   1          fun_motors(mot_rl,60);
1351   1          fun_delay(1,del_s);
1352   1          fun_motors(mot_rl,0);
1353   1          fun_delay(1,del_s);
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 23  

1354   1      
1355   1          fun_motors(mot_rl,-60);
1356   1          fun_delay(1,del_s);
1357   1          fun_motors(mot_rl,0);
1358   1          fun_delay(1,del_s);
1359   1      
1360   1          fun_motors(mot_r,40);
1361   1          fun_motors(mot_l,-40);
1362   1          fun_delay(1,del_s);
1363   1          fun_motors(mot_rl,0);
1364   1          fun_delay(1,del_s);
1365   1      
1366   1          fun_motors(mot_r,-40);
1367   1          fun_motors(mot_l,40);
1368   1          fun_delay(1,del_s);
1369   1          fun_motors(mot_rl,0);
1370   1      }//测试程序
1371          uc fun_min(uc par_num,...){
1372   1          va_list loc_argp;//保存参数结构
1373   1          uc loc_min=par_num;//现在的最小值就是第一个
1374   1          uc loc_shu;//当前参数
1375   1          va_start(loc_argp,par_num);//loc_argp指向传入的第一个可选参数，par_num是最后一个确
             -的参数
1376   1          loc_shu=va_arg(loc_argp,uc);//取出下一个参数
1377   1          do{
1378   2              if(loc_shu<loc_min)
1379   2                  loc_min=loc_shu;
1380   2              loc_shu=va_arg(loc_argp,uc);//取出下一个参数
1381   2          }while(loc_shu!=def_end);
1382   1          va_end(loc_argp);//结束
1383   1          return loc_min;//退出
1384   1      }//求最小值
1385          void fun_coordinate(){
1386   1          
1387   1      }//自动巡线之坐标
1388          void fun_zdzj(ul par_04,ul par_37){//ul型数据,一次输入所有结果,无需等待
1389   1          xdata struct str_zdzj str_pass,str_end;//str_zdzj(自动抓件)的结构体:现在的数据和结束
             -得到的结果
1390   1          xdata char loc_high[8];         //每摞工件的高度
1391   1          xdata uc loc_xh1;             //第一个循环
1392   1      
1393   1          memset(str_pass.jx,0,sizeof(str_pass.jx));//清空现在件序
1394   1          memset(str_end.jx,0,sizeof(str_end.jx)); //清空想要的件序
1395   1          memset(loc_high,5,sizeof(loc_high));     //每组高度置5(没有件)
1396   1      
1397   1          //起始区件号
1398   1          str_pass.jx[0][1]=(par_04/10000000)%10;  //传入现在件序:区0的第1号件件号(最高位)
1399   1          str_pass.jx[0][2]=(par_04/1000000)%10;   //传入现在件序:区0的第2号件件号
1400   1          str_pass.jx[0][3]=(par_04/100000)%10;    //传入现在件序:区0的第3号件件号
1401   1          str_pass.jx[0][4]=(par_04/10000)%10;     //传入现在件序:区0的第4号件件号(最低位)
1402   1          str_pass.jx[4][1]=(par_04/1000)%10;      //传入现在件序:区4的第1号件件号(最高位)
1403   1          str_pass.jx[4][2]=(par_04/100)%10;       //传入现在件序:区4的第2号件件号
1404   1          str_pass.jx[4][3]=(par_04/10)%10;        //传入现在件序:区4的第3号件件号
1405   1          str_pass.jx[4][4]=par_04%10;             //传入现在件序:区4的第4号件件号(最低位)
1406   1          //目的区件号
1407   1          str_pass.jx[3][1]=(par_37/10000000)%10;  //传入现在件序:区0的第1号件件号(最高位)
1408   1          str_pass.jx[3][2]=(par_37/1000000)%10;   //传入现在件序:区0的第2号件件号
1409   1          str_pass.jx[3][3]=(par_37/100000)%10;    //传入现在件序:区0的第3号件件号
1410   1          str_pass.jx[3][4]=(par_37/10000)%10;     //传入现在件序:区0的第4号件件号(最低位)
1411   1          str_pass.jx[7][1]=(par_37/1000)%10;      //传入现在件序:区4的第1号件件号(最高位)
1412   1          str_pass.jx[7][2]=(par_37/100)%10;       //传入现在件序:区4的第2号件件号
1413   1          str_pass.jx[7][3]=(par_37/10)%10;        //传入现在件序:区4的第3号件件号
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 24  

1414   1          str_pass.jx[7][4]=par_37%10;             //传入现在件序:区4的第4号件件号(最低位)
1415   1          //目的次序
1416   1          str_end.jx[3][1]=1;                      //标准目标次序:区3的第1号目的次序号(最高位)
1417   1          str_end.jx[3][2]=2;                      //标准目标次序:区3的第2号目的次序号
1418   1          str_end.jx[3][3]=3;                      //标准目标次序:区3的第3号目的次序号
1419   1          str_end.jx[3][4]=4;                      //标准目标次序:区3的第4号目的次序号(最低位)
1420   1          str_end.jx[7][1]=5;                      //标准目标次序:区7的第1号目的次序号(最高位)
1421   1          str_end.jx[7][2]=6;                      //标准目标次序:区7的第2号目的次序号
1422   1          str_end.jx[7][3]=7;                      //标准目标次序:区7的第3号目的次序号
1423   1          str_end.jx[7][4]=8;                      //标准目标次序:区7的第4号目的次序号(最低位)
1424   1      
1425   1          for(loc_xh1=1;loc_xh1<=4;loc_xh1++){
1426   2              if((str_pass.jx[0][loc_xh1]==str_pass.jx[3][1])&&(str_pass.jx[0][loc_xh1]!=0))
1427   2                  str_end.jx[0][loc_xh1]=str_end.jx[3][1];
1428   2              else if((str_pass.jx[0][loc_xh1]==str_pass.jx[3][2])&&(str_pass.jx[0][loc_xh1]!=0))
1429   2                  str_end.jx[0][loc_xh1]=str_end.jx[3][2];
1430   2              else if((str_pass.jx[0][loc_xh1]==str_pass.jx[3][3])&&(str_pass.jx[0][loc_xh1]!=0))
1431   2                  str_end.jx[0][loc_xh1]=str_end.jx[3][3];
1432   2              else if((str_pass.jx[0][loc_xh1]==str_pass.jx[3][4])&&(str_pass.jx[0][loc_xh1]!=0))
1433   2                  str_end.jx[0][loc_xh1]=str_end.jx[3][4];
1434   2              else if((str_pass.jx[0][loc_xh1]==str_pass.jx[7][1])&&(str_pass.jx[0][loc_xh1]!=0))
1435   2                  str_end.jx[0][loc_xh1]=str_end.jx[7][1];
1436   2              else if((str_pass.jx[0][loc_xh1]==str_pass.jx[7][2])&&(str_pass.jx[0][loc_xh1]!=0))
1437   2                  str_end.jx[0][loc_xh1]=str_end.jx[7][2];
1438   2              else if((str_pass.jx[0][loc_xh1]==str_pass.jx[7][3])&&(str_pass.jx[0][loc_xh1]!=0))
1439   2                  str_end.jx[0][loc_xh1]=str_end.jx[7][3];
1440   2              else if((str_pass.jx[0][loc_xh1]==str_pass.jx[7][4])&&(str_pass.jx[0][loc_xh1]!=0))
1441   2                  str_end.jx[0][loc_xh1]=str_end.jx[7][4];
1442   2      
1443   2              if((str_pass.jx[4][loc_xh1]==str_pass.jx[3][1])&&(str_pass.jx[4][loc_xh1]!=0))
1444   2                  str_end.jx[4][loc_xh1]=str_end.jx[3][1];
1445   2              else if((str_pass.jx[4][loc_xh1]==str_pass.jx[3][2])&&(str_pass.jx[4][loc_xh1]!=0))
1446   2                  str_end.jx[4][loc_xh1]=str_end.jx[3][2];
1447   2              else if((str_pass.jx[4][loc_xh1]==str_pass.jx[3][3])&&(str_pass.jx[4][loc_xh1]!=0))
1448   2                  str_end.jx[4][loc_xh1]=str_end.jx[3][3];
1449   2              else if((str_pass.jx[4][loc_xh1]==str_pass.jx[3][4])&&(str_pass.jx[4][loc_xh1]!=0))
1450   2                  str_end.jx[4][loc_xh1]=str_end.jx[3][4];
1451   2              else if((str_pass.jx[4][loc_xh1]==str_pass.jx[7][1])&&(str_pass.jx[4][loc_xh1]!=0))
1452   2                  str_end.jx[4][loc_xh1]=str_end.jx[7][1];
1453   2              else if((str_pass.jx[4][loc_xh1]==str_pass.jx[7][2])&&(str_pass.jx[4][loc_xh1]!=0))
1454   2                  str_end.jx[4][loc_xh1]=str_end.jx[7][2];
1455   2              else if((str_pass.jx[4][loc_xh1]==str_pass.jx[7][3])&&(str_pass.jx[4][loc_xh1]!=0))
1456   2                  str_end.jx[4][loc_xh1]=str_end.jx[7][3];
1457   2              else if((str_pass.jx[4][loc_xh1]==str_pass.jx[7][4])&&(str_pass.jx[4][loc_xh1]!=0))
1458   2                  str_end.jx[4][loc_xh1]=str_end.jx[7][4];
1459   2          }//通过实际件序获得编号
1460   1      
1461   1          memset(str_pass.jx,0,sizeof(str_pass.jx));//清空现在实际件序
1462   1          for(loc_xh1=1;loc_xh1<=4;loc_xh1++){
1463   2              str_pass.jx[0][loc_xh1]=str_end.jx[0][loc_xh1];
1464   2              str_pass.jx[4][loc_xh1]=str_end.jx[4][loc_xh1];
1465   2          }//将现在的件序从str_end.jx中拿到str_pass.jx
1466   1          for(loc_xh1=1;loc_xh1<=4;loc_xh1++){
1467   2              str_end.jx[0][loc_xh1]=0;
1468   2              str_end.jx[4][loc_xh1]=0;
1469   2          }//删除str_end.jx中现在的件序
1470   1          loc_high[0]=loc_high[4]=1;//只有0号和4号放满了件
1471   1          loc_xh1=0;//循环标志位归零
1472   1      
1473   1          /*
1474   1              到目前为止准备工作结束,现在的数组中没有实际件序,
1475   1              现在的编号在str_pass.jx中,
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 25  

1476   1              想要得到的结果件序编号在str_end.jx中
1477   1          */
1478   1          while(1){
1479   2              //退出条件
1480   2              if((str_pass.jx[3][1]==str_end.jx[3][1])&&
1481   2              (str_pass.jx[3][2]==str_end.jx[3][2])&&
1482   2              (str_pass.jx[3][3]==str_end.jx[3][3])&&
1483   2              (str_pass.jx[3][4]==str_end.jx[3][4])&&
1484   2              (str_pass.jx[7][1]==str_end.jx[7][1])&&
1485   2              (str_pass.jx[7][2]==str_end.jx[7][2])&&
1486   2              (str_pass.jx[7][3]==str_end.jx[7][3])&&
1487   2              (str_pass.jx[7][4]==str_end.jx[7][4])){
1488   3                  if(str_begin.hzfx==dir_left){
1489   4                      fun_sz1(han_s);                 //手抓松
1490   4                      fun_sj1(sjp_1);                 //升降到最高位
1491   4                      fun_zjzt(mot_pyhz,7);           //平面位置7
1492   4                      fun_zjzt(mot_sj,loc_high[7]);   //升降到7的最高位
1493   4                      fun_sz1(han_j);                 //手抓紧
1494   4                  }//如果停在左边
1495   3                  return;
1496   3              }//如果小车一方的实际件序和想要达到的件序相等
1497   2              if(str_begin.hzfx==dir_left){
1498   3                  //转向条件
1499   3                  loc_xh1++;//标志位+1
1500   3                  if(loc_xh1>=100){
1501   4                      loc_xh1=0;
1502   4                      fun_zjzt(mot_sj,fun_min(loc_high[0],loc_high[1],loc_high[2],loc_high[3],loc_high[4],loc_hi
             -gh[5],loc_high[6],loc_high[7],def_end)-1);
1503   4                      fun_hz1(dir_right);
1504   4                  }
1505   3                  //可以一次拿走,不需要中间位的
1506   3                  if(loc_high[1]<5){
1507   4                      if(str_pass.jx[1][loc_high[1]]==str_end.jx[3][loc_high[3]-1]){
1508   5                          fun_najian(1,3,loc_high,str_pass.jx);//1-->3
1509   5                          continue;
1510   5                      }
1511   4                  }//如果区1有件
1512   3                  if(loc_high[2]<5){
1513   4                      if(str_pass.jx[2][loc_high[2]]==str_end.jx[3][loc_high[3]-1]){
1514   5                          fun_najian(2,3,loc_high,str_pass.jx);//2-->3
1515   5                          continue;
1516   5                      }
1517   4                  }//如果区2有件
1518   3                  if(loc_high[0]<5){
1519   4                      if(str_pass.jx[0][loc_high[0]]==str_end.jx[3][loc_high[3]-1]){
1520   5                          fun_najian(0,3,loc_high,str_pass.jx);//0-->3
1521   5                          continue;
1522   5                      }
1523   4                      if(str_pass.jx[0][loc_high[0]]==str_end.jx[7][loc_high[7]-1]){
1524   5                          fun_najian(0,7,loc_high,str_pass.jx);//0-->7
1525   5                          continue;
1526   5                      }
1527   4                  }//如果区0有件
1528   3      
1529   3                  //不可以一次拿走,需要中间位的
1530   3                  if(loc_high[0]<5){
1531   4                      if((str_pass.jx[0][loc_high[0]]==str_end.jx[3][1])||
1532   4                      (str_pass.jx[0][loc_high[0]]==str_end.jx[3][2])||
1533   4                      (str_pass.jx[0][loc_high[0]]==str_end.jx[3][3])||
1534   4                      (str_pass.jx[0][loc_high[0]]==str_end.jx[3][4])){
1535   5                          if(((loc_high[1]==5)||//如果1区没放东西或者
1536   5                          (str_pass.jx[0][loc_high[0]]>str_pass.jx[1][loc_high[1]]))&&//0区的件编号大于1
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 26  

             -的编号并且
1537   5                          (loc_high[1]>2)){//1区不能放超过2个件
1538   6                              fun_najian(0,1,loc_high,str_pass.jx);//0-->1
1539   6                              continue;
1540   6                          }
1541   5                          if(((loc_high[2]==5)||//如果2区没放东西或者
1542   5                          (str_pass.jx[0][loc_high[0]]>str_pass.jx[2][loc_high[2]]))&&//0区的件编号大于2
             -的编号并且
1543   5                          (loc_high[2]>2)){//2区不能放超过2个件
1544   6                              fun_najian(0,2,loc_high,str_pass.jx);//0-->2
1545   6                              continue;
1546   6                          }
1547   5                      }//如果要放在3上,但目前不能放
1548   4                      if((str_pass.jx[0][loc_high[0]]==str_end.jx[7][1])||
1549   4                      (str_pass.jx[0][loc_high[0]]==str_end.jx[7][2])||
1550   4                      (str_pass.jx[0][loc_high[0]]==str_end.jx[7][3])||
1551   4                      (str_pass.jx[0][loc_high[0]]==str_end.jx[7][4])){
1552   5                          if(((loc_high[5]==5)||//如果5区没东西放或者
1553   5                          (str_pass.jx[0][loc_high[0]]>str_pass.jx[5][loc_high[5]]))&&//0区的件编号大于5
             -的编号并且
1554   5                          (loc_high[5]>2)){//5区不能放超过2个件
1555   6                              fun_najian(0,5,loc_high,str_pass.jx);//0-->5
1556   6                              continue;
1557   6                          }
1558   5                          if(((loc_high[6]==5)||//如果6区没东西放或者
1559   5                          (str_pass.jx[0][loc_high[0]]>str_pass.jx[6][loc_high[6]]))&&//0区的件编号大于6
             -的编号并且
1560   5                          (loc_high[6]>2)){//6区不能放超过2个件
1561   6                              fun_najian(0,6,loc_high,str_pass.jx);//0-->6
1562   6                              continue;
1563   6                          }
1564   5                      }//如果要放在7上,但目前不能放
1565   4                  }//如果区0有件
1566   3      
1567   3                  //中间两个位置也不能一次搞定的
1568   3                  if((loc_high[1]<5)&&(loc_high[2]<5)){
1569   4                      if((str_pass.jx[1][loc_high[1]]>str_pass.jx[2][loc_high[2]])&&(loc_high[2]>1)){
1570   5                          fun_najian(1,2,loc_high,str_pass.jx);//1-->2
1571   5                          continue;
1572   5                      }//1的件比2的件大且区2放了不到3个件
1573   4                      if((str_pass.jx[2][loc_high[2]]>str_pass.jx[1][loc_high[1]])&&(loc_high[1]>1)){
1574   5                          fun_najian(2,1,loc_high,str_pass.jx);//2-->1
1575   5                          continue;
1576   5                      }//2的件比1的件大且区1放了不到3个件
1577   4                  }//如果区1和区2都有件
1578   3      
1579   3                  //中间两个位置怎么也搞不定的
1580   3                  if((loc_high[1]<5)&&(loc_high[2]<5)){
1581   4                      if((loc_high[0]>1)&&(str_pass.jx[1][loc_high[1]]>str_pass.jx[0][loc_high[0]])){
1582   5                          fun_najian(1,0,loc_high,str_pass.jx);//1-->0
1583   5                          continue;
1584   5                      }//1区的件比0区的大且0区放了不到3个件
1585   4                      if((loc_high[0]>1)&&(str_pass.jx[2][loc_high[2]]>str_pass.jx[0][loc_high[0]])){
1586   5                          fun_najian(2,0,loc_high,str_pass.jx);//2-->0
1587   5                          continue;
1588   5                      }//2区的件比0区的大且0区放了不到3个件
1589   4                  }
1590   3              }//如果回转在左边 
1591   2              if(str_begin.hzfx==dir_right){
1592   3                  //转向条件
1593   3                  loc_xh1++;//标志位+1
1594   3                  if(loc_xh1>=100){
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 27  

1595   4                      loc_xh1=0;
1596   4                      fun_zjzt(mot_sj,fun_min(loc_high[0],loc_high[1],loc_high[2],loc_high[3],loc_high[4],loc_hi
             -gh[5],loc_high[6],loc_high[7],def_end)-1);
1597   4                      fun_hz1(dir_left);
1598   4                  }
1599   3                  //可以一次拿走,不需要中间位的
1600   3                  if(loc_high[5]<5){
1601   4                      if(str_pass.jx[5][loc_high[5]]==str_end.jx[7][loc_high[7]-1]){
1602   5                          fun_najian(5,7,loc_high,str_pass.jx);//5-->7
1603   5                          continue;
1604   5                      }//5-->7
1605   4                  }//如果区5有件
1606   3                  if(loc_high[6]<5){
1607   4                      if(str_pass.jx[6][loc_high[6]]==str_end.jx[7][loc_high[7]-1]){
1608   5                          fun_najian(6,7,loc_high,str_pass.jx);//6-->7
1609   5                          continue;
1610   5                      }//6-->7
1611   4                  }//如果区6有件
1612   3                  if(loc_high[4]<5){
1613   4                      if(str_pass.jx[4][loc_high[4]]==str_end.jx[7][loc_high[7]-1]){
1614   5                          fun_najian(4,7,loc_high,str_pass.jx);//4-->7
1615   5                          continue;
1616   5                      }//4-->7
1617   4                      if(str_pass.jx[4][loc_high[4]]==str_end.jx[3][loc_high[3]-1]){
1618   5                          fun_najian(4,3,loc_high,str_pass.jx);//4-->3
1619   5                          continue;
1620   5                      }//4-->3
1621   4                  }//如果区4有件
1622   3      
1623   3                  //不可以一次拿走,需要中间位的
1624   3                  if(loc_high[4]<5){
1625   4                      if((str_pass.jx[4][loc_high[4]]==str_end.jx[7][1])||
1626   4                      (str_pass.jx[4][loc_high[4]]==str_end.jx[7][2])||
1627   4                      (str_pass.jx[4][loc_high[4]]==str_end.jx[7][3])||
1628   4                      (str_pass.jx[4][loc_high[4]]==str_end.jx[7][4])){
1629   5                          if(((loc_high[5]==5)||//如果5区没东西放或者
1630   5                          (str_pass.jx[4][loc_high[4]]>str_pass.jx[5][loc_high[5]]))&&//4区的件编号大于5
             -的编号并且
1631   5                          (loc_high[5]>2)){//5区不能放超过2个件
1632   6                              fun_najian(4,5,loc_high,str_pass.jx);//4-->5
1633   6                              continue;
1634   6                          }
1635   5                          if(((loc_high[6]==5)||//如果6区没东西放或者
1636   5                          (str_pass.jx[4][loc_high[4]]>str_pass.jx[6][loc_high[6]]))&&//4区的件编号大于6
             -的编号并且
1637   5                          (loc_high[6]>2)){//6区不能放超过2个件
1638   6                              fun_najian(4,6,loc_high,str_pass.jx);//4-->6
1639   6                              continue;
1640   6                          }
1641   5                      }//如果要放在7上,但目前不能放
1642   4                      if((str_pass.jx[4][loc_high[4]]==str_end.jx[3][1])||
1643   4                      (str_pass.jx[4][loc_high[4]]==str_end.jx[3][2])||
1644   4                      (str_pass.jx[4][loc_high[4]]==str_end.jx[3][3])||
1645   4                      (str_pass.jx[4][loc_high[4]]==str_end.jx[3][4])){
1646   5                          if(((loc_high[1]==5)||//如果1区没放东西或者
1647   5                          (str_pass.jx[4][loc_high[4]]>str_pass.jx[1][loc_high[1]]))&&//4区的件编号大于1
             -的编号并且
1648   5                          (loc_high[1]>2)){//1区不能放超过2个件
1649   6                              fun_najian(4,1,loc_high,str_pass.jx);//4-->1
1650   6                              continue;
1651   6                          }
1652   5                          if(((loc_high[2]==5)||//如果2区没放东西或者
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 28  

1653   5                              (str_pass.jx[4][loc_high[4]]>str_pass.jx[2][loc_high[2]]))&&//4区的件编号大
             -2区的编号并且
1654   5                              (loc_high[2]>2)){//2区不能放超过2个件
1655   6                              fun_najian(4,2,loc_high,str_pass.jx);//4-->2
1656   6                              continue;
1657   6                          }
1658   5                      }//如果要放在3上,但目前不能放
1659   4                  }//如果区4有件
1660   3      
1661   3                  //中间两个位置也不能一次搞定的
1662   3                  if((loc_high[5]<5)&&(loc_high[6]<5)){
1663   4                      if((str_pass.jx[5][loc_high[5]]>str_pass.jx[6][loc_high[6]])&&(loc_high[6]>1)){
1664   5                          fun_najian(5,6,loc_high,str_pass.jx);//5-->6
1665   5                          continue;
1666   5                      }//5的件比6的件大且区6放了不到3个件
1667   4                      if((str_pass.jx[6][loc_high[6]]>str_pass.jx[5][loc_high[5]])&&(loc_high[5]>1)){
1668   5                          fun_najian(6,5,loc_high,str_pass.jx);//6-->5
1669   5                          continue;
1670   5                      }//6的件比5的件大且区5放了不到3个件
1671   4                  }//如果区5和区6都有件
1672   3      
1673   3                  //中间两个位置怎么也搞不定的
1674   3                  if((loc_high[5]<5)&&(loc_high[6]<5)){
1675   4                      if((loc_high[4]>1)&&(str_pass.jx[5][loc_high[5]]>str_pass.jx[4][loc_high[4]])){
1676   5                          fun_najian(5,4,loc_high,str_pass.jx);//5-->4
1677   5                          continue;
1678   5                      }//5区的件比4区的大且4区放了不到3个件
1679   4                      if((loc_high[4]>1)&&(str_pass.jx[6][loc_high[6]]>str_pass.jx[4][loc_high[4]])){
1680   5                          fun_najian(6,4,loc_high,str_pass.jx);//6-->4
1681   5                          continue;
1682   5                      }//6区的件比4区的大且4区放了不到3个件
1683   4                  }
1684   3              }//如果回转在右边
1685   2          }    
1686   1      }//自动抓件
1687          void fun_zjzt(uc par_motor,char par_model){
1688   1          if(par_motor==mot_pyhz){
1689   2              switch(par_model){
1690   3                  case 0:
1691   3                      if((str_begin.pywz==tra_h)&&(str_begin.hzfx==dir_left))
1692   3                          break;
1693   3                      if(str_begin.hzfx==dir_right)
1694   3                          fun_pyhz2(tra_z,dir_left);
1695   3                      fun_py1(tra_h);
1696   3                      break;
1697   3                  case 1:
1698   3                      if((str_begin.pywz==tra_kh)&&(str_begin.hzfx==dir_left))
1699   3                          break;
1700   3                      if(str_begin.hzfx==dir_right)
1701   3                          fun_pyhz2(tra_z,dir_left);
1702   3                      fun_py1(tra_kh);
1703   3                      break;
1704   3                  case 2:
1705   3                      if((str_begin.pywz==tra_kq)&&(str_begin.hzfx==dir_left))
1706   3                          break;
1707   3                      if(str_begin.hzfx==dir_right)
1708   3                          fun_pyhz2(tra_z,dir_left);
1709   3                      fun_py1(tra_kq);
1710   3                      break;
1711   3                  case 3:
1712   3                      if((str_begin.pywz==tra_q)&&(str_begin.hzfx==dir_left))
1713   3                          break;
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 29  

1714   3                      if(str_begin.hzfx==dir_right)
1715   3                          fun_pyhz2(tra_z,dir_left);
1716   3                      fun_py1(tra_q);
1717   3                      break;
1718   3                  case 4:
1719   3                      if((str_begin.pywz==tra_q)&&(str_begin.hzfx==dir_right))
1720   3                          break;
1721   3                      if(str_begin.hzfx==dir_left)
1722   3                          fun_pyhz2(tra_z,dir_right);
1723   3                      fun_py1(tra_q);
1724   3                      break;
1725   3                  case 5:
1726   3                      if((str_begin.pywz==tra_kq)&&(str_begin.hzfx==dir_right))
1727   3                          break;
1728   3                      if(str_begin.hzfx==dir_left)
1729   3                          fun_pyhz2(tra_z,dir_right);
1730   3                      fun_py1(tra_kq);
1731   3                      break;
1732   3                  case 6:
1733   3                      if((str_begin.pywz==tra_kh)&&(str_begin.hzfx==dir_right))
1734   3                          break;
1735   3                      if(str_begin.hzfx==dir_left)
1736   3                          fun_pyhz2(tra_z,dir_right);
1737   3                      fun_py1(tra_kh);
1738   3                      break;
1739   3                  case 7:
1740   3                      if((str_begin.pywz==tra_h)&&(str_begin.hzfx==dir_right))
1741   3                          break;
1742   3                      if(str_begin.hzfx==dir_left)
1743   3                          fun_pyhz2(tra_z,dir_right);
1744   3                      fun_py1(tra_h);
1745   3                      break;
1746   3                  default:
1747   3                      break;
1748   3              }
1749   2          }
1750   1          else if(par_motor==mot_sj){
1751   2              switch(par_model){
1752   3                  case 0:
1753   3                      fun_sj1(sjp_1);
1754   3                      break;
1755   3                  case 1:
1756   3                      fun_sj1(sjp_2);
1757   3                      break;
1758   3                  case 2:
1759   3                      fun_sj1(sjp_3);
1760   3                      break;
1761   3                  case 3:
1762   3                      fun_sj1(sjp_4);
1763   3                      break;
1764   3                  case 4:
1765   3                      fun_sj1(sjp_5);
1766   3                      break;
1767   3                  default:
1768   3                      if(par_model<0)
1769   3                          fun_sj1(sjp_1);
1770   3                      else if(par_model>5)
1771   3                          fun_sj1(sjp_5);
1772   3                      break;
1773   3              }
1774   2          }
1775   1      }//抓件状态,0为左上位,3为左下位,4为右上位,7为右下位
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 30  

1776          void fun_najian(uc par_now,uc par_next,char par_high[8],uc par_data[8][5]){
1777   1          #ifdef Debug
                      printf("%d --> %d\n",(ui)par_now,(ui)par_next);
                  #else
1780   1              //取各位置的最高位
1781   1              xdata uc loc_high=fun_min(par_high[0],par_high[1],par_high[2],par_high[3],par_high[4],par_high[5],
             -par_high[6],par_high[7],def_end);
1782   1              //升起
1783   1              if(par_now==0||par_now==1||par_now==2||par_now==3){
1784   2                  if(str_begin.hzfx==dir_left)
1785   2                      fun_zjzt(mot_sj,fun_min(par_high[0],par_high[1],par_high[2],par_high[3],def_end)-1);
1786   2                  else if(str_begin.hzfx==dir_right)
1787   2                      fun_zjzt(mot_sj,fun_min(par_high[0],par_high[1],par_high[2],par_high[3],par_high[4],par_hi
             -gh[5],par_high[6],par_high[7],def_end)-1);            
1788   2              }
1789   1              else if(par_now==4||par_now==5||par_now==6||par_now==7){
1790   2                  if(str_begin.hzfx==dir_right)
1791   2                      fun_zjzt(mot_sj,fun_min(par_high[4],par_high[5],par_high[6],par_high[7],def_end)-1);
1792   2                  else if(str_begin.hzfx==dir_left)
1793   2                      fun_zjzt(mot_sj,fun_min(par_high[0],par_high[1],par_high[2],par_high[3],par_high[4],par_hi
             -gh[5],par_high[6],par_high[7],def_end)-1);            
1794   2              }
1795   1              //平移回转到需要的地方
1796   1              fun_zjzt(mot_pyhz,par_now);
1797   1              //下降到工件的位置
1798   1              fun_zjzt(mot_sj,par_high[par_now]);
1799   1              //抓紧工件
1800   1              fun_sz1(han_j);
1801   1              //上升到正确的最高位
1802   1              switch(par_now){
1803   2                  case 0:
1804   2                      switch(par_next){
1805   3                          case 1:
1806   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1807   3                              break;
1808   3                          case 2:
1809   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[1],par_high[par_next
             -]-1,def_end)-1);
1810   3                              break;
1811   3                          case 3:
1812   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[1],par_high[2],par_h
             -igh[par_next]-1,def_end)-1);
1813   3                              break;
1814   3                          case 4:
1815   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[1],par_high[5],par_h
             -igh[par_next]-1,def_end)-1);
1816   3                              break;
1817   3                          case 5:
1818   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[1],par_high[par_next
             -]-1,def_end)-1);
1819   3                              break;
1820   3                          case 6:
1821   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[1],par_high[par_next
             -]-1,def_end)-1);
1822   3                              break;
1823   3                          case 7:
1824   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[1],par_high[6],par_h
             -igh[par_next]-1,def_end)-1);
1825   3                              break;
1826   3                          default:
1827   3                              break;
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 31  

1828   3                      }
1829   2                      break;
1830   2                  case 1:
1831   2                      switch(par_next){
1832   3                          case 0:
1833   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1834   3                              break;
1835   3                          case 2:
1836   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1837   3                              break;
1838   3                          case 3:
1839   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[2],par_high[par_next
             -]-1,def_end)-1);
1840   3                              break;
1841   3                          case 4:
1842   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[5],par_high[par_next
             -]-1,def_end)-1);
1843   3                              break;
1844   3                          case 5:
1845   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1846   3                              break;
1847   3                          case 6:
1848   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1849   3                              break;
1850   3                          case 7:
1851   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[6],par_high[par_next
             -]-1,def_end)-1);
1852   3                              break;
1853   3                          default:
1854   3                              break;
1855   3                      }
1856   2                      break;
1857   2                  case 2:
1858   2                      switch(par_next){
1859   3                          case 0:
1860   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[1],par_high[par_next
             -]-1,def_end)-1);
1861   3                              break;
1862   3                          case 1:
1863   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1864   3                              break;
1865   3                          case 3:
1866   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1867   3                              break;
1868   3                          case 4:
1869   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[5],par_high[par_next
             -]-1,def_end)-1);
1870   3                              break;
1871   3                          case 5:
1872   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1873   3                              break;
1874   3                          case 6:
1875   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1876   3                              break;
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 32  

1877   3                          case 7:
1878   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[6],par_high[par_next
             -]-1,def_end)-1);
1879   3                              break;
1880   3                          default:
1881   3                              break;
1882   3                      }
1883   2                      break;
1884   2                  case 3:
1885   2                      switch(par_next){
1886   3                          case 0:
1887   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[2],par_high[1],par_h
             -igh[par_next]-1,def_end)-1);
1888   3                              break;
1889   3                          case 1:
1890   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[2],par_high[par_next
             -]-1,def_end)-1);
1891   3                              break;
1892   3                          case 2:
1893   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1894   3                              break;
1895   3                          case 4:
1896   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[2],par_high[5],par_h
             -igh[par_next]-1,def_end)-1);
1897   3                              break;
1898   3                          case 5:
1899   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[2],par_high[par_next
             -]-1,def_end)-1);
1900   3                              break;
1901   3                          case 6:
1902   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[2],par_high[par_next
             -]-1,def_end)-1);
1903   3                              break;
1904   3                          case 7:
1905   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[2],par_high[6],par_h
             -igh[par_next]-1,def_end)-1);
1906   3                              break;
1907   3                          default:
1908   3                              break;
1909   3                      }
1910   2                      break;
1911   2                  case 4:
1912   2                      switch(par_next){
1913   3                          case 0:
1914   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[5],par_high[1],par_h
             -igh[par_next]-1,def_end)-1);
1915   3                              break;
1916   3                          case 1:
1917   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[5],par_high[par_next
             -]-1,def_end)-1);
1918   3                              break;
1919   3                          case 2:
1920   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[5],par_high[par_next
             -]-1,def_end)-1);
1921   3                              break;
1922   3                          case 3:
1923   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[5],par_high[2],par_h
             -igh[par_next]-1,def_end)-1);
1924   3                              break;
1925   3                          case 5:
1926   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 33  

             --1);
1927   3                              break;
1928   3                          case 6:
1929   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[5],par_high[par_next
             -]-1,def_end)-1);
1930   3                              break;
1931   3                          case 7:
1932   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[5],par_high[6],par_h
             -igh[par_next]-1,def_end)-1);
1933   3                              break;
1934   3                          default:
1935   3                              break;
1936   3                      }
1937   2                      break;
1938   2                  case 5:
1939   2                      switch(par_next){
1940   3                          case 0:
1941   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[1],par_high[par_next
             -]-1,def_end)-1);
1942   3                              break;
1943   3                          case 1:
1944   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1945   3                              break;
1946   3                          case 2:
1947   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1948   3                              break;
1949   3                          case 3:
1950   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[2],par_high[par_next
             -]-1,def_end)-1);
1951   3                              break;
1952   3                          case 4:
1953   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1954   3                              break;
1955   3                          case 6:
1956   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1957   3                              break;
1958   3                          case 7:
1959   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[6],par_high[par_next
             -]-1,def_end)-1);
1960   3                              break;
1961   3                          default:
1962   3                              break;
1963   3                      }
1964   2                      break;
1965   2                  case 6:
1966   2                      switch(par_next){
1967   3                          case 0:
1968   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[1],par_high[par_next
             -]-1,def_end)-1);
1969   3                              break;
1970   3                          case 1:
1971   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1972   3                              break;
1973   3                          case 2:
1974   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1975   3                              break;
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 34  

1976   3                          case 3:
1977   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[2],par_high[par_next
             -]-1,def_end)-1);
1978   3                              break;
1979   3                          case 4:
1980   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[5],par_high[par_next
             -]-1,def_end)-1);
1981   3                              break;
1982   3                          case 5:
1983   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1984   3                              break;
1985   3                          case 7:
1986   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
1987   3                              break;
1988   3                          default:
1989   3                              break;
1990   3                      }
1991   2                      break;
1992   2                  case 7:
1993   2                      switch(par_next){
1994   3                          case 0:
1995   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[6],par_high[1],par_h
             -igh[par_next]-1,def_end)-1);
1996   3                              break;
1997   3                          case 1:
1998   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[6],par_high[par_next
             -]-1,def_end)-1);
1999   3                              break;
2000   3                          case 2:
2001   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[6],par_high[par_next
             -]-1,def_end)-1);
2002   3                              break;
2003   3                          case 3:
2004   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[6],par_high[2],par_h
             -igh[par_next]-1,def_end)-1);
2005   3                              break;
2006   3                          case 4:
2007   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[5],par_high[6],par_h
             -igh[par_next]-1,def_end)-1);
2008   3                              break;
2009   3                          case 5:
2010   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[6],par_high[par_next
             -]-1,def_end)-1);
2011   3                              break;
2012   3                          case 6:
2013   3                              fun_zjzt(mot_sj,fun_min(loc_high+1,par_high[par_now],par_high[par_next]-1,def_end)
             --1);
2014   3                              break;
2015   3                          default:
2016   3                              break;
2017   3                      }
2018   2                      break;
2019   2                  default:
2020   2                      break;
2021   2              }
2022   1              //平移回转至放件处
2023   1              fun_zjzt(mot_pyhz,par_next);
2024   1              //下降到要放下的位置
2025   1              fun_zjzt(mot_sj,par_high[par_next]-1);
2026   1              //松开手抓
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 35  

2027   1              fun_sz1(han_s);
2028   1          #endif
2029   1      
2030   1          //更新参数
2031   1          par_data[par_next][par_high[par_next]-1]=par_data[par_now][par_high[par_now]];
2032   1          par_data[par_now][par_high[par_now]]=0;
2033   1          par_high[par_now]++;
2034   1          par_high[par_next]--;
2035   1      }//拿件(配合自动抓件使用)
2036          void fun_zhuajian(){
2037   1          fun_sz1(han_s);                 //手抓松
2038   1          fun_sj1(sjp_1);                 //上升到最高位
2039   1          fun_py1(tra_q);                 //平移到前端
2040   1          if(str_begin.hzfx!=dir_right)   //如果不在右边
2041   1              fun_hz1(dir_right);         //就平移到右边
2042   1      
2043   1          fun_folline(2,60);
2044   1          fun_turn(tur_l90,40);
2045   1          fun_folline(1,60);
2046   1          fun_qc(100,40);
2047   1          while(!in_ls1&&!in_ls2&&!in_ls3&&in_ls4&&in_ls5&&!in_ls6&&!in_ls7&&!in_ls8){
2048   2              if(in_ls3||!in_ls5){
2049   3                  fun_motors(mot_r,-30);
2050   3                  fun_motors(mot_l,-29);
2051   3                  fun_delay(500,del_ms);
2052   3                  fun_motors(mot_r,-29);
2053   3                  fun_motors(mot_l,-30);
2054   3                  fun_delay(500,del_ms);
2055   3                  fun_motors(mot_rl,-30);
2056   3                  fun_delay(500,del_ms);
2057   3              }//3亮或5不亮
2058   2              else if(in_ls6||!in_ls4){
2059   3                  fun_motors(mot_r,-30);
2060   3                  fun_motors(mot_l,-29);
2061   3                  fun_delay(500,del_ms);
2062   3                  fun_motors(mot_r,-29);
2063   3                  fun_motors(mot_l,-30);
2064   3                  fun_delay(500,del_ms);
2065   3                  fun_motors(mot_rl,-30);
2066   3                  fun_delay(500,del_ms);
2067   3              }//6亮或4不亮
2068   2              fun_qc(200,40);//重新进行前冲
2069   2          }
2070   1          fun_motors(mot_rl,0);
2071   1      }//从起始区走到抓件区
2072          void fun_back(){
2073   1          fun_motors(mot_rl,-30);
2074   1          fun_delay(1,del_s);
2075   1      
2076   1          fun_motors(mot_r,-50);
2077   1          fun_motors(mot_l,-20);
2078   1          fun_delay(3,del_s);    
2079   1      
2080   1          fun_motors(mot_rl,-35);
2081   1          fun_delay(1,del_s);
2082   1      }//从抓件区回到起始区
2083          void fun_start(char par_x,char par_y,enum varENU_dir par_ctfx,enum varENU_han par_szzt,enum varENU_sjp par
             -_sjwz,enum varENU_tra par_pywz,enum varENU_dir par_hzfx){
2084   1          CLK_DIV=0x00;             //不分频
2085   1          P0M1=0xff;                //P0用于输入
2086   1          P0M0=0x00;                //P0不能输出
2087   1          P1M1=0x00;                //P1口0-1双向
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 36  

2088   1          P1M0=0xfc;                //P1口2-7输出
2089   1          P2M1=0xf0;                //P2口4-7输入
2090   1          P2M0=0x0f;                //P2口0-3输出
2091   1      
2092   1          out_en1=1;                //电机1/3使能
2093   1          out_en2=1;                //电机2/4使能
2094   1          CR=0;                     //PAC计数器归零
2095   1          out_motorselect=0;        //电机片选为0
2096   1      
2097   1          #ifdef Debug              //如果是调试模式
                      fun_port();           //初始化串口
                      TI=1;                 //打开串口传输功能        
                  #endif
2101   1          fun_pwminit();            //PWM的初始化
2102   1          fun_timer0init();         //初始化定时器0
2103   1          fun_timer1init();         //初始化定时器1
2104   1      
2105   1          str_begin.x=par_x;        //X坐标
2106   1          str_begin.y=par_y;        //Y坐标
2107   1          str_begin.ctfx=par_ctfx;  //车头方向
2108   1          str_begin.szzt=par_szzt;  //手抓状态
2109   1          str_begin.sjwz=par_sjwz;  //升降位置
2110   1          str_begin.pywz=par_pywz;  //平移位置
2111   1          str_begin.hzfx=par_hzfx;  //回转方向
2112   1      
2113   1          str_tfl.gospeed=0;        //速度归零
2114   1          fun_motors(mot_sz,0);     //手抓速度归零
2115   1          fun_motors(mot_py,0);     //平移速度归零
2116   1          fun_motors(mot_sj,0);     //手抓速度归零
2117   1          fun_motors(mot_hz,0);     //手抓速度归零
2118   1          fun_motors(mot_rl,0);     //左右速度归零
2119   1      
2120   1          TR0=1;                    //打开定时器0
2121   1          TR1=1;                    //打开定时器1
2122   1          in_start=1;               //按键置1
2123   1          #ifdef Debug              //如果开启调试模式
                      fun_delay(5,del_s);
                      MSG("Ready!")         //输出Ready!
                  #else
2127   1              fun_wait();           //等待按键
2128   1          #endif
2129   1      }//初始化函数
2130          void fun_stop(){
2131   1          EA=0;                   //关总中断
2132   1          str_tfl.gospeed=0;      //速度归零
2133   1          fun_motors(mot_sz,0);   //手抓速度归零
2134   1          fun_motors(mot_py,0);   //平移速度归零
2135   1          fun_motors(mot_sj,0);   //手抓速度归零
2136   1          fun_motors(mot_hz,0);   //手抓速度归零
2137   1          fun_motors(mot_rl,0);   //左右速度归零
2138   1          MSG("End!")             //输出End!
2139   1          while(1);               //死循环
2140   1      }//结束函数


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  12353    ----
   CONSTANT SIZE    =      9    ----
   XDATA SIZE       =    150      90
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5      72
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.54   8023                                                                  09/29/2015 14:55:09 PAGE 37  

   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
