C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE 8023
OBJECT MODULE PLACED IN .\output\8023.obj
COMPILER INVOKED BY: H:\Program\keil\C51\BIN\C51.EXE program\8023.c DEBUG OBJECTEXTEND PRINT(.\8023.lst) OBJECT(.\output
                    -\8023.obj)

line level    source

   1          #include "./output/8023.h"
   2          xdata struct str_state str_begin,str_now,str_next;//分别为:起始状态/当前状态/目标状态
   3          xdata struct str_parameter str_cod={
   4              /*ui str_cod.mlinerqd*/25000,//默认主函数巡线软起动路程为25000
   5              /*ui str_cod.mlineqc*/200,//默认主函数巡线前冲时间为500毫秒
   6          
   7              /*ui str_cod.sj1bzw*/58,
   8              /*ui str_cod.sj1zjw*/800,
   9          
  10              /*ui str_cod.py1qkq*/666,
  11              /*ui str_cod.py1kqz*/684,
  12              /*ui str_cod.py1zkh*/684,
  13              /*ui str_cod.py1khh*/666,
  14              /*ui str_cod.py1qz*/500,
  15              /*ui str_cod.py1zh*/500,
  16              /*ui str_cod.py1kqkh*/1480,
  17              /*ui str_cod.py1qkh*/2122,
  18              /*ui str_cod.py1kqh*/2122,
  19          };
  20          ui var_timer0=0;
  21          void fun_delay(ui par_value,enum varENU_del par_model){
  22   1          ui loc_con=par_value;
  23   1          switch(par_model){
  24   2              case del_us://微秒级延时
  25   2                  while(loc_con-->0){
  26   3                      _nop_();
  27   3                      _nop_();
  28   3                  }
  29   2                  return;
  30   2              case del_ms://毫秒级延时
  31   2                  while(loc_con-->0){
  32   3                      uc loc_i, loc_j;
  33   3                      _nop_();
  34   3                      _nop_();
  35   3                      loc_i=12;
  36   3                      loc_j=168;
  37   3                      do{
  38   4                          while(--loc_j);
  39   4                      }while(--loc_i);
  40   3                  }
  41   2                  return;
  42   2              case del_s://秒级延时
  43   2                  while(loc_con-->0){
  44   3                      uc loc_i, loc_j, loc_k;
  45   3                      loc_i=46;
  46   3                      loc_j=153;
  47   3                      loc_k=245;
  48   3                      do{
  49   4                          do{
  50   5                              while(--loc_k);
  51   5                          }while(--loc_j);
  52   4                      }while(--loc_i);
  53   3                  }
  54   2                  return;
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 2   

  55   2              default:return;
  56   2          }
  57   1      }//延时
  58          void fun_timer0init(){
  59   1          AUXR|=0x80;       //定时器时钟1T模式
  60   1          TMOD&=0xF0;       //设置定时器模式
  61   1          TMOD|=0x01;       //设置定时器模式
  62   1          TL0=0x20;     //设置定时初值
  63   1          TH0=0xD1;     //设置定时初值
  64   1          TF0=0;        //清除TF0标志
  65   1          ET0=1;
  66   1          EA=1;
  67   1      }//1毫秒定时器0初始化
  68          void fun_timer1init(){
  69   1          AUXR&=0xBF;
  70   1          TMOD&=0x0F;
  71   1          TMOD|=0x10;
  72   1          TL1=0xE0;
  73   1          TH1=0xB1;
  74   1          TF1=0;
  75   1          ET1=1;
  76   1          EA=1;
  77   1      }//20毫秒定时器1初始化
  78          void fun_timer0(){
  79   1          TL0=0x20;
  80   1          TH0=0xD1;
  81   1          _nop_();
  82   1          var_timer0++;
  83   1      }//1毫秒定时器0处理函数
  84          void fun_timer1(){
  85   1          TL1=0xE0;
  86   1          TH1=0xB1;
  87   1          _nop_();
  88   1      }//20毫秒定时器1处理函数
  89          void fun_wait(){
  90   1          while(in_start==1);
  91   1          fun_delay(20,del_ms);
  92   1          while(in_start==0);
  93   1          fun_delay(256,del_ms);
  94   1      }//等待按键
  95          void fun_select(enum varENU_sel par_model){
  96   1          if(par_model==sel_58)
  97   1              out_switchselect=0;
  98   1          else if(par_model==sel_912)
  99   1              out_switchselect=1;
 100   1      }//传感器片选
 101          void fun_initialization(){
 102   1          CLK_DIV=0x00;//不分频
 103   1      
 104   1          P0M1=0xff;//P0用于输入
 105   1          P0M0=0x00;//P0不能输出
 106   1          
 107   1          P1M1=0x00;//P1口0-1双向，2中断输入，3-6输入，7输出
 108   1          P1M0=0xfc;//P1口2-7输出
 109   1      
 110   1          P2M1=0xf0;//P2口4-7输入
 111   1          P2M0=0x0f;//P2口0-3输出
 112   1      
 113   1          //PS_2=1;//手抓松传感器置1 $?$
 114   1          //PS_11=1;//升降位置3传感器置1 $?$
 115   1      
 116   1          out_en1=1;//电机1/3使能 $?$
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 3   

 117   1          out_en2=1;//电机2/4使能 $?$
 118   1          //out_motorselect=1;//电机片选为1 $?$
 119   1          //fun_delay(del_ms,1);//延时1毫秒 $?$
 120   1          out_motorselect=0;//电机片选为0 $?$
 121   1          //PS_5=PS_1;// $?$
 122   1      
 123   1          fun_pwminit();//PWM的初始化设置
 124   1          fun_timer0init();//初始化定时器0
 125   1          fun_timer1init();//初始化定时器1
 126   1          fun_port();//初始化串口
 127   1          in_start=1;//按键置1
 128   1      
 129   1          fun_wait();
 130   1      }//初始化
 131          void fun_pwminit(){
 132   1          CCON=0x00;
 133   1          CH=0;
 134   1          CL=0;
 135   1          CMOD=0x00;
 136   1      }//PWM初始化
 137          void fun_pwmr(uc par_value){
 138   1          CCAP0H=CCAP0L=par_value*2.5;//控制输出的占空比
 139   1          CCAPM0=0X42;//8位PWM输出，无中断
 140   1          PCA_PWM0=0x00;
 141   1      }//右路PWM输出
 142          void fun_pwml(uc par_value){
 143   1          CCAP1H=CCAP1L=par_value*2.5;//控制输出的占空比
 144   1          CCAPM1=0X42;//8位PWM输出，无中断
 145   1          PCA_PWM1=0x00;
 146   1      }//左路PWM输出
 147          void fun_startdj(enum varENU_mot par_model,char par_speed){
 148   1          if(par_speed==0)
 149   1              return;
 150   1          else if(par_speed>100)
 151   1              par_speed=100;
 152   1          else if(par_speed<-100)
 153   1              par_speed=-100;
 154   1          switch(par_model){
 155   2              case mot_l://左轮电机
 156   2                  CR=1;
 157   2                  if(par_speed>0){
 158   3                      fun_pwml(par_speed);out_pwml=0;
 159   3                  }
 160   2                  else if(par_speed<0){
 161   3                      fun_pwml(cabs(par_speed));out_pwml=1;
 162   3                  }
 163   2                  break;
 164   2              case mot_r://右轮电机
 165   2                  CR=1;
 166   2                  if(par_speed>0){
 167   3                      fun_pwmr(par_speed);out_pwmr=0;
 168   3                  }
 169   2                  else if(par_speed<0){
 170   3                      fun_pwmr(cabs(par_speed));out_pwmr=1;
 171   3                  }
 172   2                  break;
 173   2              case mot_rl://左右轮同步
 174   2                  CR=1;
 175   2                  if(par_speed>0){
 176   3                      fun_pwml(par_speed);out_pwml=0;
 177   3                      fun_pwmr(par_speed);out_pwmr=0;
 178   3                  }
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 4   

 179   2                  else if(par_speed<0){
 180   3                      fun_pwml(cabs(par_speed));out_pwml=1;
 181   3                      fun_pwmr(cabs(par_speed));out_pwmr=1;
 182   3                  }
 183   2                  break;
 184   2              case mot_dj1://正转为抓紧，反转为松开
 185   2                  out_motorselect=1;
 186   2                  if(par_speed>0)
 187   2                      out_dir1=1;
 188   2                  else if(par_speed<0)
 189   2                      out_dir1=0;
 190   2                  out_en1=0;
 191   2                  break;
 192   2              case mot_dj2://正转是向无电机一方转,反转为向有电机一方转
 193   2                  out_motorselect=1;
 194   2                  if(par_speed>0)
 195   2                      out_dir2=1;
 196   2                  else if(par_speed<0)
 197   2                      out_dir2=0;
 198   2                  out_en2=0;
 199   2                  break;
 200   2              case mot_dj3://向上为正转,向下为反转
 201   2                  out_motorselect=0;
 202   2                  if(par_speed>0)
 203   2                      out_dir1=0;
 204   2                  else if(par_speed<0)
 205   2                      out_dir1=1;
 206   2                  out_en1=0;
 207   2                  break;
 208   2              case mot_dj4://顺时针为正转,逆时针为反转
 209   2                  out_motorselect=0;
 210   2                  if(par_speed>0)
 211   2                      out_dir2=0;
 212   2                  else if(par_speed<0)
 213   2                      out_dir2=1;
 214   2                  out_en2=0;
 215   2                  break;
 216   2              default:
 217   2                  break;
 218   2          }
 219   1      }//启动电机
 220          void fun_stop(enum varENU_mot par_model){
 221   1          switch(par_model){
 222   2              case mot_l:
 223   2                  fun_pwml(0);out_pwml=0;break;
 224   2              case mot_r:
 225   2                  fun_pwmr(0);out_pwmr=0;break;
 226   2              case mot_rl:
 227   2                  CR=0;
 228   2                  fun_pwmr(0);out_pwmr=0;
 229   2                  fun_pwml(0);out_pwml=0;
 230   2                  break;
 231   2              case mot_dj1:
 232   2                  out_motorselect=1;out_dir1=0;out_en1=1;break;
 233   2              case mot_dj2:
 234   2                  out_motorselect=1;out_dir2=0;out_en2=1;break;
 235   2              case mot_dj3:
 236   2                  out_motorselect=0;out_dir1=0;out_en1=1;break;
 237   2              case mot_dj4:
 238   2                  out_motorselect=0;out_dir2=0;out_en2=1;break;
 239   2              default:
 240   2                  break;
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 5   

 241   2          }
 242   1      }//停止电机
 243          void fun_sz1(enum varENU_han par_model){
 244   1          if(str_begin.szzt==par_model)
 245   1              return;
 246   1          if(par_model==han_s){//手抓松
 247   2              while(1){
 248   3                  fun_startdj(mot_dj1,-100);
 249   3                  while(in_s==1);
 250   3                  fun_delay(20,del_ms);
 251   3                  if(in_s==0)
 252   3                      break;
 253   3              }
 254   2          }
 255   1          else{//手抓紧
 256   2              while(1){
 257   3                  fun_startdj(mot_dj1,100);
 258   3                  while(in_j==1);
 259   3                  fun_delay(20,del_ms);
 260   3                  if(in_j==0)
 261   3                      break;
 262   3              }
 263   2          }
 264   1          fun_stop(mot_dj1);
 265   1          str_begin.szzt=par_model;//存储运行结果
 266   1      }//手抓单步运动
 267          void fun_sj1(enum varENU_sjp par_model){
 268   1          if(par_model==str_begin.sjwz)
 269   1             return;
 270   1          switch(par_model){
 271   2              case sjp_wz1://升降位置1(最上位)
 272   2                  fun_startdj(mot_dj3,100);
 273   2                  fun_select(sel_58);
 274   2                  fun_delay(50,del_ms);
 275   2                  while(1){//只有向上
 276   3                      while(in_wz1==1);
 277   3                      fun_delay(20,del_ms);
 278   3                      if(in_wz1==0){
 279   4                          fun_delay(20,del_ms);
 280   4                          break;                    
 281   4                      }
 282   3                  }
 283   2                  break;
 284   2              case sjp_wz12:
 285   2                  if(par_model>str_begin.sjwz){
 286   3                      fun_startdj(mot_dj3,-100);
 287   3                      fun_delay(str_cod.sj1zjw,del_ms);
 288   3                  }
 289   2                  else{//要去的地方在上面，向上走
 290   3                      fun_sj1(sjp_wz2);
 291   3                      fun_startdj(mot_dj3,100);
 292   3                      fun_delay(str_cod.sj1zjw,del_ms);
 293   3                  }
 294   2                  break;
 295   2              case sjp_wz2://升降位置2
 296   2                  if(par_model>str_begin.sjwz)
 297   2                      fun_startdj(mot_dj3,-100);
 298   2                  else
 299   2                      fun_startdj(mot_dj3,100);
 300   2                  fun_select(sel_58);
 301   2                  fun_delay(50,del_ms);
 302   2                  while(1){//要去的地方比较靠下,向下走                    
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 6   

 303   3                      while(in_wz2==1);
 304   3                      fun_delay(20,del_ms);
 305   3                      if(in_wz2==0){
 306   4                          fun_delay(str_cod.sj1bzw,del_ms);
 307   4                          break;
 308   4                      }
 309   3                  }
 310   2                  break;
 311   2              case sjp_wz23:
 312   2                  if(par_model>str_begin.sjwz){
 313   3                      fun_sj1(sjp_wz2);
 314   3                      fun_startdj(mot_dj3,-100);
 315   3                      fun_delay(str_cod.sj1zjw,del_ms);
 316   3                  }
 317   2                  else{//要去的地方在上面，向上走
 318   3                      fun_sj1(sjp_wz3);
 319   3                      fun_startdj(mot_dj3,100);
 320   3                      fun_delay(str_cod.sj1zjw,del_ms);
 321   3                  }
 322   2                  break;
 323   2              case sjp_wz3://升降位置3
 324   2                  if(par_model>str_begin.sjwz)
 325   2                      fun_startdj(mot_dj3,-100);
 326   2                  else
 327   2                      fun_startdj(mot_dj3,100);
 328   2                  fun_select(sel_58);
 329   2                  fun_delay(50,del_ms);
 330   2                  while(1){
 331   3                      while(in_wz3==1);
 332   3                      fun_delay(str_cod.sj1bzw,del_ms);
 333   3                      if(in_wz3==0)
 334   3                          break;
 335   3                  }
 336   2                  break;
 337   2              case sjp_wz34:
 338   2                  if(par_model>str_begin.sjwz){
 339   3                      fun_sj1(sjp_wz3);
 340   3                      fun_startdj(mot_dj3,-100);
 341   3                      fun_delay(str_cod.sj1zjw,del_ms);
 342   3                  }
 343   2                  else{//要去的地方在上面，向上走
 344   3                      fun_sj1(sjp_wz4);
 345   3                      fun_startdj(mot_dj3,100);
 346   3                      fun_delay(str_cod.sj1zjw,del_ms);
 347   3                  }
 348   2                  break;
 349   2              case sjp_wz4://升降位置4
 350   2                  if(par_model>str_begin.sjwz)
 351   2                      fun_startdj(mot_dj3,-100);
 352   2                  else
 353   2                      fun_startdj(mot_dj3,100);
 354   2                  fun_select(sel_58);
 355   2                  fun_delay(50,del_ms);
 356   2                  while(1){
 357   3                      while(in_wz4==1);
 358   3                      fun_delay(str_cod.sj1bzw,del_ms);
 359   3                      if(in_wz4==0)
 360   3                          break;
 361   3                  }
 362   2                  break;
 363   2              case sjp_wz45:
 364   2                  if(par_model>str_begin.sjwz){
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 7   

 365   3                      fun_sj1(sjp_wz4);
 366   3                      fun_startdj(mot_dj3,-100);
 367   3                      fun_delay(str_cod.sj1zjw,del_ms);
 368   3                  }
 369   2                  else{//要去的地方在上面，向上走
 370   3                      fun_startdj(mot_dj3,100);
 371   3                      fun_delay(str_cod.sj1zjw,del_ms);
 372   3                  }
 373   2                  break;
 374   2              case sjp_wz5://升降位置5
 375   2                  fun_startdj(mot_dj3,-100);
 376   2                  fun_select(sel_912);
 377   2                  fun_delay(50,del_ms);
 378   2                  while(1){//要去的地方比较靠下,向下走                
 379   3                      while(in_wz5==1);
 380   3                      fun_delay(20,del_ms);
 381   3                      if(in_wz5==0){
 382   4                          fun_delay(str_cod.sj1bzw,del_ms);
 383   4                          break;
 384   4                      }
 385   3                  }
 386   2                  break;
 387   2              default:
 388   2                  break;
 389   2          }
 390   1          fun_stop(mot_dj3);
 391   1          str_begin.sjwz=par_model;//存储运行结果
 392   1      }//升降单步运动
 393          void fun_py1(enum varENU_tra par_model){
 394   1          if(str_begin.pywz==par_model)
 395   1              return;
 396   1          switch(par_model){
 397   2              case tra_q://前平移(没有电机的呢个方向)
 398   2                  while(1){
 399   3                      fun_startdj(mot_dj2,100);
 400   3                      while(in_qpy==1);
 401   3                      fun_delay(20,del_ms);
 402   3                      if(in_qpy==0){
 403   4                          fun_delay(20,del_ms);
 404   4                          break;
 405   4                      }
 406   3                  }
 407   2                  break;
 408   2              case tra_kq:
 409   2                  switch(str_begin.pywz){
 410   3                      case tra_q:
 411   3                          fun_startdj(mot_dj2,-100);
 412   3                          fun_delay(str_cod.py1qkq,del_ms);
 413   3                          break;
 414   3                      case tra_z:
 415   3                          fun_startdj(mot_dj2,100);
 416   3                          fun_delay(str_cod.py1kqz,del_ms);
 417   3                          break;
 418   3                      case tra_kh:
 419   3                          fun_startdj(mot_dj2,100);
 420   3                          fun_delay(str_cod.py1kqkh,del_ms);
 421   3                          break;
 422   3                      case tra_h:
 423   3                          fun_startdj(mot_dj2,100);
 424   3                          fun_delay(str_cod.py1kqh,del_ms);
 425   3                          break;
 426   3                  }
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 8   

 427   2                  break;
 428   2              case tra_z:
 429   2                  switch(str_begin.pywz){
 430   3                      case tra_q:
 431   3                          fun_startdj(mot_dj2,-100);
 432   3                          fun_delay(str_cod.py1qz,del_ms);
 433   3                          break;
 434   3                      case tra_kq:
 435   3                          fun_startdj(mot_dj2,-100);
 436   3                          fun_delay(str_cod.py1kqz,del_ms);
 437   3                          break;
 438   3                      case tra_kh:
 439   3                          fun_startdj(mot_dj2,100);
 440   3                          fun_delay(str_cod.py1zkh,del_ms);
 441   3                          break;
 442   3                      case tra_h:
 443   3                          fun_startdj(mot_dj2,100);
 444   3                          fun_delay(str_cod.py1zh,del_ms);
 445   3                          break;
 446   3                  }
 447   2                  break;
 448   2              case tra_kh:
 449   2                  switch(str_begin.pywz){
 450   3                      case tra_q:
 451   3                          fun_startdj(mot_dj2,-100);
 452   3                          fun_delay(str_cod.py1qkh,del_ms);
 453   3                          break;
 454   3                      case tra_kq:
 455   3                          fun_startdj(mot_dj2,-100);
 456   3                          fun_delay(str_cod.py1kqkh,del_ms);
 457   3                          break;
 458   3                      case tra_z:
 459   3                          fun_startdj(mot_dj2,-100);
 460   3                          fun_delay(str_cod.py1zkh,del_ms);
 461   3                          break;
 462   3                      case tra_h:
 463   3                          fun_startdj(mot_dj2,100);
 464   3                          fun_delay(str_cod.py1khh,del_ms);
 465   3                          break;
 466   3                  }
 467   2                  break;
 468   2              case tra_h://后平移(有电机的呢个方向)
 469   2                  while(1){
 470   3                      fun_startdj(mot_dj2,-100);
 471   3                      while(in_hpy==1);
 472   3                      fun_delay(20,del_ms);
 473   3                      if(in_hpy==0){
 474   4                          fun_delay(20,del_ms);
 475   4                          break;
 476   4                      }
 477   3                  }
 478   2                  break;
 479   2              default:
 480   2                  break;
 481   2          }
 482   1          fun_stop(mot_dj2);
 483   1          str_begin.pywz=par_model;//存储运行结果
 484   1      }//平移单步运动
 485          void fun_hz1(enum varENU_dir par_model){
 486   1          fun_select(sel_912);
 487   1          switch(par_model){
 488   2              case dir_up://回转至前方
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 9   

 489   2                  switch(str_begin.hzfx){
 490   3                      case dir_down://现在在下方
 491   3                          fun_startdj(mot_dj4,-100);
 492   3                          fun_delay(1,del_s);
 493   3                          while(1){
 494   4                              while(in_hz==1);
 495   4                              fun_delay(25,del_ms);
 496   4                              if(in_hz==0)
 497   4                                  break;
 498   4                          }
 499   3                          while(1){
 500   4                              while(in_hz==0);
 501   4                              fun_delay(25,del_ms);
 502   4                              if(in_hz==1)
 503   4                                  break;
 504   4                          }
 505   3                          while(1){
 506   4                              while(in_hz==1);
 507   4                              fun_delay(25,del_ms);
 508   4                              if(in_hz==0)
 509   4                                  break;
 510   4                          }
 511   3                          break;
 512   3                      case dir_left://现在在左边
 513   3                          fun_startdj(mot_dj4,100);
 514   3                          fun_delay(1,del_s);
 515   3                          while(1){
 516   4                              while(in_hz==1);
 517   4                              fun_delay(25,del_ms);
 518   4                              if(in_hz==0)
 519   4                                  break;
 520   4                          }
 521   3                          break;
 522   3                      case dir_right://现在在右边
 523   3                          fun_startdj(mot_dj4,-100);
 524   3                          fun_delay(1,del_s);
 525   3                          while(1){
 526   4                              while(in_hz==1);
 527   4                              fun_delay(25,del_ms);
 528   4                              if(in_hz==0)
 529   4                                  break;
 530   4                          }
 531   3                          break;
 532   3                      default:
 533   3                          break;
 534   3                  }
 535   2                  break;
 536   2              case dir_down://要去下面
 537   2                  switch(str_begin.hzfx){
 538   3                      case dir_up://现在在上面
 539   3                          fun_startdj(mot_dj4,100);
 540   3                          fun_delay(1,del_s);
 541   3                          while(1){
 542   4                              while(in_hz==1);
 543   4                              fun_delay(25,del_ms);
 544   4                              if(in_hz==0)
 545   4                                  break;
 546   4                          }
 547   3                          while(1){
 548   4                              while(in_hz==0);
 549   4                              fun_delay(25,del_ms);
 550   4                              if(in_hz==1)
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 10  

 551   4                                  break;
 552   4                          }
 553   3                          while(1){
 554   4                              while(in_hz==1);
 555   4                              fun_delay(25,del_ms);
 556   4                              if(in_hz==0)
 557   4                                  break;
 558   4                          }
 559   3                          break;
 560   3                      case dir_left://现在在左面
 561   3                          fun_startdj(mot_dj4,-100);
 562   3                          fun_delay(1,del_s);
 563   3                          while(1){
 564   4                              while(in_hz==1);
 565   4                              fun_delay(25,del_ms);
 566   4                              if(in_hz==0)
 567   4                                  break;
 568   4                          }
 569   3                          break;
 570   3                      case dir_right://现在在右面
 571   3                          fun_startdj(mot_dj4,100);
 572   3                          fun_delay(1,del_s);
 573   3                          while(1){
 574   4                              while(in_hz==1);
 575   4                              fun_delay(25,del_ms);
 576   4                              if(in_hz==0)
 577   4                                  break;
 578   4                          }
 579   3                          break;
 580   3                      default:
 581   3                          break;
 582   3                  }
 583   2                  break;
 584   2              case dir_left://要去左边
 585   2                  switch(str_begin.hzfx){
 586   3                      case dir_up://现在在上面
 587   3                          fun_startdj(mot_dj4,-100);
 588   3                          fun_delay(1,del_s);
 589   3                          while(1){
 590   4                              while(in_hz==1);
 591   4                              fun_delay(25,del_ms);
 592   4                              if(in_hz==0)
 593   4                                  break;
 594   4                          }
 595   3                          break;
 596   3                      case dir_down://现在在下面
 597   3                          fun_startdj(mot_dj4,100);
 598   3                          fun_delay(1,del_s);
 599   3                          while(1){
 600   4                              while(in_hz==1);
 601   4                              fun_delay(25,del_ms);
 602   4                              if(in_hz==0)
 603   4                                  break;
 604   4                          }
 605   3                          break;
 606   3                      case dir_right://现在在右面
 607   3                          fun_startdj(mot_dj4,-100);
 608   3                          fun_delay(1,del_s);
 609   3                          while(1){
 610   4                              while(in_hz==1);
 611   4                              fun_delay(25,del_ms);
 612   4                              if(in_hz==0)
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 11  

 613   4                                  break;
 614   4                          }
 615   3                          while(1){
 616   4                              while(in_hz==0);
 617   4                              fun_delay(25,del_ms);
 618   4                              if(in_hz==1)
 619   4                                  break;
 620   4                          }
 621   3                          while(1){
 622   4                              while(in_hz==1);
 623   4                              fun_delay(25,del_ms);
 624   4                              if(in_hz==0){
 625   5                                  break;
 626   5                              }
 627   4                          }
 628   3                          break;
 629   3                      default:
 630   3                          break;
 631   3                  }
 632   2                  break;
 633   2              case dir_right://要去右面
 634   2                  switch(str_begin.hzfx){
 635   3                      case dir_up://现在在前面
 636   3                          fun_startdj(mot_dj4,100);
 637   3                          fun_delay(1,del_s);
 638   3                          while(1){
 639   4                              while(in_hz==1);
 640   4                              fun_delay(25,del_ms);
 641   4                              if(in_hz==0)
 642   4                                  break;
 643   4                          }
 644   3                          break;
 645   3                      case dir_down://现在在下面
 646   3                          fun_startdj(mot_dj4,-100);
 647   3                          fun_delay(1,del_s);
 648   3                          while(1){
 649   4                              while(in_hz==1);
 650   4                              fun_delay(25,del_ms);
 651   4                              if(in_hz==0)
 652   4                                  break;
 653   4                          }
 654   3                          break;
 655   3                      case dir_left://现在在左面
 656   3                          fun_startdj(mot_dj4,100);
 657   3                          fun_delay(1,del_s);
 658   3                          while(1){
 659   4                              while(in_hz==1);
 660   4                              fun_delay(25,del_ms);
 661   4                              if(in_hz==0)
 662   4                                  break;
 663   4                          }
 664   3                          while(1){
 665   4                              while(in_hz==0);
 666   4                              fun_delay(25,del_ms);
 667   4                              if(in_hz==1)
 668   4                                  break;
 669   4                          }
 670   3                          while(1){
 671   4                              while(in_hz==1);
 672   4                              fun_delay(25,del_ms);
 673   4                              if(in_hz==0){
 674   5                                  break;
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 12  

 675   5                              }
 676   4                          }
 677   3                          break;
 678   3                      default:
 679   3                          break;
 680   3                  }
 681   2                  break;
 682   2              default:
 683   2                  break;
 684   2          }
 685   1          fun_stop(mot_dj4);
 686   1          str_begin.hzfx=par_model;//存储运行结果
 687   1      }//回转单步运动
 688          void fun_sj2(char par_value){
 689   1          switch(par_value){
 690   2              case 1:
 691   2                  fun_sj1(sjp_wz2);
 692   2                  break;
 693   2              case 2:
 694   2                  fun_sj1(sjp_wz3);
 695   2                  break;
 696   2              case 3:
 697   2                  fun_sj1(sjp_wz4);
 698   2                  break;
 699   2              case 4:
 700   2                  fun_sj1(sjp_wz5);
 701   2                  break;
 702   2              default:
 703   2                  fun_sj1(sjp_wz1);
 704   2                  break;
 705   2          }
 706   1      }//状态的升降单步,用来配合自动抓件
 707          void fun_pyhz2(enum varENU_tra par_py,enum varENU_dir par_hz){
 708   1          if(str_begin.hzfx!=par_hz){
 709   2              fun_py1(tra_z);
 710   2              switch(par_hz){//启动回转,在位则不启动
 711   3                  case dir_up://回转至前方
 712   3                      switch(str_begin.hzfx){
 713   4                          case dir_down://现在在下方
 714   4                              fun_startdj(mot_dj4,-100);
 715   4                              break;
 716   4                          case dir_left://现在在左边
 717   4                              fun_startdj(mot_dj4,100);
 718   4                              break;
 719   4                          case dir_right://现在在右边
 720   4                              fun_startdj(mot_dj4,-100);
 721   4                              break;
 722   4                          default:
 723   4                              break;
 724   4                      }
 725   3                      break;
 726   3                  case dir_down://要去下面
 727   3                      switch(str_begin.hzfx){
 728   4                          case dir_up://现在在上面
 729   4                              fun_startdj(mot_dj4,100);
 730   4                              break;
 731   4                          case dir_left://现在在左面
 732   4                              fun_startdj(mot_dj4,-100);
 733   4                              break;
 734   4                          case dir_right://现在在右面
 735   4                              fun_startdj(mot_dj4,100);
 736   4                              break;
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 13  

 737   4                          default:
 738   4                              break;
 739   4                      }
 740   3                      break;
 741   3                  case dir_left://要去左边
 742   3                      switch(str_begin.hzfx){
 743   4                          case dir_up://现在在上面
 744   4                              fun_startdj(mot_dj4,-100);
 745   4                              break;
 746   4                          case dir_down://现在在下面
 747   4                              fun_startdj(mot_dj4,100);
 748   4                              break;
 749   4                          case dir_right://现在在右面
 750   4                              fun_startdj(mot_dj4,-100);
 751   4                              break;
 752   4                          default:
 753   4                              break;
 754   4                      }
 755   3                      break;
 756   3                  case dir_right://要去右面
 757   3                      switch(str_begin.hzfx){
 758   4                          case dir_up://现在在前面
 759   4                              fun_startdj(mot_dj4,100);
 760   4                              break;
 761   4                          case dir_down://现在在下面
 762   4                              fun_startdj(mot_dj4,-100);
 763   4                              break;
 764   4                          case dir_left://现在在左面
 765   4                              fun_startdj(mot_dj4,100);
 766   4                              break;
 767   4                          default:
 768   4                              break;
 769   4                      }
 770   3                      break;
 771   3                  default:
 772   3                      break;
 773   3              }
 774   2              switch(par_py){
 775   3                  case tra_q://前平移(没有电机的呢个方向)
 776   3                      while(1){
 777   4                          fun_startdj(mot_dj2,100);
 778   4                          while(in_qpy==1);
 779   4                          fun_delay(20,del_ms);
 780   4                          if(in_qpy==0){
 781   5                              fun_delay(20,del_ms);
 782   5                              break;
 783   5                          }
 784   4                      }
 785   3                      break;
 786   3                  case tra_kq:
 787   3                      fun_startdj(mot_dj2,100);
 788   3                      fun_delay(str_cod.py1kqz,del_ms);
 789   3                      break;
 790   3                  case tra_kh:
 791   3                      fun_startdj(mot_dj2,-100);
 792   3                      fun_delay(str_cod.py1zkh,del_ms);
 793   3                      break;
 794   3                  case tra_h://后平移(有电机的呢个方向)
 795   3                      while(1){
 796   4                          fun_startdj(mot_dj2,-100);
 797   4                          while(in_hpy==1);
 798   4                          fun_delay(20,del_ms);
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 14  

 799   4                          if(in_hpy==0){
 800   5                              fun_delay(20,del_ms);
 801   5                              break;
 802   5                          }
 803   4                      }
 804   3                      break;
 805   3                  default:
 806   3                      break;
 807   3              }
 808   2              fun_stop(mot_dj2);
 809   2              str_begin.pywz=par_py;//存储平移位置
 810   2      
 811   2              fun_select(sel_912);
 812   2              switch(par_hz){
 813   3                  case dir_up://回转至前方
 814   3                      switch(str_begin.hzfx){
 815   4                          case dir_down://现在在下方
 816   4                              while(1){
 817   5                                  while(in_hz==1);
 818   5                                  fun_delay(25,del_ms);
 819   5                                  if(in_hz==0)
 820   5                                      break;
 821   5                              }
 822   4                              while(1){
 823   5                                  while(in_hz==0);
 824   5                                  fun_delay(1,del_s);
 825   5                                  if(in_hz==1)
 826   5                                      break;
 827   5                              }
 828   4                              while(1){
 829   5                                  while(in_hz==1);
 830   5                                  fun_delay(25,del_ms);
 831   5                                  if(in_hz==0)
 832   5                                      break;
 833   5                              }
 834   4                              break;
 835   4                          case dir_left://现在在左边
 836   4                              while(1){
 837   5                                  while(in_hz==1);
 838   5                                  fun_delay(25,del_ms);
 839   5                                  if(in_hz==0)
 840   5                                      break;
 841   5                              }
 842   4                              break;
 843   4                          case dir_right://现在在右边
 844   4                              while(1){
 845   5                                  while(in_hz==1);
 846   5                                  fun_delay(25,del_ms);
 847   5                                  if(in_hz==0)
 848   5                                      break;
 849   5                              }
 850   4                              break;
 851   4                          default:
 852   4                              break;
 853   4                      }
 854   3                      break;
 855   3                  case dir_down://要去下面
 856   3                      switch(str_begin.hzfx){
 857   4                          case dir_up://现在在上面
 858   4                              while(1){
 859   5                                  while(in_hz==1);
 860   5                                  fun_delay(25,del_ms);
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 15  

 861   5                                  if(in_hz==0)
 862   5                                      break;
 863   5                              }
 864   4                              while(1){
 865   5                                  while(in_hz==0);
 866   5                                  fun_delay(1,del_s);
 867   5                                  if(in_hz==1)
 868   5                                      break;
 869   5                              }
 870   4                              while(1){
 871   5                                  while(in_hz==1);
 872   5                                  fun_delay(25,del_ms);
 873   5                                  if(in_hz==0)
 874   5                                      break;
 875   5                              }
 876   4                              break;
 877   4                          case dir_left://现在在左面
 878   4                              while(1){
 879   5                                  while(in_hz==1);
 880   5                                  fun_delay(25,del_ms);
 881   5                                  if(in_hz==0)
 882   5                                      break;
 883   5                              }
 884   4                              break;
 885   4                          case dir_right://现在在右面
 886   4                              while(1){
 887   5                                  while(in_hz==1);
 888   5                                  fun_delay(25,del_ms);
 889   5                                  if(in_hz==0)
 890   5                                      break;
 891   5                              }
 892   4                              break;
 893   4                          default:
 894   4                              break;
 895   4                      }
 896   3                      break;
 897   3                  case dir_left://要去左边
 898   3                      switch(str_begin.hzfx){
 899   4                          case dir_up://现在在上面
 900   4                              while(1){
 901   5                                  while(in_hz==1);
 902   5                                  fun_delay(25,del_ms);
 903   5                                  if(in_hz==0)
 904   5                                      break;
 905   5                              }
 906   4                              break;
 907   4                          case dir_down://现在在下面
 908   4                              while(1){
 909   5                                  while(in_hz==1);
 910   5                                  fun_delay(25,del_ms);
 911   5                                  if(in_hz==0)
 912   5                                      break;
 913   5                              }
 914   4                              break;
 915   4                          case dir_right://现在在右面
 916   4                              while(1){
 917   5                                  while(in_hz==1);
 918   5                                  fun_delay(25,del_ms);
 919   5                                  if(in_hz==0)
 920   5                                      break;
 921   5                              }
 922   4                              while(1){
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 16  

 923   5                                  while(in_hz==0);
 924   5                                  fun_delay(1,del_s);
 925   5                                  if(in_hz==1)
 926   5                                      break;
 927   5                              }
 928   4                              while(1){
 929   5                                  while(in_hz==1);
 930   5                                  fun_delay(25,del_ms);
 931   5                                  if(in_hz==0){
 932   6                                      break;
 933   6                                  }
 934   5                              }
 935   4                              break;
 936   4                          default:
 937   4                              break;
 938   4                      }
 939   3                      break;
 940   3                  case dir_right://要去右面
 941   3                      switch(str_begin.hzfx){
 942   4                          case dir_up://现在在前面
 943   4                              while(1){
 944   5                                  while(in_hz==1);
 945   5                                  fun_delay(25,del_ms);
 946   5                                  if(in_hz==0)
 947   5                                      break;
 948   5                              }
 949   4                              break;
 950   4                          case dir_down://现在在下面
 951   4                              while(1){
 952   5                                  while(in_hz==1);
 953   5                                  fun_delay(25,del_ms);
 954   5                                  if(in_hz==0)
 955   5                                      break;
 956   5                              }
 957   4                              break;
 958   4                          case dir_left://现在在左面
 959   4                              while(1){
 960   5                                  while(in_hz==1);
 961   5                                  fun_delay(25,del_ms);
 962   5                                  if(in_hz==0)
 963   5                                      break;
 964   5                              }
 965   4                              while(1){
 966   5                                  while(in_hz==0);
 967   5                                  fun_delay(1,del_s);
 968   5                                  if(in_hz==1)
 969   5                                      break;
 970   5                              }
 971   4                              while(1){
 972   5                                  while(in_hz==1);
 973   5                                  fun_delay(25,del_ms);
 974   5                                  if(in_hz==0){
 975   6                                      break;
 976   6                                  }
 977   5                              }
 978   4                              break;
 979   4                          default:
 980   4                              break;
 981   4                      }
 982   3                      break;
 983   3                  default:
 984   3                      break;
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 17  

 985   3              }
 986   2              fun_stop(mot_dj4);
 987   2              str_begin.hzfx=par_hz;//存储回转位置
 988   2          }
 989   1          else
 990   1              fun_py1(par_py);
 991   1      }//回转单步运动,用来配合自动抓件
 992          void fun_planezt(uc par_model){
 993   1          switch(par_model){
 994   2              case 0:
 995   2                  fun_pyhz2(tra_h,dir_left);
 996   2                  break;
 997   2              case 1:
 998   2                  fun_pyhz2(tra_kh,dir_left);
 999   2                  break;
1000   2              case 2:
1001   2                  fun_pyhz2(tra_kq,dir_left);
1002   2                  break;
1003   2              case 3:
1004   2                  fun_pyhz2(tra_q,dir_left);
1005   2                  break;
1006   2              case 4:
1007   2                  fun_pyhz2(tra_q,dir_right);
1008   2                  break;
1009   2              case 5:
1010   2                  fun_pyhz2(tra_kq,dir_right);
1011   2                  break;
1012   2              case 6:
1013   2                  fun_pyhz2(tra_kh,dir_right);
1014   2                  break;
1015   2              case 7:
1016   2                  fun_pyhz2(tra_h,dir_right);
1017   2                  break;
1018   2          }
1019   1      }//水平面位置状态,用来配合自动抓件
1020          void fun_mptline(uc par_num,uc par_sd,enum varENU_dir par_model){
1021   1          bit loc_flag=0;
1022   1          ui loc_xh=str_cod.mlinerqd/(0.5*(par_sd*par_sd+par_sd));
1023   1          uc loc_con;
1024   1          uc loc_l=par_sd,loc_r=par_sd;
1025   1          for(loc_con=1;loc_con<par_sd;fun_delay(loc_xh,del_ms)){//确定路程的软启动程序
1026   2              loc_r=loc_l=loc_con++;//恢复默认参数
1027   2              if(in_ls3){//纠偏
1028   3                  loc_l*=0.9;
1029   3                  loc_r*=1.1;
1030   3              }
1031   2              if(in_ls6){
1032   3                  loc_l*=1.1;
1033   3                  loc_r*=0.9;
1034   3              }  
1035   2              if(in_ls2){
1036   3                  loc_l*=0.8;
1037   3                  loc_r*=1.2;
1038   3              }
1039   2              if(in_ls7){
1040   3                  loc_l*=1.2;
1041   3                  loc_r*=0.8;
1042   3              }
1043   2              if(in_ls1){
1044   3                  loc_l*=0.7;
1045   3                  loc_r*=1.3;
1046   3              }
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 18  

1047   2              if(in_ls8){
1048   3                  loc_l*=1.3;
1049   3                  loc_r*=0.7;
1050   3              }
1051   2              fun_startdj(mot_r,loc_r);
1052   2              fun_startdj(mot_l,loc_l);
1053   2          }
1054   1          loc_con=0;
1055   1          while(1){
1056   2              if(((in_ls1)&&(in_ls7))||((in_ls2)&&(in_ls8)))
1057   2                  loc_flag=1;
1058   2              else if(loc_flag==1){
1059   3                  loc_con++;
1060   3                  loc_flag=0;
1061   3                  if(loc_con>=par_num){
1062   4                      if(par_model!=dir_up){
1063   5                          if(par_model==dir_left){//左转
1064   6                              fun_startdj(mot_r,par_sd);
1065   6                              fun_startdj(mot_l,-10);
1066   6                              fun_delay(500,del_ms);
1067   6                              while(1){
1068   7                                  while(!in_ls4||!in_ls5);
1069   7                                  fun_delay(100,del_us);
1070   7                                  if(in_ls4&&in_ls5){
1071   8                                      fun_stop(mot_rl);
1072   8                                      return;
1073   8                                  }
1074   7                              }
1075   6                          }
1076   5                          else if(par_model==dir_right){
1077   6                              fun_startdj(mot_l,par_sd);
1078   6                              fun_startdj(mot_r,-10);
1079   6                              fun_delay(500,del_ms);
1080   6                              while(1){
1081   7                                  while(!in_ls4||!in_ls5);
1082   7                                  fun_delay(100,del_us);
1083   7                                  if(in_ls4&&in_ls5){
1084   8                                      fun_stop(mot_rl);
1085   8                                      return;
1086   8                                  }
1087   7                              }
1088   6                          }
1089   5                      }
1090   4                      else{
1091   5                          for(loc_con=par_sd;loc_con>0;fun_delay(loc_xh,del_ms)){//确定路程的软启动程
             -
1092   6                              loc_r=loc_l=loc_con--;//恢复默认参数
1093   6                              if(in_ls3){//纠偏
1094   7                                  loc_l*=0.9;
1095   7                                  loc_r*=1.1;
1096   7                              }
1097   6                              if(in_ls6){
1098   7                                  loc_l*=1.1;
1099   7                                  loc_r*=0.9;
1100   7                              }  
1101   6                              if(in_ls2){
1102   7                                  loc_l*=0.8;
1103   7                                  loc_r*=1.2;
1104   7                              }
1105   6                              if(in_ls7){
1106   7                                  loc_l*=1.2;
1107   7                                  loc_r*=0.8;
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 19  

1108   7                              }
1109   6                              if(in_ls1){
1110   7                                  loc_l*=0.7;
1111   7                                  loc_r*=1.3;
1112   7                              }
1113   6                              if(in_ls8){
1114   7                                  loc_l*=1.3;
1115   7                                  loc_r*=0.7;
1116   7                              }
1117   6                              fun_startdj(mot_r,loc_r);
1118   6                              fun_startdj(mot_l,loc_l);
1119   6                          }
1120   5                          fun_stop(mot_rl);
1121   5                          return;
1122   5                      }
1123   4                  }
1124   3              }
1125   2              loc_r=loc_l=par_sd;
1126   2              if(in_ls3){//纠偏
1127   3                  loc_l*=0.9;
1128   3                  loc_r*=1.1;
1129   3              }
1130   2              if(in_ls6){
1131   3                  loc_l*=1.1;
1132   3                  loc_r*=0.9;
1133   3              }  
1134   2              if(in_ls2){
1135   3                  loc_l*=0.8;
1136   3                  loc_r*=1.2;
1137   3              }
1138   2              if(in_ls7){
1139   3                  loc_l*=1.2;
1140   3                  loc_r*=0.8;
1141   3              }
1142   2              if(in_ls1){
1143   3                  loc_l*=0.7;
1144   3                  loc_r*=1.3;
1145   3              }
1146   2              if(in_ls8){
1147   3                  loc_l*=1.3;
1148   3                  loc_r*=0.7;
1149   3              }
1150   2              fun_startdj(mot_l,loc_l);//更新电机参数
1151   2              fun_startdj(mot_r,loc_r);
1152   2          }
1153   1      }//主函数普通巡线
1154          void fun_stope2prom(){
1155   1          IAP_CONTR = 0;                  //关闭IAP功能
1156   1          IAP_CMD = 0;                    //清除命令
1157   1          IAP_TRIG = 0;                   //清除触发寄存器
1158   1          IAP_ADDRH = 0x80;               //数据指针指向非EEPROM区
1159   1          IAP_ADDRL = 0;                  //清除IAP地址
1160   1      }//关闭EEPROM功能(IapIdle)
1161          uc fun_reade2prom(ui par_add){
1162   1          uc loc_dat;                     //数据缓冲区
1163   1          IAP_CONTR = 0x83;               //打开EEPROM功能,设置等待时间
1164   1          IAP_CMD = 1;                    //设置EEPROM读命令
1165   1          IAP_ADDRL = par_add;            //设置EEPROM地址低八位
1166   1          IAP_ADDRH = par_add >> 8;       //设置EEPROM地址高八位
1167   1          IAP_TRIG = 0x5a;                //触发
1168   1          IAP_TRIG = 0xa5;                //再次触发
1169   1          fun_delay(10,del_us);           //稍等一会儿
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 20  

1170   1          loc_dat = IAP_DATA;             //读出EEPROM中的数据
1171   1          fun_stope2prom();               //关闭EEPROM功能
1172   1          return loc_dat;                 //返回读取结果
1173   1      }//读取EEPROM数据
1174          void fun_writee2prom(ui par_add,uc par_dat){
1175   1          IAP_CONTR = 0x83;               //打开EEPROM功能,设置等待时间
1176   1          IAP_CMD = 2;                    //设置EEPROM写入命令
1177   1          IAP_ADDRL = par_add;            //设置EEPROM地址低八位
1178   1          IAP_ADDRH = par_add >> 8;       //设置EEPROM地址高八位
1179   1          IAP_DATA = par_dat;             //写入数据
1180   1          IAP_TRIG = 0x5a;                //触发
1181   1          IAP_TRIG = 0xa5;                //再次触发
1182   1          fun_delay(10,del_us);           //稍等一会儿
1183   1          fun_stope2prom();               //关闭EEPROM功能
1184   1      }//写EEPROM数据
1185          void fun_cleane2prom(ui par_add){
1186   1          IAP_CONTR = 0x83;               //打开EEPROM功能,设置等待时间
1187   1          IAP_CMD = 3;                    //设置EEPROM擦除命令
1188   1          IAP_ADDRL = par_add;            //设置EEPROM地址低八位
1189   1          IAP_ADDRH = par_add >> 8;       //设置EEPROM地址高八位
1190   1          IAP_TRIG = 0x5a;                //触发
1191   1          IAP_TRIG = 0xa5;                //再次触发
1192   1          fun_delay(10,del_us);           //稍等一会儿
1193   1          fun_stope2prom();               //关闭EEPROM功能
1194   1      }//清除EEPROM数据
1195          void fun_calibration(){
1196   1          // fun_sj1(sjp_wz1);//升到最上位
1197   1          fun_py1(tra_q);//移动到最前端
1198   1          fun_py1(tra_h);//移动到最后端
1199   1          def_timer0start//开始定时器
1200   1          fun_py1(tra_q);//移动到前端并计时
1201   1          fun_py1(tra_h);//移动到后端
1202   1          def_timer0stop//停止定时器
1203   1          var_timer0*=0.39;
1204   1          str_cod.py1zh=str_cod.py1qz=var_timer0*0.5;
1205   1          str_cod.py1qkh=str_cod.py1kqh=var_timer0*0.75;
1206   1          str_cod.py1qkq=str_cod.py1khh=var_timer0*0.25;
1207   1          str_cod.py1kqz=str_cod.py1zkh=var_timer0*0.25;
1208   1          str_cod.py1kqkh=var_timer0*0.5;
1209   1          var_timer0=0;
1210   1      }//自动校准参数
1211          void fun_port(){
1212   1          PCON|=0x80;       //使能波特率倍速位SMOD
1213   1          SCON=0x50;        //8位数据,可变波特率
1214   1          AUXR|=0x04;       //独立波特率发生器时钟为Fosc,即1T
1215   1          BRT=0xD9;     //设定独立波特率发生器重装值
1216   1          AUXR|=0x01;       //串口1选择独立波特率发生器为波特率发生器
1217   1          AUXR|=0x10;       //启动独立波特率发生器
1218   1          TI=1;//打开串口传输功能
1219   1      }//串口初始化
1220          void fun_zhuajian(
1221              uc par_01,uc par_02,uc par_03,uc par_04,uc par_41,uc par_42,uc par_43,uc par_44,
1222              uc par_31,uc par_32,uc par_33,uc par_34,uc par_71,uc par_72,uc par_73,uc par_74){
1223   1      
1224   1          xdata uc loc_data[8][5][2];//三维数组,8个区,5个高度
1225   1          xdata uc loc_high[8];
1226   1          xdata uc loc_xh1=0,loc_xh2=0;
1227   1      
1228   1          memset(loc_data,0,sizeof(loc_data));//清空数组
1229   1          memset(loc_high,0,sizeof(loc_high));//清空数组
1230   1          //起始区件号
1231   1          loc_data[0][1][0]=par_01;//传入形参:区0的第1号件件号(最高位)
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 21  

1232   1          loc_data[0][2][0]=par_02;//传入形参:区0的第2号件件号
1233   1          loc_data[0][3][0]=par_03;//传入形参:区0的第3号件件号
1234   1          loc_data[0][4][0]=par_04;//传入形参:区0的第4号件件号(最低位)
1235   1          loc_data[4][1][0]=par_41;//传入形参:区4的第1号件件号(最高位)
1236   1          loc_data[4][2][0]=par_42;//传入形参:区4的第2号件件号
1237   1          loc_data[4][3][0]=par_43;//传入形参:区4的第3号件件号
1238   1          loc_data[4][4][0]=par_44;//传入形参:区4的第4号件件号(最低位)
1239   1          //目的区件号
1240   1          loc_data[3][1][0]=par_31;//传入形参:区0的第1号件件号(最高位)
1241   1          loc_data[3][2][0]=par_32;//传入形参:区0的第2号件件号
1242   1          loc_data[3][3][0]=par_33;//传入形参:区0的第3号件件号
1243   1          loc_data[3][4][0]=par_34;//传入形参:区0的第4号件件号(最低位)
1244   1          loc_data[7][1][0]=par_71;//传入形参:区4的第1号件件号(最高位)
1245   1          loc_data[7][2][0]=par_72;//传入形参:区4的第2号件件号
1246   1          loc_data[7][3][0]=par_73;//传入形参:区4的第3号件件号
1247   1          loc_data[7][4][0]=par_74;//传入形参:区4的第4号件件号(最低位)
1248   1          //目的次序
1249   1          loc_data[3][1][1]=1;//标准次序:区3的第1号目的次序号(最高位)
1250   1          loc_data[3][2][1]=2;//标准次序:区3的第2号目的次序号
1251   1          loc_data[3][3][1]=3;//标准次序:区3的第3号目的次序号
1252   1          loc_data[3][4][1]=4;//标准次序:区3的第4号目的次序号(最低位)
1253   1          loc_data[7][1][1]=5;//标准次序:区7的第1号目的次序号(最高位)
1254   1          loc_data[7][2][1]=6;//标准次序:区7的第2号目的次序号
1255   1          loc_data[7][3][1]=7;//标准次序:区7的第3号目的次序号
1256   1          loc_data[7][4][1]=8;//标准次序:区7的第4号目的次序号(最低位)
1257   1          //根据形参统一次序
1258   1          for(loc_xh1=4;loc_xh1>0;loc_xh1--){
1259   2              if((loc_data[0][loc_xh1][0]==loc_data[3][1][0])&&(loc_data[0][loc_xh1][0]!=0))
1260   2                  loc_data[0][loc_xh1][1]=loc_data[3][1][1];
1261   2              else if((loc_data[0][loc_xh1][0]==loc_data[3][2][0])&&(loc_data[0][loc_xh1][0]!=0))
1262   2                  loc_data[0][loc_xh1][1]=loc_data[3][2][1];
1263   2              else if((loc_data[0][loc_xh1][0]==loc_data[3][3][0])&&(loc_data[0][loc_xh1][0]!=0))
1264   2                  loc_data[0][loc_xh1][1]=loc_data[3][3][1];
1265   2              else if((loc_data[0][loc_xh1][0]==loc_data[3][4][0])&&(loc_data[0][loc_xh1][0]!=0))
1266   2                  loc_data[0][loc_xh1][1]=loc_data[3][4][1];
1267   2              else if((loc_data[0][loc_xh1][0]==loc_data[7][1][0])&&(loc_data[0][loc_xh1][0]!=0))
1268   2                  loc_data[0][loc_xh1][1]=loc_data[7][1][1];
1269   2              else if((loc_data[0][loc_xh1][0]==loc_data[7][2][0])&&(loc_data[0][loc_xh1][0]!=0))
1270   2                  loc_data[0][loc_xh1][1]=loc_data[7][2][1];
1271   2              else if((loc_data[0][loc_xh1][0]==loc_data[7][3][0])&&(loc_data[0][loc_xh1][0]!=0))
1272   2                  loc_data[0][loc_xh1][1]=loc_data[7][3][1];
1273   2              else if((loc_data[0][loc_xh1][0]==loc_data[7][4][0])&&(loc_data[0][loc_xh1][0]!=0))
1274   2                  loc_data[0][loc_xh1][1]=loc_data[7][4][1];
1275   2      
1276   2              if((loc_data[4][loc_xh1][0]==loc_data[3][1][0])&&(loc_data[4][loc_xh1][0]!=0))
1277   2                  loc_data[4][loc_xh1][1]=loc_data[3][1][1];
1278   2              else if((loc_data[4][loc_xh1][0]==loc_data[3][2][0])&&(loc_data[4][loc_xh1][0]!=0))
1279   2                  loc_data[4][loc_xh1][1]=loc_data[3][2][1];
1280   2              else if((loc_data[4][loc_xh1][0]==loc_data[3][3][0])&&(loc_data[4][loc_xh1][0]!=0))
1281   2                  loc_data[4][loc_xh1][1]=loc_data[3][3][1];
1282   2              else if((loc_data[4][loc_xh1][0]==loc_data[3][4][0])&&(loc_data[4][loc_xh1][0]!=0))
1283   2                  loc_data[4][loc_xh1][1]=loc_data[3][4][1];
1284   2              else if((loc_data[4][loc_xh1][0]==loc_data[7][1][0])&&(loc_data[4][loc_xh1][0]!=0))
1285   2                  loc_data[4][loc_xh1][1]=loc_data[7][1][1];
1286   2              else if((loc_data[4][loc_xh1][0]==loc_data[7][2][0])&&(loc_data[4][loc_xh1][0]!=0))
1287   2                  loc_data[4][loc_xh1][1]=loc_data[7][2][1];
1288   2              else if((loc_data[4][loc_xh1][0]==loc_data[7][3][0])&&(loc_data[4][loc_xh1][0]!=0))
1289   2                  loc_data[4][loc_xh1][1]=loc_data[7][3][1];
1290   2              else if((loc_data[4][loc_xh1][0]==loc_data[7][4][0])&&(loc_data[4][loc_xh1][0]!=0))
1291   2                  loc_data[4][loc_xh1][1]=loc_data[7][4][1];
1292   2          }
1293   1          //清空形参表(实际件序)
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 22  

1294   1          for(loc_xh1=0;loc_xh1<=7;loc_xh1++)
1295   1              for(loc_xh2=0;loc_xh2<=4;loc_xh2++)
1296   1                  loc_data[loc_xh1][loc_xh2][0]=0;
1297   1          for(loc_xh1=0;loc_xh1<=4;loc_xh1++){
1298   2              loc_data[0][loc_xh1][0]=loc_data[0][loc_xh1][1];
1299   2              loc_data[4][loc_xh1][0]=loc_data[4][loc_xh1][1];
1300   2          }//转移04的序号
1301   1          for(loc_xh1=0;loc_xh1<=4;loc_xh1++){
1302   2              loc_data[0][loc_xh1][1]=0;
1303   2              loc_data[1][loc_xh1][1]=0;
1304   2              loc_data[2][loc_xh1][1]=0;
1305   2              loc_data[4][loc_xh1][1]=0;
1306   2              loc_data[5][loc_xh1][1]=0;
1307   2              loc_data[6][loc_xh1][1]=0;
1308   2          }//目的区除了3.7区全部清零
1309   1          for(loc_xh1=0;loc_xh1<=7;loc_xh1++){
1310   2              loc_high[loc_xh1]=4;//默认为没有件
1311   2              for(loc_xh2=0;loc_xh2<=4;loc_xh2++){//5个高度的循环
1312   3                  if(loc_data[loc_xh1][loc_xh2][0]!=0){//如果放了件了
1313   4                      loc_high[loc_xh1]=loc_xh2-1;//记录这个区最高空闲位置
1314   4                      break;//继续区的循环
1315   4                  }
1316   3              }
1317   2          }//8个区的循环
1318   1      
1319   1          fun_sj1(sjp_wz1);
1320   1          fun_sz1(han_s);
1321   1          if((str_begin.hzfx!=dir_left)||(str_begin.hzfx!=dir_right))//不在左右位转到左位
1322   1              fun_hz1(dir_left);
1323   1      
1324   1          while(1){
1325   2              if(str_begin.hzfx==dir_left){
1326   3                  if(loc_high[0]<4){
1327   4                      if((loc_data[0][loc_high[0]+1][0]==loc_data[3][1][1])||
1328   4                         (loc_data[0][loc_high[0]+1][0]==loc_data[3][2][1])||
1329   4                         (loc_data[0][loc_high[0]+1][0]==loc_data[3][3][1])||
1330   4                         (loc_data[0][loc_high[0]+1][0]==loc_data[3][4][1])){
1331   5                          if(loc_data[0][loc_high[0]+1][0]==loc_data[3][loc_high[3]][1]){
1332   6                              fun_sj2(fun_min(4,loc_high[0],loc_high[1],loc_high[2],loc_high[3]));//上升到012
             -3最高位
1333   6                              fun_planezt(0);//平面状态0
1334   6                              fun_sj2(loc_high[0]+1);//下降到区0最高位
1335   6                              fun_sz1(han_j);//抓件
1336   6                              fun_sj2(//上升到123最高位或向上一个格
1337   6                                  loc_high[0]<fun_min(3,loc_high[1],loc_high[2],loc_high[3])-1?
1338   6                                  loc_high[0]:fun_min(3,loc_high[1],loc_high[2],loc_high[3])-1);
1339   6                              fun_planezt(3);//平面状态3
1340   6                              fun_sj2(loc_high[3]);//下降到区3最高位
1341   6                              fun_sz1(han_s);//松件
1342   6      
1343   6                              loc_data[3][loc_high[3]][0]=loc_data[0][loc_high[0]+1][0];//件已经从0区拿到
             -了3区
1344   6                              loc_data[0][loc_high[0]+1][0]=0;//0区木有了
1345   6                              loc_high[0]++;//更新区0最高位
1346   6                              loc_high[3]--;//更新区3最高位
1347   6                          }//0 --> 3
1348   5                          else if(((loc_high[1]>=4)||(loc_data[0][loc_high[0]+1][0]>loc_data[1][loc_high[1]][0])
             -)&&(loc_high[1]>2)&&(loc_high[0]<3)){
1349   6                              fun_sj2(fun_min(4,loc_high[0],loc_high[1],loc_high[2],loc_high[3]));//上升到012
             -3最高位
1350   6                              fun_planezt(0);//平面状态0
1351   6                              fun_sj2(loc_high[0]+1);//下降到区0最高位
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 23  

1352   6                              fun_sz1(han_j);//抓件
1353   6                              fun_sj2(//上升到1最高位或向上一个格
1354   6                                  loc_high[0]<loc_high[1]-1?
1355   6                                  loc_high[0]:loc_high[1]-1);
1356   6                              fun_planezt(1);//平面状态1
1357   6                              fun_sj2(loc_high[1]);//下降到区1最高位
1358   6                              fun_sz1(han_s);//松件
1359   6      
1360   6                              loc_data[1][loc_high[1]][0]=loc_data[0][loc_high[0]+1][0];//件已经从0区拿到
             -了1区
1361   6                              loc_data[0][loc_high[0]+1][0]=0;//0区木有了
1362   6                              loc_high[0]++;//更新区0最高位
1363   6                              loc_high[1]--;//更新区1最高位
1364   6                          }//0 --> 1
1365   5                          else if(((loc_high[2]>=4)||(loc_data[0][loc_high[0]+1][0]>loc_data[2][loc_high[2]][0])
             -)&&(loc_high[2]>2)&&(loc_high[0]<3)){
1366   6                              fun_sj2(fun_min(4,loc_high[0],loc_high[1],loc_high[2],loc_high[3]));//上升到012
             -3最高位
1367   6                              fun_planezt(0);//平面状态0
1368   6                              fun_sj2(loc_high[0]+1);//下降到区0最高位
1369   6                              fun_sz1(han_j);//抓件
1370   6                              fun_sj2(//上升到12最高位或向上一个格
1371   6                                  loc_high[0]<fun_min(2,loc_high[1],loc_high[2])-1?
1372   6                                  loc_high[0]:fun_min(2,loc_high[1],loc_high[2])-1);
1373   6                              fun_planezt(2);//平面状态2
1374   6                              fun_sj2(loc_high[2]);//下降到区2最高位
1375   6                              fun_sz1(han_s);//松件
1376   6      
1377   6                              loc_data[2][loc_high[2]][0]=loc_data[0][loc_high[0]+1][0];//件已经从0区拿到
             -了2区
1378   6                              loc_data[0][loc_high[0]+1][0]=0;//0区木有了
1379   6                              loc_high[0]++;//更新区0最高位
1380   6                              loc_high[2]--;//更新区2最高位
1381   6                          }//0 --> 2
1382   5                      }//目的地在左边
1383   4                      else if((loc_data[0][loc_high[0]+1][0]==loc_data[7][1][1])||
1384   4                              (loc_data[0][loc_high[0]+1][0]==loc_data[7][2][1])||
1385   4                              (loc_data[0][loc_high[0]+1][0]==loc_data[7][3][1])||
1386   4                              (loc_data[0][loc_high[0]+1][0]==loc_data[7][4][1])){
1387   5                          if(loc_data[0][loc_high[0]+1][0]==loc_data[7][loc_high[7]][1]){//如果区0最高位
             -于区7最高位件
1388   6                              fun_sj2(fun_min(4,loc_high[0],loc_high[1],loc_high[2],loc_high[3]));//上升到012
             -3最高位
1389   6                              fun_planezt(0);//平面状态0
1390   6                              fun_sj2(loc_high[0]+1);//下降到区0最高位
1391   6                              fun_sz1(han_j);//抓件
1392   6                              fun_sj2(//上升到167最高位或向上一个格
1393   6                                  loc_high[0]<fun_min(3,loc_high[1],loc_high[6],loc_high[7])-1?
1394   6                                  loc_high[0]:fun_min(3,loc_high[1],loc_high[6],loc_high[7])-1);
1395   6                              fun_planezt(7);//平面状态7
1396   6                              fun_sj2(loc_high[7]);//下降到区7最高位
1397   6                              fun_sz1(han_s);//松件
1398   6      
1399   6                              loc_data[7][loc_high[7]][0]=loc_data[0][loc_high[0]+1][0];//件已经从0区拿到
             -了7区
1400   6                              loc_data[0][loc_high[0]+1][0]=0;//0区木有了
1401   6                              loc_high[0]++;//更新区0最高位
1402   6                              loc_high[7]--;//更新区7最高位
1403   6                          }//0 --> 7
1404   5                          else if(((loc_high[5]>=4)||(loc_data[0][loc_high[0]+1][0]>loc_data[5][loc_high[5]][0])
             -)&&(loc_high[5]>2)&&(loc_high[0]<3)){
1405   6                              fun_sj2(fun_min(4,loc_high[0],loc_high[1],loc_high[2],loc_high[3]));//上升到012
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 24  

             -3最高位
1406   6                              fun_planezt(0);//平面状态0
1407   6                              fun_sj2(loc_high[0]+1);//下降到区0最高位
1408   6                              fun_sz1(han_j);//抓件
1409   6                              fun_sj2(//上升到15最高位或向上一个格
1410   6                                  loc_high[0]<fun_min(2,loc_high[1],loc_high[5])-1?
1411   6                                  loc_high[0]:fun_min(2,loc_high[1],loc_high[5])-1);
1412   6                              fun_planezt(5);//平面状态5
1413   6                              fun_sj2(loc_high[5]);//下降到区5最高位
1414   6                              fun_sz1(han_s);//松件
1415   6      
1416   6                              loc_data[5][loc_high[5]][0]=loc_data[0][loc_high[0]+1][0];//件已经从0区拿到
             -了5区
1417   6                              loc_data[0][loc_high[0]+1][0]=0;//0区木有了
1418   6                              loc_high[0]++;//更新区0最高位
1419   6                              loc_high[5]--;//更新区5最高位
1420   6                          }//0 --> 5
1421   5                          else if(((loc_high[6]>=4)||(loc_data[0][loc_high[0]+1][0]>loc_data[6][loc_high[6]][0])
             -)&&(loc_high[6]>2)&&(loc_high[0]<3)){
1422   6                              fun_sj2(fun_min(4,loc_high[0],loc_high[1],loc_high[2],loc_high[3]));//上升到012
             -3最高位
1423   6                              fun_planezt(0);//平面状态0
1424   6                              fun_sj2(loc_high[0]+1);//下降到区0最高位
1425   6                              fun_sz1(han_j);//抓件
1426   6                              fun_sj2(//上升到16最高位或向上一个格
1427   6                                  loc_high[0]<fun_min(2,loc_high[1],loc_high[6])-1?
1428   6                                  loc_high[0]:fun_min(2,loc_high[1],loc_high[6])-1);
1429   6                              fun_planezt(6);//平面状态6
1430   6                              fun_sj2(loc_high[6]);//下降到区6最高位
1431   6                              fun_sz1(han_s);//松件
1432   6      
1433   6                              loc_data[6][loc_high[6]][0]=loc_data[0][loc_high[0]+1][0];//件已经从0区拿到
             -了6区
1434   6                              loc_data[0][loc_high[0]+1][0]=0;//0区木有了
1435   6                              loc_high[0]++;//更新区0最高位
1436   6                              loc_high[6]--;//更新区6最高位
1437   6                          }//0 --> 6
1438   5                      }//目的地在右边
1439   4                      else//报错
1440   4                          MSG("Error! fun_zhuajian if(loc_high[0]<4)")
1441   4                  }//如果区0有件
1442   3                  else if(loc_high[1]<4){
1443   4                      if(loc_data[1][loc_high[1]+1][0]==loc_data[3][loc_high[3]][1]){
1444   5                          fun_sj2(fun_min(4,loc_high[0],loc_high[1],loc_high[2],loc_high[3]));//上升到0123最
             -高位
1445   5                          fun_planezt(1);//平面状态1
1446   5                          fun_sj2(loc_high[1]+1);//下降到区1最高位
1447   5                          fun_sz1(han_j);//抓件
1448   5                          fun_sj2(//上升到23最高位或向上一个格
1449   5                              loc_high[1]<fun_min(2,loc_high[2],loc_high[3])-1?
1450   5                              loc_high[1]:fun_min(2,loc_high[2],loc_high[3])-1);
1451   5                          fun_planezt(3);//平面状态3
1452   5                          fun_sj2(loc_high[3]);//下降到区3最高位
1453   5                          fun_sz1(han_s);//松件
1454   5      
1455   5                          loc_data[3][loc_high[3]][0]=loc_data[1][loc_high[1]+1][0];//件已经从1区拿到了3
             -区
1456   5                          loc_data[1][loc_high[1]+1][0]=0;//1区木有了
1457   5                          loc_high[1]++;//更新区1最高位
1458   5                          loc_high[3]--;//更新区3最高位
1459   5                      }//1 --> 3
1460   4                      else if(((loc_high[2]>=4)||(loc_data[1][loc_high[1]+1][0]>loc_data[2][loc_high[2]][0]))&&(
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 25  

             -loc_high[2]>2)){
1461   5                          fun_sj2(fun_min(4,loc_high[0],loc_high[1],loc_high[2],loc_high[3]));//上升到0123最
             -高位
1462   5                          fun_planezt(1);//平面状态1
1463   5                          fun_sj2(loc_high[1]+1);//下降到区1最高位
1464   5                          fun_sz1(han_j);//抓件
1465   5                          fun_sj2(//上升到2最高位或向上一个格
1466   5                              loc_high[1]<loc_high[2]-1?
1467   5                              loc_high[1]:loc_high[2]-1);
1468   5                          fun_planezt(2);//平面状态2
1469   5                          fun_sj2(loc_high[2]);//下降到区2最高位
1470   5                          fun_sz1(han_s);//松件
1471   5      
1472   5                          loc_data[2][loc_high[2]][0]=loc_data[1][loc_high[1]+1][0];//件已经从1区拿到了2
             -区
1473   5                          loc_data[1][loc_high[1]+1][0]=0;//1区木有了
1474   5                          loc_high[1]++;//更新区1最高位
1475   5                          loc_high[2]--;//更新区2最高位
1476   5                      }//1 --> 2
1477   4                  }//如果区1有件
1478   3                  else if(loc_high[2]<4){
1479   4                      if(loc_data[2][loc_high[2]+1][0]==loc_data[3][loc_high[3]][1]){
1480   5                          fun_sj2(fun_min(4,loc_high[0],loc_high[1],loc_high[2],loc_high[3]));//上升到0123最
             -高位
1481   5                          fun_planezt(2);//平面状态2
1482   5                          fun_sj2(loc_high[2]+1);//下降到区2最高位
1483   5                          fun_sz1(han_j);//抓件
1484   5                          fun_sj2(//上升到3最高位或向上一个格
1485   5                              loc_high[2]<loc_high[3]-1?
1486   5                              loc_high[2]:loc_high[3]-1);
1487   5                          fun_planezt(3);//平面状态3
1488   5                          fun_sj2(loc_high[3]);//下降到区3最高位
1489   5                          fun_sz1(han_s);//松件
1490   5      
1491   5                          loc_data[3][loc_high[3]][0]=loc_data[2][loc_high[2]+1][0];//件已经从2区拿到了3
             -区
1492   5                          loc_data[2][loc_high[2]+1][0]=0;//2区木有了
1493   5                          loc_high[2]++;//更新区2最高位
1494   5                          loc_high[3]--;//更新区3最高位
1495   5                      }//2 --> 3
1496   4                      else if(((loc_high[1]>=4)||(loc_data[2][loc_high[2]+1][0]>loc_data[1][loc_high[1]][0]))&&(
             -loc_high[1]>2)){
1497   5                          MSG("Error! fun_zhuajian if(loc_high[2]<4)")
1498   5                      }//2 --> 1
1499   4                  }//如果区2有件
1500   3                  if((loc_data[3][4][0]==loc_data[3][4][1])&&
1501   3                     (loc_data[3][3][0]==loc_data[3][3][1])&&
1502   3                     (loc_data[3][2][0]==loc_data[3][2][1])&&
1503   3                     (loc_data[3][1][0]==loc_data[3][1][1])&&
1504   3                     (loc_data[0][4][0]==0)&&
1505   3                     (loc_data[0][3][0]==0)&&
1506   3                     (loc_data[0][2][0]==0)&&
1507   3                     (loc_data[0][1][0]==0)){
1508   4                      if((loc_data[7][4][0]==loc_data[7][4][1])&&
1509   4                         (loc_data[7][3][0]==loc_data[7][3][1])&&
1510   4                         (loc_data[7][2][0]==loc_data[7][2][1])&&
1511   4                         (loc_data[7][1][0]==loc_data[7][1][1])&&
1512   4                         (loc_data[4][4][0]==0)&&
1513   4                         (loc_data[4][3][0]==0)&&
1514   4                         (loc_data[4][2][0]==0)&&
1515   4                         (loc_data[4][1][0]==0))
1516   4                          return;
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 26  

1517   4                      else{
1518   5                          fun_sj1(fun_min(8,loc_high[0],loc_high[1],loc_high[2],loc_high[3],
1519   5                                            loc_high[4],loc_high[5],loc_high[6],loc_high[7]));
1520   5                          fun_hz1(dir_right);
1521   5                      }
1522   4                  }//退出条件
1523   3              }
1524   2              else if(str_begin.hzfx==dir_right){
1525   3                  if(loc_high[4]<4){
1526   4                      if((loc_data[4][loc_high[4]+1][0]==loc_data[7][1][1])||
1527   4                         (loc_data[4][loc_high[4]+1][0]==loc_data[7][2][1])||
1528   4                         (loc_data[4][loc_high[4]+1][0]==loc_data[7][3][1])||
1529   4                         (loc_data[4][loc_high[4]+1][0]==loc_data[7][4][1])){
1530   5                          if(loc_data[4][loc_high[4]+1][0]==loc_data[7][loc_high[7]][1]){
1531   6                              fun_sj2(fun_min(4,loc_high[4],loc_high[5],loc_high[6],loc_high[7]));//上升到456
             -7最高位
1532   6                              fun_planezt(4);//平面状态4
1533   6                              fun_sj2(loc_high[4]+1);//下降到区4最高位
1534   6                              fun_sz1(han_j);//抓件
1535   6                              fun_sj2(//上升到567最高位或向上一个格
1536   6                                  loc_high[4]<fun_min(3,loc_high[5],loc_high[6],loc_high[7])-1?
1537   6                                  loc_high[4]:fun_min(3,loc_high[5],loc_high[6],loc_high[7])-1);
1538   6                              fun_planezt(7);//平面状态7
1539   6                              fun_sj2(loc_high[7]);//下降到区7最高位
1540   6                              fun_sz1(han_s);//松件
1541   6      
1542   6                              loc_data[7][loc_high[7]][0]=loc_data[4][loc_high[4]+1][0];//件已经从4区拿到
             -了7区
1543   6                              loc_data[4][loc_high[4]+1][0]=0;//4区木有了
1544   6                              loc_high[4]++;//更新区4最高位
1545   6                              loc_high[7]--;//更新区7最高位
1546   6                          }//4 --> 7
1547   5                          else if(((loc_high[5]>=4)||(loc_data[4][loc_high[4]+1][0]>loc_data[5][loc_high[5]][0])
             -)&&(loc_high[5]>2)&&(loc_high[4]<3)){
1548   6                              fun_sj2(fun_min(4,loc_high[4],loc_high[5],loc_high[6],loc_high[7]));//上升到456
             -7最高位
1549   6                              fun_planezt(4);//平面状态4
1550   6                              fun_sj2(loc_high[4]+1);//下降到区4最高位
1551   6                              fun_sz1(han_j);//抓件
1552   6                              fun_sj2(//上升到5最高位或向上一个格
1553   6                                  loc_high[4]<loc_high[5]-1?
1554   6                                  loc_high[4]:loc_high[5]-1);
1555   6                              fun_planezt(5);//平面状态5
1556   6                              fun_sj2(loc_high[5]);//下降到区5最高位
1557   6                              fun_sz1(han_s);//松件
1558   6      
1559   6                              loc_data[5][loc_high[5]][0]=loc_data[4][loc_high[4]+1][0];//件已经从4区拿到
             -了5区
1560   6                              loc_data[4][loc_high[4]+1][0]=0;//4区木有了
1561   6                              loc_high[4]++;//更新区4最高位
1562   6                              loc_high[5]--;//更新区5最高位
1563   6                          }//4 --> 5
1564   5                          else if(((loc_high[6]>=4)||(loc_data[4][loc_high[4]+1][0]>loc_data[6][loc_high[6]][0])
             -)&&(loc_high[6]>2)&&(loc_high[4]<3)){
1565   6                              fun_sj2(fun_min(4,loc_high[4],loc_high[5],loc_high[6],loc_high[7]));//上升到456
             -7最高位
1566   6                              fun_planezt(4);//平面状态4
1567   6                              fun_sj2(loc_high[4]+1);//下降到区4最高位
1568   6                              fun_sz1(han_j);//抓件
1569   6                              fun_sj2(//上升到56最高位或向上一个格
1570   6                                  loc_high[4]<fun_min(2,loc_high[5],loc_high[6])-1?
1571   6                                  loc_high[4]:fun_min(2,loc_high[5],loc_high[6])-1);
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 27  

1572   6                              fun_planezt(6);//平面状态6
1573   6                              fun_sj2(loc_high[6]);//下降到区6最高位
1574   6                              fun_sz1(han_s);//松件
1575   6      
1576   6                              loc_data[6][loc_high[6]][0]=loc_data[4][loc_high[4]+1][0];//件已经从4区拿到
             -了6区
1577   6                              loc_data[4][loc_high[4]+1][0]=0;//4区木有了
1578   6                              loc_high[4]++;//更新区4最高位
1579   6                              loc_high[6]--;//更新区6最高位
1580   6                          }//4 --> 6
1581   5                      }//目的地在右边
1582   4                      else if((loc_data[4][loc_high[4]+1][0]==loc_data[3][1][1])||
1583   4                              (loc_data[4][loc_high[4]+1][0]==loc_data[3][2][1])||
1584   4                              (loc_data[4][loc_high[4]+1][0]==loc_data[3][3][1])||
1585   4                              (loc_data[4][loc_high[4]+1][0]==loc_data[3][4][1])){
1586   5                          if(loc_data[4][loc_high[4]+1][0]==loc_data[3][loc_high[3]][1]){
1587   6                              fun_sj2(fun_min(4,loc_high[4],loc_high[5],loc_high[6],loc_high[7]));//上升到456
             -7最高位
1588   6                              fun_planezt(4);//平面状态4
1589   6                              fun_sj2(loc_high[4]+1);//下降到区4最高位
1590   6                              fun_sz1(han_j);//抓件
1591   6                              fun_sj2(//上升到523最高位或向上一个格
1592   6                                  loc_high[4]<fun_min(3,loc_high[5],loc_high[2],loc_high[3])-1?
1593   6                                  loc_high[4]:fun_min(3,loc_high[5],loc_high[2],loc_high[3])-1);
1594   6                              fun_planezt(3);//平面状态3
1595   6                              fun_sj2(loc_high[3]);//下降到区3最高位
1596   6                              fun_sz1(han_s);//松件
1597   6      
1598   6                              loc_data[3][loc_high[3]][0]=loc_data[4][loc_high[4]+1][0];//件已经从4区拿到
             -了3区
1599   6                              loc_data[4][loc_high[4]+1][0]=0;//4区木有了
1600   6                              loc_high[4]++;//更新区4最高位
1601   6                              loc_high[3]--;//更新区3最高位
1602   6                          }//4 --> 3
1603   5                          else if(((loc_high[1]>=4)||(loc_data[4][loc_high[4]+1][0]>loc_data[1][loc_high[1]][0])
             -)&&(loc_high[1]>2)&&(loc_high[4]<3)){
1604   6                              fun_sj2(fun_min(4,loc_high[4],loc_high[5],loc_high[6],loc_high[7]));//上升到456
             -7最高位
1605   6                              fun_planezt(4);//平面状态4
1606   6                              fun_sj2(loc_high[4]+1);//下降到区4最高位
1607   6                              fun_sz1(han_j);//抓件
1608   6                              fun_sj2(//上升到51最高位或向上一个格
1609   6                                  loc_high[4]<fun_min(2,loc_high[5],loc_high[1])-1?
1610   6                                  loc_high[4]:fun_min(2,loc_high[5],loc_high[1])-1);
1611   6                              fun_planezt(1);//平面状态1
1612   6                              fun_sj2(loc_high[1]);//下降到区1最高位
1613   6                              fun_sz1(han_s);//松件
1614   6      
1615   6                              loc_data[1][loc_high[1]][0]=loc_data[4][loc_high[4]+1][0];//件已经从4区拿到
             -了1区
1616   6                              loc_data[4][loc_high[4]+1][0]=0;//4区木有了
1617   6                              loc_high[4]++;//更新区4最高位
1618   6                              loc_high[1]--;//更新区1最高位
1619   6                          }//4 --> 1
1620   5                          else if(((loc_high[2]>=4)||(loc_data[4][loc_high[4]+1][0]>loc_data[2][loc_high[2]][0])
             -)&&(loc_high[2]>2)&&(loc_high[4]<3)){
1621   6                              fun_sj2(fun_min(4,loc_high[4],loc_high[5],loc_high[6],loc_high[7]));//上升到456
             -7最高位
1622   6                              fun_planezt(4);//平面状态4
1623   6                              fun_sj2(loc_high[4]+1);//下降到区4最高位
1624   6                              fun_sz1(han_j);//抓件
1625   6                              fun_sj2(//上升到523最高位或向上一个格
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 28  

1626   6                                  loc_high[4]<fun_min(2,loc_high[5],loc_high[2])-1?
1627   6                                  loc_high[4]:fun_min(2,loc_high[5],loc_high[2])-1);
1628   6                              fun_planezt(2);//平面状态2
1629   6                              fun_sj2(loc_high[2]);//下降到区2最高位
1630   6                              fun_sz1(han_s);//松件
1631   6      
1632   6                              loc_data[2][loc_high[2]][0]=loc_data[4][loc_high[4]+1][0];//件已经从4区拿到
             -了2区
1633   6                              loc_data[4][loc_high[4]+1][0]=0;//4区木有了
1634   6                              loc_high[4]++;//更新区4最高位
1635   6                              loc_high[2]--;//更新区2最高位
1636   6                          }//4 --> 2
1637   5                      }//目的地在左边
1638   4                      else
1639   4                          MSG("Error! fun_zhuajian if(loc_high[4]<4)")
1640   4                  }//如果区4有件
1641   3                  else if(loc_high[5]<4){
1642   4                      if(loc_data[5][loc_high[5]+1][0]==loc_data[7][loc_high[7]][1]){
1643   5                          fun_sj2(fun_min(4,loc_high[4],loc_high[5],loc_high[6],loc_high[7]));//上升到4567最
             -高位
1644   5                          fun_planezt(5);//平面状态5
1645   5                          fun_sj2(loc_high[5]+1);//下降到区5最高位
1646   5                          fun_sz1(han_j);//抓件
1647   5                          fun_sj2(//上升到67最高位或向上一个格
1648   5                              loc_high[5]<fun_min(2,loc_high[6],loc_high[7])-1?
1649   5                              loc_high[5]:fun_min(2,loc_high[6],loc_high[7])-1);
1650   5                          fun_planezt(7);//平面状态7
1651   5                          fun_sj2(loc_high[7]);//下降到区7最高位
1652   5                          fun_sz1(han_s);//松件
1653   5      
1654   5                          loc_data[7][loc_high[7]][0]=loc_data[5][loc_high[5]+1][0];//件已经从5区拿到了7
             -区
1655   5                          loc_data[5][loc_high[5]+1][0]=0;//5区木有了
1656   5                          loc_high[5]++;//更新区5最高位
1657   5                          loc_high[7]--;//更新区7最高位
1658   5                      }//5 --> 7
1659   4                      else if(((loc_high[6]>=4)||(loc_data[5][loc_high[5]+1][0]>loc_data[6][loc_high[6]][0]))&&(
             -loc_high[6]>2)){
1660   5                          fun_sj2(fun_min(4,loc_high[4],loc_high[5],loc_high[6],loc_high[7]));//上升到4567最
             -高位
1661   5                          fun_planezt(5);//平面状态5
1662   5                          fun_sj2(loc_high[5]+1);//下降到区5最高位
1663   5                          fun_sz1(han_j);//抓件
1664   5                          fun_sj2(//上升到6最高位或向上一个格
1665   5                              loc_high[5]<loc_high[6]-1?
1666   5                              loc_high[5]:loc_high[6]-1);
1667   5                          fun_planezt(6);//平面状态6
1668   5                          fun_sj2(loc_high[6]);//下降到区6最高位
1669   5                          fun_sz1(han_s);//松件
1670   5      
1671   5                          loc_data[6][loc_high[6]][0]=loc_data[5][loc_high[5]+1][0];//件已经从5区拿到了6
             -区
1672   5                          loc_data[5][loc_high[5]+1][0]=0;//5区木有了
1673   5                          loc_high[5]++;//更新区5最高位
1674   5                          loc_high[6]--;//更新区6最高位
1675   5                      }//5 --> 6
1676   4                  }//如果区5有件
1677   3                  else if(loc_high[6]<4){
1678   4                      if(loc_data[6][loc_high[6]+1][0]==loc_data[7][loc_high[7]][1]){
1679   5                          fun_sj2(fun_min(4,loc_high[4],loc_high[5],loc_high[6],loc_high[7]));//上升到4567最
             -高位
1680   5                          fun_planezt(6);//平面状态6
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 29  

1681   5                          fun_sj2(loc_high[6]+1);//下降到区6最高位
1682   5                          fun_sz1(han_j);//抓件
1683   5                          fun_sj2(//上升到7最高位或向上一个格
1684   5                              loc_high[6]<loc_high[7]-1?
1685   5                              loc_high[6]:loc_high[7]-1);
1686   5                          fun_planezt(7);//平面状态7
1687   5                          fun_sj2(loc_high[7]);//下降到区7最高位
1688   5                          fun_sz1(han_s);//松件
1689   5      
1690   5                          loc_data[7][loc_high[7]][0]=loc_data[6][loc_high[6]+1][0];//件已经从6区拿到了7
             -区
1691   5                          loc_data[6][loc_high[6]+1][0]=0;//6区木有了
1692   5                          loc_high[6]++;//更新区6最高位
1693   5                          loc_high[7]--;//更新区7最高位
1694   5                      }//6 --> 7
1695   4                      else if(((loc_high[5]>=4)||(loc_data[6][loc_high[6]+1][0]>loc_data[5][loc_high[5]][0]))&&(
             -loc_high[5]>2)){
1696   5                          MSG("Error! fun_zhuajian if(loc_high[6]<4)")
1697   5                      }//6 --> 5
1698   4                  }//如果区6有件
1699   3                  if((loc_data[7][4][0]==loc_data[7][4][1])&&
1700   3                     (loc_data[7][3][0]==loc_data[7][3][1])&&
1701   3                     (loc_data[7][2][0]==loc_data[7][2][1])&&
1702   3                     (loc_data[7][1][0]==loc_data[7][1][1])&&
1703   3                     (loc_data[4][4][0]==0)&&
1704   3                     (loc_data[4][3][0]==0)&&
1705   3                     (loc_data[4][2][0]==0)&&
1706   3                     (loc_data[4][1][0]==0)){
1707   4                      if((loc_data[3][4][0]==loc_data[3][4][1])&&
1708   4                         (loc_data[3][3][0]==loc_data[3][3][1])&&
1709   4                         (loc_data[3][2][0]==loc_data[3][2][1])&&
1710   4                         (loc_data[3][1][0]==loc_data[3][1][1])&&
1711   4                         (loc_data[0][4][0]==0)&&
1712   4                         (loc_data[0][3][0]==0)&&
1713   4                         (loc_data[0][2][0]==0)&&
1714   4                         (loc_data[0][1][0]==0))
1715   4                          return;
1716   4                      else{
1717   5                          fun_sj1(fun_min(8,loc_high[0],loc_high[1],loc_high[2],loc_high[3],
1718   5                                            loc_high[4],loc_high[5],loc_high[6],loc_high[7]));
1719   5                          fun_hz1(dir_left);
1720   5                      }
1721   4                  }//退出条件
1722   3              }
1723   2          }
1724   1      }//自动抓件
1725          uc fun_min(uc par_num,...){
1726   1          va_list loc_argp;//保存参数结构
1727   1          uc loc_xh;//循环
1728   1          uc loc_shu;//当前参数
1729   1          uc loc_min;//最小值
1730   1          va_start(loc_argp,par_num);//loc_argp指向传入的第一个可选参数，par_num是最后一个确
             -的参数
1731   1          loc_min=va_arg(loc_argp,uc);//第一个参数传入
1732   1          for(loc_xh=1;loc_xh<par_num;loc_xh++){//指定循环次数
1733   2              loc_shu=va_arg(loc_argp,uc);//取出一个参数
1734   2              if(loc_shu<loc_min)
1735   2                  loc_min=loc_shu;
1736   2          }
1737   1          va_end(loc_argp);
1738   1          return loc_min;
1739   1      }//求最小值
C51 COMPILER V9.01   8023                                                                  03/11/2015 08:56:45 PAGE 30  



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  10700    ----
   CONSTANT SIZE    =    157    ----
   XDATA SIZE       =     47      90
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      53
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
