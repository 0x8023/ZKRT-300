C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE 8023
OBJECT MODULE PLACED IN .\output\8023.obj
COMPILER INVOKED BY: D:\MyProgram\keil\C51\BIN\C51.EXE program\8023.c OPTIMIZE(8,SPEED) DEBUG OBJECTEXTEND PRINT(.\8023.
                    -lst) OBJECT(.\output\8023.obj)

line level    source

   1          #include "./output/8023.h"
   2          xdata struct str_state str_begin,str_now,str_next;//分别为:起始状态/当前状态/目标状态
   3          xdata struct str_parameter str_cod={
   4              /*ui str_cod.mlinerqd*/25000,//默认主函数巡线软起动路程为25000
   5              /*ui str_cod.mlineqc*/200,   //默认主函数巡线前冲时间为500毫秒
   6          
   7              /*ui str_cod.sj1bzw*/58,     //升降标准位延时
   8              /*ui str_cod.sj1zjw*/800,    //升降中间位延时
   9          
  10              /*ui str_cod.py1bz*/45,      //fun_py标准位延时
  11              /*ui str_cod.py1qkq*/600,    //fun_py前到靠前延时参数
  12              /*ui str_cod.py1kqz*/525,    //fun_py靠前到中间延时
  13              /*ui str_cod.py1zkh*/525,    //fun_py中间到靠后延时
  14              /*ui str_cod.py1khh*/540,    //fun_py靠后到后延时
  15              /*ui str_cod.py1qz*/1155,    //fun_py前到中间延时
  16              /*ui str_cod.py1zh*/1090,    //fun_py中间到后延时
  17              /*ui str_cod.py1kqkh*/1105,  //fun_py靠前到靠后延时
  18              /*ui str_cod.py1khkq*/1050,  //fun_py靠后到靠前延时
  19              /*ui str_cod.py1qkh*/1735,   //fun_py前到靠后延时
  20              /*ui str_cod.py1kqh*/1635,   //fun_py靠前到后延时
  21          
  22              /*ui str_cod.hz1bz*/20,      //fun_hz标准位延时
  23          
  24              /*ui turn90;*/500,           //90度转弯屏蔽延时
  25              /*ui turn180;*/2000          //180度转弯屏蔽延时
  26          };
  27          xdata struct str_timerfolline str_tfl;
  28          ul var_timer=0;
  29          void fun_delay(ui par_value,enum varENU_del par_model){
  30   1          ui loc_con=par_value;
  31   1          switch(par_model){
  32   2              case del_us://微秒级延时
  33   2                  #ifdef Debug
                              printf("fun_delay(%d,del_us);\n",par_value);
                          #else
  36   2                      while(loc_con-->0){
  37   3                          _nop_();
  38   3                          _nop_();
  39   3                      }
  40   2                  #endif
  41   2                  return;
  42   2              case del_ms://毫秒级延时
  43   2                  #ifdef Debug
                              printf("fun_delay(%d,del_ms);\n",par_value);
                          #else
  46   2                      while(loc_con-->0){
  47   3                          uc loc_i, loc_j;
  48   3                          _nop_();
  49   3                          _nop_();
  50   3                          loc_i=12;
  51   3                          loc_j=168;
  52   3                          do{
  53   4                              while(--loc_j);
  54   4                          }while(--loc_i);
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 2   

  55   3                      }
  56   2                  #endif
  57   2                  return;
  58   2              case del_s://秒级延时
  59   2                  #ifdef Debug
                              printf("fun_delay(%d,del_s);\n",par_value);
                          #else
  62   2                      while(loc_con-->0){
  63   3                          uc loc_i, loc_j, loc_k;
  64   3                          loc_i=46;
  65   3                          loc_j=153;
  66   3                          loc_k=245;
  67   3                          do{
  68   4                              do{
  69   5                                  while(--loc_k);
  70   5                              }while(--loc_j);
  71   4                          }while(--loc_i);
  72   3                      }
  73   2                  #endif
  74   2                  return;
  75   2              default:return;
  76   2          }
  77   1      }//延时
  78          void fun_timer0init(){
  79   1          #ifdef Debug
                      printf("fun_timer0init();\n");
                  #endif
  82   1          AUXR|=0x80;   //定时器时钟1T模式
  83   1          TMOD&=0xF0;   //定时器模式:16位
  84   1          TMOD|=0x01;   //定时器模式:16位
  85   1          TL0=0x20;     //定时初值:1ms
  86   1          TH0=0xD1;     //定时初值:1ms
  87   1          TF0=0;        //清除TF0标志
  88   1          ET0=1;
  89   1          EA=1;         //开启总中断
  90   1      }//1毫秒定时器0初始化
  91          void fun_timer1init(){
  92   1          #ifdef Debug
                      printf("fun_timer1init();\n");
                  #endif
  95   1          AUXR&=0xBF;     //定时器时钟12T模式
  96   1          TMOD&=0x0F;     //定时器模式:16位
  97   1          TMOD|=0x10;     //定时器模式:16位
  98   1          TL1=0xE0;       //定时初值:20ms
  99   1          TH1=0xB1;       //定时初值:20ms
 100   1          TF1=0;          //清除TF1标志
 101   1          ET1=1;
 102   1          EA=1;           //开启总中断
 103   1      }//20毫秒定时器1初始化
 104          void fun_timer0(){
 105   1          TL0=0x20;
 106   1          TH0=0xD1;//定时器初值恢复至1ms
 107   1          var_timer++;//全局计时器开始计时
 108   1          if(str_tfl.doing==tf_ture)//如果正在移动
 109   1              fun_timermove();//定时器移动
 110   1      }//1毫秒定时器0处理函数
 111          void fun_timer1(){
 112   1          TL1=0xE0;
 113   1          TH1=0xB1;
 114   1      }//20毫秒定时器1处理函数
 115          void fun_wait(){
 116   1          #ifdef Debug
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 3   

                      printf("fun_wait();\n");
                  #else
 119   1              while(in_start==1);
 120   1              fun_delay(20,del_ms);
 121   1              while(in_start==0);
 122   1              fun_delay(256,del_ms);
 123   1          #endif
 124   1      }//等待按键
 125          void fun_pwminit(){
 126   1          #ifdef Debug
                      printf("fun_pwminit();\n");
                  #endif
 129   1          CCON=0x00;//PAC寄存控制器
 130   1          CH=0;//重置PAC计时器
 131   1          CL=0;
 132   1          CMOD=0x08;//不分频
 133   1      }//PWM初始化
 134          void fun_pwmr(uc par_value){
 135   1          CCAP0H=CCAP0L=par_value*25/10;//控制输出的占空比
 136   1          CCAPM0=0X42;//8位PWM输出，无中断
 137   1          PCA_PWM0=0x00;
 138   1      }//右路PWM输出
 139          void fun_pwml(uc par_value){
 140   1          CCAP1H=CCAP1L=par_value*25/10;//控制输出的占空比
 141   1          CCAPM1=0X42;//8位PWM输出，无中断
 142   1          PCA_PWM1=0x00;
 143   1      }//左路PWM输出
 144          void fun_motors(enum varENU_mot par_model,char par_speed){
 145   1          if(par_speed>100)
 146   1              par_speed=100;
 147   1          else if(par_speed<-100)
 148   1              par_speed=-100;//速度最多100,最少-100
 149   1          switch(par_model){
 150   2              case mot_l://左轮电机
 151   2                  if(str_begin.leftsd==par_speed)
 152   2                      return;
 153   2                  else
 154   2                      str_begin.leftsd=par_speed;
 155   2                  if(par_speed==0){
 156   3                      fun_pwml(0);out_pwml=0;
 157   3                  }
 158   2                  else if(par_speed>0){
 159   3                      CR=1;fun_pwml(par_speed);out_pwml=0;
 160   3                  }
 161   2                  else if(par_speed<0){
 162   3                      CR=1;fun_pwml(cabs(par_speed));out_pwml=1;
 163   3                  }
 164   2                  break;
 165   2              case mot_r://右轮电机
 166   2                  if(str_begin.rightsd==par_speed)
 167   2                      return;
 168   2                  else
 169   2                      str_begin.rightsd=par_speed;
 170   2                  if(par_speed==0){
 171   3                      fun_pwmr(0);out_pwmr=0;
 172   3                  }
 173   2                  else if(par_speed>0){
 174   3                      CR=1;fun_pwmr(par_speed);out_pwmr=0;
 175   3                  }
 176   2                  else if(par_speed<0){
 177   3                      CR=1;fun_pwmr(cabs(par_speed));out_pwmr=1;
 178   3                  }
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 4   

 179   2                  break;
 180   2              case mot_rl://左右轮同步
 181   2                  if((str_begin.leftsd==par_speed)&&(str_begin.rightsd==par_speed))
 182   2                      return;
 183   2                  else
 184   2                      str_begin.leftsd=str_begin.rightsd=par_speed;
 185   2                  if(par_speed==0){
 186   3                      CR=0;
 187   3                      fun_pwmr(0);out_pwmr=0;
 188   3                      fun_pwml(0);out_pwml=0;
 189   3                  }
 190   2                  else if(par_speed>0){
 191   3                      CR=1;
 192   3                      fun_pwml(par_speed);out_pwml=0;
 193   3                      fun_pwmr(par_speed);out_pwmr=0;
 194   3                  }
 195   2                  else if(par_speed<0){
 196   3                      CR=1;
 197   3                      fun_pwml(cabs(par_speed));out_pwml=1;
 198   3                      fun_pwmr(cabs(par_speed));out_pwmr=1;
 199   3                  }
 200   2                  break;
 201   2              case mot_sz://正转为抓紧，反转为松开
 202   2                  if(str_begin.szsd==par_speed)
 203   2                      return;
 204   2                  else
 205   2                      str_begin.szsd=par_speed;
 206   2                  if(par_speed==0){
 207   3                      out_motorselect=1;out_dir1=0;out_en1=1;
 208   3                  }
 209   2                  else if(par_speed>0){
 210   3                      out_motorselect=1;out_dir1=1;out_en1=0;
 211   3                  }
 212   2                  else if(par_speed<0){
 213   3                      out_motorselect=1;out_dir1=0;out_en1=0;
 214   3                  }
 215   2                  break;
 216   2              case mot_py://正转是向无电机一方转,反转为向有电机一方转
 217   2                  if(str_begin.pysd==par_speed)
 218   2                      return;
 219   2                  else
 220   2                      str_begin.pysd=par_speed;
 221   2                  if(par_speed==0){
 222   3                      out_motorselect=1;out_dir2=0;out_en2=1;
 223   3                  }
 224   2                  else if(par_speed>0){
 225   3                      out_motorselect=1;out_dir2=1;out_en2=0;
 226   3                  }
 227   2                  else if(par_speed<0){
 228   3                      out_motorselect=1;out_dir2=0;out_en2=0;
 229   3                  }
 230   2                  break;
 231   2              case mot_sj://向上为正转,向下为反转
 232   2                  if(str_begin.sjsd==par_speed)
 233   2                      return;
 234   2                  else
 235   2                      str_begin.sjsd=par_speed;
 236   2                  if(par_speed==0){
 237   3                      out_motorselect=0;out_dir1=0;out_en1=1;
 238   3                  }
 239   2                  else if(par_speed>0){
 240   3                      out_motorselect=0;out_dir1=0;out_en1=0;
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 5   

 241   3                  }
 242   2                  else if(par_speed<0){
 243   3                      out_motorselect=0;out_dir1=1;out_en1=0;
 244   3                  }
 245   2                  break;
 246   2              case mot_hz://顺时针为正转,逆时针为反转
 247   2                  if(str_begin.hzsd==par_speed)
 248   2                      return;
 249   2                  else
 250   2                      str_begin.hzsd=par_speed;
 251   2                  if(par_speed==0){
 252   3                      out_motorselect=0;out_dir2=0;out_en2=1;
 253   3                  }
 254   2                  else if(par_speed>0){
 255   3                      out_motorselect=0;out_dir2=0;out_en2=0;
 256   3                  }
 257   2                  else if(par_speed<0){
 258   3                      out_motorselect=0;out_dir2=1;out_en2=0;
 259   3                  }
 260   2                  break;
 261   2              default:
 262   2                  break;
 263   2          }
 264   1      }//主函数操作电机
 265          void fun_motorsrl(enum varENU_mot par_model,char par_speed){
 266   1          if(par_speed>100)
 267   1              par_speed=100;
 268   1          else if(par_speed<-100)
 269   1              par_speed=-100;//速度最多100,最少-100
 270   1          switch(par_model){
 271   2              case mot_l://左轮电机
 272   2                  if(str_begin.leftsd==par_speed)
 273   2                      return;
 274   2                  else
 275   2                      str_begin.leftsd=par_speed;
 276   2                  if(par_speed==0){
 277   3                      fun_pwml(0);out_pwml=0;
 278   3                  }
 279   2                  else if(par_speed>0){
 280   3                      CR=1;fun_pwml(par_speed);out_pwml=0;
 281   3                  }
 282   2                  else if(par_speed<0){
 283   3                      CR=1;fun_pwml(cabs(par_speed));out_pwml=1;
 284   3                  }
 285   2                  break;
 286   2              case mot_r://右轮电机
 287   2                  if(str_begin.rightsd==par_speed)
 288   2                      return;
 289   2                  else
 290   2                      str_begin.rightsd=par_speed;
 291   2                  if(par_speed==0){
 292   3                      fun_pwmr(0);out_pwmr=0;
 293   3                  }
 294   2                  else if(par_speed>0){
 295   3                      CR=1;fun_pwmr(par_speed);out_pwmr=0;
 296   3                  }
 297   2                  else if(par_speed<0){
 298   3                      CR=1;fun_pwmr(cabs(par_speed));out_pwmr=1;
 299   3                  }
 300   2                  break;
 301   2              case mot_rl://左右轮同步
 302   2                  if((str_begin.leftsd==par_speed)&&(str_begin.rightsd==par_speed))
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 6   

 303   2                      return;
 304   2                  else
 305   2                      str_begin.leftsd=str_begin.rightsd=par_speed;
 306   2                  if(par_speed==0){
 307   3                      CR=0;
 308   3                      fun_pwmr(0);out_pwmr=0;
 309   3                      fun_pwml(0);out_pwml=0;
 310   3                  }
 311   2                  else if(par_speed>0){
 312   3                      CR=1;
 313   3                      fun_pwml(par_speed);out_pwml=0;
 314   3                      fun_pwmr(par_speed);out_pwmr=0;
 315   3                  }
 316   2                  else if(par_speed<0){
 317   3                      CR=1;
 318   3                      fun_pwml(cabs(par_speed));out_pwml=1;
 319   3                      fun_pwmr(cabs(par_speed));out_pwmr=1;
 320   3                  }
 321   2                  break;
 322   2              default:
 323   2                  break;
 324   2          }
 325   1      }//定时器操作左右轮
 326          void fun_sz(enum varENU_han par_model){
 327   1          if(str_begin.szzt==par_model)
 328   1              return;
 329   1          if(par_model==han_s){//手抓松
 330   2              #ifdef Debug
                          printf("fun_sz(han_s);\n");
                      #else
 333   2                  fun_motors(mot_sz,-100);
 334   2                  while(in_s==1);
 335   2              #endif
 336   2          }
 337   1          else{//手抓紧
 338   2              #ifdef Debug
                          printf("fun_sz(han_j);\n");
                      #else
 341   2                  fun_motors(mot_sz,100);
 342   2                  while(in_j==1);
 343   2              #endif
 344   2          }
 345   1              fun_delay(20,del_ms);
 346   1              fun_motors(mot_sz,0);
 347   1          str_begin.szzt=par_model;//存储运行结果
 348   1      }//手抓单步运动
 349          void fun_py(enum varENU_tra par_model){
 350   1          if(str_begin.pywz==par_model)
 351   1              return;
 352   1          switch(par_model){
 353   2              case tra_q://前平移(没有电机的呢个方向)
 354   2                  #ifdef Debug
                              printf("fun_py(tra_q);\n");
                          #else
 357   2                      fun_motors(mot_py,100);
 358   2                      while(in_qpy==1);
 359   2                      fun_delay(str_cod.py1bz,del_ms);
 360   2                  #endif
 361   2                      break;
 362   2              case tra_kq://靠前平移
 363   2                  #ifdef Debug
                              printf("fun_py(tra_kq);\n");
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 7   

                          #else
 366   2                      switch(str_begin.pywz){
 367   3                          case tra_q://现在在前面
 368   3                              fun_motors(mot_py,-100);
 369   3                              fun_delay(str_cod.py1qkq,del_ms);
 370   3                              break;
 371   3                          case tra_z://现在在中间
 372   3                              fun_motors(mot_py,100);
 373   3                              fun_delay(str_cod.py1kqz,del_ms);
 374   3                              break;
 375   3                          case tra_kh://现在在靠后
 376   3                              fun_motors(mot_py,100);
 377   3                              fun_delay(str_cod.py1khkq,del_ms);
 378   3                              break;
 379   3                          case tra_h://现在在后
 380   3                              fun_motors(mot_py,100);
 381   3                              fun_delay(str_cod.py1kqh,del_ms);
 382   3                              break;
 383   3                      }
 384   2                  #endif
 385   2                      break;
 386   2              case tra_z://平移到中间
 387   2                  #ifdef Debug
                              printf("fun_py(tra_z);\n");
                          #else
 390   2                      switch(str_begin.pywz){
 391   3                          case tra_q://现在在前面
 392   3                              fun_motors(mot_py,-100);
 393   3                              fun_delay(str_cod.py1qz,del_ms);
 394   3                              break;
 395   3                          case tra_kq://现在在靠前
 396   3                              fun_motors(mot_py,-100);
 397   3                              fun_delay(str_cod.py1kqz,del_ms);
 398   3                              break;
 399   3                          case tra_kh://现在在靠后
 400   3                              fun_motors(mot_py,100);
 401   3                              fun_delay(str_cod.py1zkh,del_ms);
 402   3                              break;
 403   3                          case tra_h://现在在后面
 404   3                              fun_motors(mot_py,100);
 405   3                              fun_delay(str_cod.py1zh,del_ms);
 406   3                              break;
 407   3                      }
 408   2                  #endif
 409   2                      break;
 410   2              case tra_kh://平移到靠后
 411   2                  #ifdef Debug
                              printf("fun_py(tra_kh);\n");
                          #else
 414   2                      switch(str_begin.pywz){
 415   3                          case tra_q://现在在前面
 416   3                              fun_motors(mot_py,-100);
 417   3                              fun_delay(str_cod.py1qkh,del_ms);
 418   3                              break;
 419   3                          case tra_kq://现在在靠前
 420   3                              fun_motors(mot_py,-100);
 421   3                              fun_delay(str_cod.py1kqkh,del_ms);
 422   3                              break;
 423   3                          case tra_z://现在在中间
 424   3                              fun_motors(mot_py,-100);
 425   3                              fun_delay(str_cod.py1zkh,del_ms);
 426   3                              break;
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 8   

 427   3                          case tra_h://现在在后面
 428   3                              fun_motors(mot_py,100);
 429   3                              fun_delay(str_cod.py1khh,del_ms);
 430   3                              break;
 431   3                      }
 432   2                  #endif
 433   2                      break;
 434   2              case tra_h://后平移(有电机的呢个方向)
 435   2                  #ifdef Debug
                              printf("fun_py(tra_h);\n");
                          #else
 438   2                      fun_motors(mot_py,-100);
 439   2                      while(in_hpy==1);
 440   2                      fun_delay(str_cod.py1bz,del_ms);
 441   2                  #endif
 442   2                      break;
 443   2              default:
 444   2                  break;
 445   2          }
 446   1          fun_motors(mot_py,0);
 447   1          str_begin.pywz=par_model;//存储运行结果
 448   1      }//平移单步运动
 449          void fun_sj(enum varENU_sjp par_model){
 450   1          if(str_begin.sjwz==par_model)
 451   1             return;
 452   1          def_select(sel_58)
 453   1          switch(par_model){
 454   2              case sjp_1://升降位置1(最上位)
 455   2                  #ifdef Debug
                              printf("fun_sj(sjp_1);\n");
                          #else
 458   2                      fun_motors(mot_sj,100);
 459   2                      def_select(sel_58);
 460   2                      while(in_wz1==1);
 461   2                      fun_delay(str_cod.sj1bzw,del_ms);
 462   2                  #endif
 463   2                      break;
 464   2              case sjp_12:
 465   2                  #ifdef Debug
                              printf("fun_sj(sjp_12);\n");
                          #else
 468   2                      if(par_model>str_begin.sjwz){
 469   3                          fun_motors(mot_sj,-100);
 470   3                          fun_delay(str_cod.sj1zjw,del_ms);
 471   3                      }
 472   2                      else{//要去的地方在上面，向上走
 473   3                          fun_sj(sjp_2);
 474   3                          fun_motors(mot_sj,100);
 475   3                          fun_delay(str_cod.sj1zjw,del_ms);
 476   3                      }
 477   2                  #endif
 478   2                      break;
 479   2              case sjp_2://升降位置2
 480   2                  #ifdef Debug
                              printf("fun_sj(sjp_2);\n");
                          #else
 483   2                      fun_motors(mot_sj,par_model<str_begin.sjwz?100:-100);
 484   2                      def_select(sel_58);
 485   2                      while(in_wz2==1);
 486   2                      fun_delay(str_cod.sj1bzw,del_ms);
 487   2                  #endif
 488   2                      break;
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 9   

 489   2              case sjp_23:
 490   2                  #ifdef Debug
                              printf("fun_sj(sjp_23);\n");
                          #else
 493   2                      if(par_model>str_begin.sjwz){
 494   3                          fun_sj(sjp_2);
 495   3                          fun_motors(mot_sj,-100);
 496   3                          fun_delay(str_cod.sj1zjw,del_ms);
 497   3                      }
 498   2                      else{//要去的地方在上面，向上走
 499   3                          fun_sj(sjp_3);
 500   3                          fun_motors(mot_sj,100);
 501   3                          fun_delay(str_cod.sj1zjw,del_ms);
 502   3                      }
 503   2                  #endif
 504   2                      break;
 505   2              case sjp_3://升降位置3
 506   2                  #ifdef Debug
                              printf("fun_sj(sjp_3);\n");
                          #else
 509   2                      fun_motors(mot_sj,par_model<str_begin.sjwz?100:-100);
 510   2                      def_select(sel_58);
 511   2                      while(in_wz3==1);
 512   2                      fun_delay(str_cod.sj1bzw,del_ms);
 513   2                  #endif
 514   2                  break;
 515   2              case sjp_34:
 516   2                  #ifdef Debug
                              printf("fun_sj(sjp_34);\n");
                          #else
 519   2                      if(par_model>str_begin.sjwz){
 520   3                          fun_sj(sjp_3);
 521   3                          fun_motors(mot_sj,-100);
 522   3                          fun_delay(str_cod.sj1zjw,del_ms);
 523   3                      }
 524   2                      else{//要去的地方在上面，向上走
 525   3                          fun_sj(sjp_4);
 526   3                          fun_motors(mot_sj,100);
 527   3                          fun_delay(str_cod.sj1zjw,del_ms);
 528   3                      }
 529   2                  #endif
 530   2                      break;
 531   2              case sjp_4://升降位置4
 532   2                  #ifdef Debug
                              printf("fun_sj(sjp_4);\n");
                          #else
 535   2                      fun_motors(mot_sj,par_model<str_begin.sjwz?100:-100);
 536   2                      def_select(sel_58);
 537   2                      while(in_wz4==1);
 538   2                      fun_delay(str_cod.sj1bzw,del_ms);
 539   2                  #endif
 540   2                      break;
 541   2              case sjp_45:
 542   2                  #ifdef Debug
                              printf("fun_sj(sjp_45);\n");
                          #else
 545   2                      if(par_model>str_begin.sjwz){
 546   3                          fun_sj(sjp_4);
 547   3                          fun_motors(mot_sj,-100);
 548   3                          fun_delay(str_cod.sj1zjw,del_ms);
 549   3                      }
 550   2                      else{//要去的地方在上面，向上走
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 10  

 551   3                          fun_motors(mot_sj,100);
 552   3                          fun_delay(str_cod.sj1zjw,del_ms);
 553   3                      }
 554   2                  #endif
 555   2                      break;
 556   2              case sjp_5://升降位置5
 557   2                  #ifdef Debug
                              printf("fun_sj(sjp_5);\n");
                          #else
 560   2                      fun_motors(mot_sj,-100);
 561   2                      def_select(sel_912);
 562   2                      while(in_wz5==1);
 563   2                      fun_delay(str_cod.sj1bzw,del_ms);
 564   2                  #endif
 565   2                      break;
 566   2              default:
 567   2                  break;
 568   2          }
 569   1          fun_motors(mot_sj,0);
 570   1          str_begin.sjwz=par_model;//存储运行结果
 571   1      }//升降单步运动
 572          void fun_hz(enum varENU_dir par_model){
 573   1          if(str_begin.hzfx==par_model)
 574   1              return;
 575   1          def_select(sel_912);
 576   1          switch(par_model){
 577   2              case dir_up://回转至前方
 578   2                  #ifdef Debug
                              printf("fun_hz(dir_up);\n");
                          #else
 581   2                      switch(str_begin.hzfx){
 582   3                          case dir_down://现在在下方
 583   3                              fun_motors(mot_hz,-100);
 584   3                              fun_delay(1,del_s);
 585   3                              while(in_hz==1);
 586   3                              while(in_hz==0);
 587   3                              while(in_hz==1);
 588   3                              fun_delay(str_cod.hz1bz,del_ms);
 589   3                              break;
 590   3                          case dir_left://现在在左边
 591   3                              fun_motors(mot_hz,100);
 592   3                              fun_delay(1,del_s);
 593   3                              while(in_hz==1);
 594   3                              fun_delay(str_cod.hz1bz,del_ms);
 595   3                              break;
 596   3                          case dir_right://现在在右边
 597   3                              fun_motors(mot_hz,-100);
 598   3                              fun_delay(1,del_s);
 599   3                              while(in_hz==1);
 600   3                              fun_delay(str_cod.hz1bz,del_ms);
 601   3                              break;
 602   3                          default:
 603   3                              break;
 604   3                      }
 605   2                  #endif
 606   2                      break;
 607   2              case dir_down://要去下面
 608   2                  #ifdef Debug
                              printf("fun_hz(dir_down);\n");
                          #else
 611   2                      switch(str_begin.hzfx){
 612   3                          case dir_up://现在在上面
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 11  

 613   3                              fun_motors(mot_hz,100);
 614   3                              fun_delay(1,del_s);
 615   3                              while(in_hz==1);
 616   3                              while(in_hz==0);
 617   3                              while(in_hz==1);
 618   3                              fun_delay(str_cod.hz1bz,del_ms);
 619   3                              break;
 620   3                          case dir_left://现在在左面
 621   3                              fun_motors(mot_hz,-100);
 622   3                              fun_delay(1,del_s);
 623   3                              while(in_hz==1);
 624   3                              fun_delay(str_cod.hz1bz,del_ms);
 625   3                              break;
 626   3                              break;
 627   3                          case dir_right://现在在右面
 628   3                              fun_motors(mot_hz,100);
 629   3                              fun_delay(1,del_s);
 630   3                              while(in_hz==1);
 631   3                              fun_delay(str_cod.hz1bz,del_ms);
 632   3                              break;
 633   3                          default:
 634   3                              break;
 635   3                      }
 636   2                  #endif
 637   2                      break;
 638   2              case dir_left://要去左边
 639   2                  #ifdef Debug
                              printf("fun_hz(dir_left);\n");
                          #else
 642   2                      switch(str_begin.hzfx){
 643   3                          case dir_up://现在在上面
 644   3                              fun_motors(mot_hz,-100);
 645   3                              fun_delay(1,del_s);
 646   3                              while(in_hz==1);
 647   3                              fun_delay(str_cod.hz1bz,del_ms);
 648   3                              break;
 649   3                              break;
 650   3                          case dir_down://现在在下面
 651   3                              fun_motors(mot_hz,100);
 652   3                              fun_delay(1,del_s);
 653   3                              while(in_hz==1);
 654   3                              fun_delay(str_cod.hz1bz,del_ms);
 655   3                              break;
 656   3                              break;
 657   3                          case dir_right://现在在右面
 658   3                              fun_motors(mot_hz,-100);
 659   3                              fun_delay(1,del_s);
 660   3                              while(in_hz==1);
 661   3                              while(in_hz==0);
 662   3                              while(in_hz==1);
 663   3                              fun_delay(str_cod.hz1bz,del_ms);
 664   3                              break;
 665   3                          default:
 666   3                              break;
 667   3                      }
 668   2                  #endif
 669   2                      break;
 670   2              case dir_right://要去右面
 671   2                  #ifdef Debug
                              printf("fun_hz(dir_right);\n");
                          #else
 674   2                      switch(str_begin.hzfx){
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 12  

 675   3                          case dir_up://现在在前面
 676   3                              fun_motors(mot_hz,100);
 677   3                              fun_delay(1,del_s);
 678   3                              while(in_hz==1);
 679   3                              fun_delay(str_cod.hz1bz,del_ms);
 680   3                              break;
 681   3                          case dir_down://现在在下面
 682   3                              fun_motors(mot_hz,-100);
 683   3                              fun_delay(1,del_s);
 684   3                              while(in_hz==1);
 685   3                              fun_delay(str_cod.hz1bz,del_ms);
 686   3                              break;
 687   3                          case dir_left://现在在左面
 688   3                              fun_motors(mot_hz,100);
 689   3                              fun_delay(1,del_s);
 690   3                              while(in_hz==1);
 691   3                              while(in_hz==0);
 692   3                              while(in_hz==1);
 693   3                              fun_delay(str_cod.hz1bz,del_ms);
 694   3                              break;
 695   3                          default:
 696   3                              break;
 697   3                      }
 698   2                  #endif
 699   2                      break;
 700   2              default:
 701   2                  break;
 702   2          }
 703   1          fun_motors(mot_hz,0);
 704   1          str_begin.hzfx=par_model;//存储运行结果
 705   1      }//回转单步运动
 706          void fun_pyhz(enum varENU_tra par_pymodel,enum varENU_dir par_hzmodel){
 707   1          switch(par_hzmodel){//获取想要到达的回转位置
 708   2              case dir_left://要去左边
 709   2                  switch(str_begin.hzfx){
 710   3                      case dir_right://现在在右边
 711   3                          fun_motors(mot_hz,-100);
 712   3                          break;
 713   3                      case dir_up://现在在上面
 714   3                          fun_motors(mot_hz,-100);
 715   3                          break;
 716   3                      case dir_down://现在在下面
 717   3                          fun_motors(mot_hz,100);
 718   3                          break;
 719   3                      default:
 720   3                          break;
 721   3                  }//获取现在回转所在的位置
 722   2                  break;
 723   2              case dir_right://要去右边
 724   2                  switch(str_begin.hzfx){
 725   3                      case dir_left://现在在左边
 726   3                          fun_motors(mot_hz,100);
 727   3                          break;
 728   3                      case dir_up://现在在上面
 729   3                          fun_motors(mot_hz,100);
 730   3                          break;
 731   3                      case dir_down://现在在下面
 732   3                          fun_motors(mot_hz,-100);
 733   3                          break;
 734   3                      default:
 735   3                          break;
 736   3                  }//获取现在回转所在的位置
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 13  

 737   2                  break;
 738   2              case dir_up://要去上面
 739   2                  switch(str_begin.hzfx){
 740   3                      case dir_left://现在在左边
 741   3                          fun_motors(mot_hz,100);
 742   3                          break;
 743   3                      case dir_right://现在在右边
 744   3                          fun_motors(mot_hz,-100);
 745   3                          break;
 746   3                      case dir_down://现在在下面
 747   3                          fun_motors(mot_hz,-100);
 748   3                          break;
 749   3                      default:
 750   3                          break;
 751   3                  }//获取现在回转所在的位置
 752   2                  break;
 753   2              case dir_down://要去下面
 754   2                  switch(str_begin.hzfx){
 755   3                      case dir_left://现在在左边
 756   3                          fun_motors(mot_hz,-100);
 757   3                          break;
 758   3                      case dir_right://现在在右边
 759   3                          fun_motors(mot_hz,100);
 760   3                          break;
 761   3                      case dir_up://现在在上面
 762   3                          fun_motors(mot_hz,100);
 763   3                          break;
 764   3                      default:
 765   3                          break;
 766   3                  }//获取现在回转所在的位置
 767   2                  break;
 768   2              default:
 769   2                  break;
 770   2          }//获取现在要去的回转位置
 771   1          switch(par_pymodel){
 772   2              case tra_q://前平移(没有电机的呢个方向)
 773   2                  fun_motors(mot_py,100);
 774   2                  while(in_qpy==1);
 775   2                  fun_delay(str_cod.py1bz,del_ms);
 776   2                  break;
 777   2              case tra_kq://靠前
 778   2                  switch(str_begin.pywz){
 779   3                      case tra_q://现在在前面
 780   3                          fun_motors(mot_py,-100);
 781   3                          fun_delay(str_cod.py1qkq,del_ms);
 782   3                          break;
 783   3                      case tra_z://现在在中间
 784   3                          fun_motors(mot_py,100);
 785   3                          fun_delay(str_cod.py1kqz,del_ms);
 786   3                          break;
 787   3                      case tra_kh://现在在靠后
 788   3                          fun_motors(mot_py,100);
 789   3                          fun_delay(str_cod.py1khkq,del_ms);
 790   3                          break;
 791   3                      case tra_h://现在在后面
 792   3                          fun_motors(mot_py,100);
 793   3                          fun_delay(str_cod.py1kqh,del_ms);
 794   3                          break;
 795   3                  }
 796   2                  break;
 797   2              case tra_z://中
 798   2                  switch(str_begin.pywz){
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 14  

 799   3                      case tra_q://现在在前面
 800   3                          fun_motors(mot_py,-100);
 801   3                          fun_delay(str_cod.py1qz,del_ms);
 802   3                          break;
 803   3                      case tra_kq://现在在靠前
 804   3                          fun_motors(mot_py,-100);
 805   3                          fun_delay(str_cod.py1kqz,del_ms);
 806   3                          break;
 807   3                      case tra_kh://现在在靠后
 808   3                          fun_motors(mot_py,100);
 809   3                          fun_delay(str_cod.py1zkh,del_ms);
 810   3                          break;
 811   3                      case tra_h://现在在后面
 812   3                          fun_motors(mot_py,100);
 813   3                          fun_delay(str_cod.py1zh,del_ms);
 814   3                          break;
 815   3                  }
 816   2                  break;
 817   2              case tra_kh://靠后
 818   2                  switch(str_begin.pywz){
 819   3                      case tra_q://现在在前面
 820   3                          fun_motors(mot_py,-100);
 821   3                          fun_delay(str_cod.py1qkh,del_ms);
 822   3                          break;
 823   3                      case tra_kq://现在在靠前
 824   3                          fun_motors(mot_py,-100);
 825   3                          fun_delay(str_cod.py1kqkh,del_ms);
 826   3                          break;
 827   3                      case tra_z://现在在中间
 828   3                          fun_motors(mot_py,-100);
 829   3                          fun_delay(str_cod.py1zkh,del_ms);
 830   3                          break;
 831   3                      case tra_h://现在在后面
 832   3                          fun_motors(mot_py,100);
 833   3                          fun_delay(str_cod.py1khh,del_ms);
 834   3                          break;
 835   3                  }
 836   2                  break;
 837   2              case tra_h://后平移(有电机的呢个方向)
 838   2                  fun_motors(mot_py,-100);
 839   2                  while(in_hpy==1);
 840   2                  fun_delay(str_cod.py1bz,del_ms);
 841   2                  break;
 842   2              default:
 843   2                  break;
 844   2          }//获取现在平移所在的位置
 845   1          fun_motors(mot_py,0);//停止平移动作
 846   1          def_select(sel_912)//传感器片选
 847   1          str_begin.pywz=par_pymodel;//存储运行结果
 848   1          switch(par_hzmodel){//获取想要到达的回转位置
 849   2              case dir_up://回转至前方
 850   2                  switch(str_begin.hzfx){
 851   3                      case dir_down://现在在下方
 852   3                          while(in_hz==1);
 853   3                          while(in_hz==0);
 854   3                          while(in_hz==1);
 855   3                          fun_delay(str_cod.hz1bz,del_ms);
 856   3                          break;
 857   3                      case dir_left://现在在左边
 858   3                          while(in_hz==1);
 859   3                          fun_delay(str_cod.hz1bz,del_ms);
 860   3                          break;
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 15  

 861   3                      case dir_right://现在在右边
 862   3                          while(in_hz==1);
 863   3                          fun_delay(str_cod.hz1bz,del_ms);
 864   3                          break;
 865   3                      default:
 866   3                          break;
 867   3                  }
 868   2                  break;
 869   2              case dir_down://要去下面
 870   2                  switch(str_begin.hzfx){
 871   3                      case dir_up://现在在上面
 872   3                          while(in_hz==1);
 873   3                          while(in_hz==0);
 874   3                          while(in_hz==1);
 875   3                          fun_delay(str_cod.hz1bz,del_ms);
 876   3                          break;
 877   3                      case dir_left://现在在左面
 878   3                          while(in_hz==1);
 879   3                          fun_delay(str_cod.hz1bz,del_ms);
 880   3                          break;
 881   3                      case dir_right://现在在右面
 882   3                          while(in_hz==1);
 883   3                          fun_delay(str_cod.hz1bz,del_ms);
 884   3                          break;
 885   3                      default:
 886   3                          break;
 887   3                  }
 888   2                  break;
 889   2              case dir_left://要去左边
 890   2                  switch(str_begin.hzfx){
 891   3                      case dir_up://现在在上面
 892   3                          while(in_hz==1);
 893   3                          fun_delay(str_cod.hz1bz,del_ms);
 894   3                          break;
 895   3                      case dir_down://现在在下面
 896   3                          while(in_hz==1);
 897   3                          fun_delay(str_cod.hz1bz,del_ms);
 898   3                          break;
 899   3                      case dir_right://现在在右面
 900   3                          while(in_hz==1);
 901   3                          while(in_hz==0);
 902   3                          while(in_hz==1);
 903   3                          fun_delay(str_cod.hz1bz,del_ms);
 904   3                          break;
 905   3                      default:
 906   3                          break;
 907   3                  }
 908   2                  break;
 909   2              case dir_right://要去右面
 910   2                  switch(str_begin.hzfx){
 911   3                      case dir_up://现在在前面
 912   3                          while(in_hz==1);
 913   3                          fun_delay(str_cod.hz1bz,del_ms);
 914   3                          break;
 915   3                      case dir_down://现在在下面
 916   3                          while(in_hz==1);
 917   3                          fun_delay(str_cod.hz1bz,del_ms);
 918   3                          break;
 919   3                      case dir_left://现在在左面
 920   3                          while(in_hz==1);
 921   3                          while(in_hz==0);
 922   3                          while(in_hz==1);
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 16  

 923   3                          fun_delay(str_cod.hz1bz,del_ms);
 924   3                          break;
 925   3                      default:
 926   3                          break;
 927   3                  }
 928   2                  break;
 929   2              default:
 930   2                  break;
 931   2          }//获取现在要去的回转位置
 932   1          fun_motors(mot_hz,0);//停止回转动作
 933   1          str_begin.hzfx=par_hzmodel;//存储运行结果
 934   1      }//平移回转同步运动
 935          // void fun_sjhz(enum varENU_tra par_sjmodel,enum varENU_dir par_hzmodel){
 936          //     switch(par_hzmodel){//获取想要到达的回转位置
 937          //         case dir_left://要去左边
 938          //             switch(str_begin.hzfx){
 939          //                 case dir_right://现在在右边
 940          //                     fun_motors(mot_hz,-100);
 941          //                     break;
 942          //                 case dir_up://现在在上面
 943          //                     fun_motors(mot_hz,-100);
 944          //                     break;
 945          //                 case dir_down://现在在下面
 946          //                     fun_motors(mot_hz,100);
 947          //                     break;
 948          //                 default:
 949          //                     break;
 950          //             }//获取现在回转所在的位置
 951          //             break;
 952          //         case dir_right://要去右边
 953          //             switch(str_begin.hzfx){
 954          //                 case dir_left://现在在左边
 955          //                     fun_motors(mot_hz,100);
 956          //                     break;
 957          //                 case dir_up://现在在上面
 958          //                     fun_motors(mot_hz,100);
 959          //                     break;
 960          //                 case dir_down://现在在下面
 961          //                     fun_motors(mot_hz,-100);
 962          //                     break;
 963          //                 default:
 964          //                     break;
 965          //             }//获取现在回转所在的位置
 966          //             break;
 967          //         case dir_up://要去上面
 968          //             switch(str_begin.hzfx){
 969          //                 case dir_left://现在在左边
 970          //                     fun_motors(mot_hz,100);
 971          //                     break;
 972          //                 case dir_right://现在在右边
 973          //                     fun_motors(mot_hz,-100);
 974          //                     break;
 975          //                 case dir_down://现在在下面
 976          //                     fun_motors(mot_hz,-100);
 977          //                     break;
 978          //                 default:
 979          //                     break;
 980          //             }//获取现在回转所在的位置
 981          //             break;
 982          //         case dir_down://要去下面
 983          //             switch(str_begin.hzfx){
 984          //                 case dir_left://现在在左边
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 17  

 985          //                     fun_motors(mot_hz,-100);
 986          //                     break;
 987          //                 case dir_right://现在在右边
 988          //                     fun_motors(mot_hz,100);
 989          //                     break;
 990          //                 case dir_up://现在在上面
 991          //                     fun_motors(mot_hz,100);
 992          //                     break;
 993          //                 default:
 994          //                     break;
 995          //             }//获取现在回转所在的位置
 996          //             break;
 997          //         default:
 998          //             break;
 999          //     }//获取现在要去的回转位置
1000          //     switch(par_model){
1001          //         case sjp_1://升降位置1(最上位)
1002          //                 fun_motors(mot_sj,100);
1003          //                 def_select(sel_58);
1004          //                 while(in_wz1==1);
1005          //                 fun_delay(str_cod.sj1bzw,del_ms);
1006          //                 break;
1007          //         case sjp_12:
1008          //                 if(par_model>str_begin.sjwz){
1009          //                     fun_motors(mot_sj,-100);
1010          //                     fun_delay(str_cod.sj1zjw,del_ms);
1011          //                 }
1012          //                 else{//要去的地方在上面，向上走
1013          //                     fun_sj(sjp_2);
1014          //                     fun_motors(mot_sj,100);
1015          //                     fun_delay(str_cod.sj1zjw,del_ms);
1016          //                 }
1017          //                 break;
1018          //         case sjp_2://升降位置2
1019          //                 fun_motors(mot_sj,par_model<str_begin.sjwz?100:-100);
1020          //                 def_select(sel_58);
1021          //                 while(in_wz2==1);
1022          //                 fun_delay(str_cod.sj1bzw,del_ms);
1023          //                 break;
1024          //         case sjp_23:
1025          //                 if(par_model>str_begin.sjwz){
1026          //                     fun_sj(sjp_2);
1027          //                     fun_motors(mot_sj,-100);
1028          //                     fun_delay(str_cod.sj1zjw,del_ms);
1029          //                 }
1030          //                 else{//要去的地方在上面，向上走
1031          //                     fun_sj(sjp_3);
1032          //                     fun_motors(mot_sj,100);
1033          //                     fun_delay(str_cod.sj1zjw,del_ms);
1034          //                 }
1035          //                 break;
1036          //         case sjp_3://升降位置3
1037          //                 fun_motors(mot_sj,par_model<str_begin.sjwz?100:-100);
1038          //                 def_select(sel_58);
1039          //                 while(in_wz3==1);
1040          //                 fun_delay(str_cod.sj1bzw,del_ms);
1041          //             break;
1042          //         case sjp_34:
1043          //                 if(par_model>str_begin.sjwz){
1044          //                     fun_sj(sjp_3);
1045          //                     fun_motors(mot_sj,-100);
1046          //                     fun_delay(str_cod.sj1zjw,del_ms);
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 18  

1047          //                 }
1048          //                 else{//要去的地方在上面，向上走
1049          //                     fun_sj(sjp_4);
1050          //                     fun_motors(mot_sj,100);
1051          //                     fun_delay(str_cod.sj1zjw,del_ms);
1052          //                 }
1053          //                 break;
1054          //         case sjp_4://升降位置4
1055          //                 fun_motors(mot_sj,par_model<str_begin.sjwz?100:-100);
1056          //                 def_select(sel_58);
1057          //                 while(in_wz4==1);
1058          //                 fun_delay(str_cod.sj1bzw,del_ms);
1059          //                 break;
1060          //         case sjp_45:
1061          //                 if(par_model>str_begin.sjwz){
1062          //                     fun_sj(sjp_4);
1063          //                     fun_motors(mot_sj,-100);
1064          //                     fun_delay(str_cod.sj1zjw,del_ms);
1065          //                 }
1066          //                 else{//要去的地方在上面，向上走
1067          //                     fun_motors(mot_sj,100);
1068          //                     fun_delay(str_cod.sj1zjw,del_ms);
1069          //                 }
1070          //                 break;
1071          //         case sjp_5://升降位置5
1072          //                 fun_motors(mot_sj,-100);
1073          //                 break;
1074          //         default:
1075          //             break;
1076          //     }
1077          // }//升降回转同步运动
1078          void fun_jtjp(){
1079   1          while(1){
1080   2              if((!in_ls1&&!in_ls2&&in_ls4&&in_ls5&&!in_ls7&&!in_ls8)&&((in_ls3&&in_ls6)||(!in_ls3&&!in_ls6))){
1081   3                  fun_delay(10,del_ms);
1082   3                  fun_motors(mot_rl,0);
1083   3                  return;
1084   3              }
1085   2              if(in_ls2||in_ls1){
1086   3                  fun_motors(mot_l,16);
1087   3                  fun_motors(mot_r,-16);
1088   3              }
1089   2              else if(in_ls7||in_ls8){
1090   3                  fun_motors(mot_l,-16);
1091   3                  fun_motors(mot_r,16);
1092   3              }
1093   2              else{
1094   3                  if(!in_ls4){
1095   4                      fun_motors(mot_l,-12);
1096   4                      fun_motors(mot_r,12);
1097   4                  }
1098   3                  else if(!in_ls5){
1099   4                      fun_motors(mot_l,12);
1100   4                      fun_motors(mot_r,-12);
1101   4                  }
1102   3                  else{
1103   4                      if(in_ls6&&!in_ls3){
1104   5                          fun_motors(mot_l,-8);
1105   5                          fun_motors(mot_r,8);
1106   5                      }
1107   4                      if(in_ls3&&!in_ls6){
1108   5                          fun_motors(mot_l,8);
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 19  

1109   5                          fun_motors(mot_r,-8);
1110   5                      }
1111   4                  }
1112   3              }
1113   2          }
1114   1      }//静态纠偏
1115          void fun_timermove(){
1116   1          static uc loc_con=0;//需要分步做的动作需要用到此静态私有分步标志位
1117   1          int loc_sdl,loc_sdr;//左轮速度和右轮速度的局部变量
1118   1          switch(*str_tfl.run){//选择运行方式
1119   2              case def_end://运行结束
1120   2                  fun_motorsrl(mot_rl,0);//再次停止电机运动
1121   2                  str_tfl.doing=tf_false;//移动结束
1122   2                  memset(str_tfl.step,0,sizeof(str_tfl.step));//清空step数组
1123   2                  str_tfl.run=str_tfl.step;//指针指向step的第一个元素
1124   2                  break;
1125   2              case tfl_line://运行巡线
1126   2                  if(*(str_tfl.run+1)){//如果参数为非0数
1127   3                      if((in_ls1||in_ls8)&&(in_ls2&&in_ls3&&in_ls4&&in_ls5&in_ls6&&in_ls7)){//如果中间6个
             -全亮,左右亮任意一个
1128   4                          str_tfl.online=tf_ture;//标志位记录在线
1129   4                          fun_motorsrl(mot_rl,str_tfl.gospeed);//按照常规速度过线
1130   4                      }
1131   3                      else if(str_tfl.online==tf_ture){//如果标志位记录在线,而且不符合在线特征
1132   4                          str_tfl.online=tf_false;//标志位记录不在线
1133   4                          (*(str_tfl.run+1))--;//参数值减1,记录已经走了一条线
1134   4                      }
1135   3                      else{
1136   4                          loc_sdl=loc_sdr=str_tfl.gospeed;//巡线速度为str_tfl.gospeed
1137   4                          if(in_ls3&&!in_ls6){//3亮6不亮
1138   5                              loc_sdl-=loc_sdl/10;
1139   5                              loc_sdr+=(100-loc_sdr)/10;
1140   5                          }//向左转
1141   4                          if(in_ls6&&!in_ls3){//6亮3不亮
1142   5                              loc_sdl+=(100-loc_sdl)/10;
1143   5                              loc_sdr-=loc_sdr/10;
1144   5                          }//向右转
1145   4                          if(in_ls2&&!in_ls7){//2亮7不亮
1146   5                              loc_sdl-=loc_sdl/10*3;
1147   5                              loc_sdr+=(100-loc_sdr)/10*3;
1148   5                          }//向左转
1149   4                          if(in_ls7&&!in_ls2){//7亮2不亮
1150   5                              loc_sdl+=(100-loc_sdl)/10*3;
1151   5                              loc_sdr-=loc_sdr/10*3;
1152   5                          }//向右转
1153   4                          if(in_ls1&&!in_ls8){//1亮8不亮
1154   5                              loc_sdl-=loc_sdl/10*5;
1155   5                              loc_sdr+=(100-loc_sdr)/10*5;
1156   5                          }//向左转
1157   4                          if(in_ls8&&!in_ls1){//8亮1不亮
1158   5                              loc_sdl+=(100-loc_sdl)/10*5;
1159   5                              loc_sdr-=loc_sdr/10*5;
1160   5                          }//向右转
1161   4                          fun_motorsrl(mot_r,loc_sdr);
1162   4                          fun_motorsrl(mot_l,loc_sdl);
1163   4                      }
1164   3                  }
1165   2                  else{//如果线走完了
1166   3                      str_tfl.run+=2;//指针指向下一组过程
1167   3                      fun_motorsrl(mot_rl,0);//停止电机运动
1168   3                  }
1169   2                  break;
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 20  

1170   2              case tfl_turn://运行转弯
1171   2                  switch(loc_con){//分步运行标志位
1172   3                      case 0://第一步
1173   3                          switch(*(str_tfl.run+1)){//获取参数
1174   4                              case tur_r90://右转90
1175   4                                  fun_motorsrl(mot_l,str_tfl.turnspeed);//左轮向前
1176   4                                  fun_motorsrl(mot_r,-str_tfl.turnspeed);//右轮向后
1177   4                                  str_tfl.delay=var_timer+str_cod.turn90;//计时
1178   4                                  break;
1179   4                              case tur_l90://左转90
1180   4                                  fun_motorsrl(mot_l,-str_tfl.turnspeed);//左轮向后
1181   4                                  fun_motorsrl(mot_r,str_tfl.turnspeed);//右轮向前
1182   4                                  str_tfl.delay=var_timer+str_cod.turn90;//计时
1183   4                                  break;
1184   4                              case tur_r180://右转180
1185   4                                  fun_motorsrl(mot_l,str_tfl.turnspeed);//左轮向前
1186   4                                  fun_motorsrl(mot_r,-str_tfl.turnspeed);//右轮向后
1187   4                                  str_tfl.delay=var_timer+str_cod.turn180;//计时
1188   4                                  break;
1189   4                              case tur_l180://左转180
1190   4                                  fun_motorsrl(mot_l,-str_tfl.turnspeed);//左轮向后
1191   4                                  fun_motorsrl(mot_r,str_tfl.turnspeed);//左轮向前
1192   4                                  str_tfl.delay=var_timer+str_cod.turn180;//计时
1193   4                                  break;
1194   4                          }
1195   3                          loc_con++;//执行下一步
1196   3                          break;
1197   3                      case 1://第二步
1198   3                          if(str_tfl.delay<=var_timer)//计时时间到
1199   3                              loc_con++;//执行下一步
1200   3                          break;
1201   3                      case 2://第三步
1202   3                          if(in_ls4&&in_ls5){//如果中间两个灯亮
1203   4                              fun_motorsrl(mot_rl,0);//停止电机
1204   4                              str_tfl.run+=2;//指针指向下一组过程
1205   4                              str_tfl.delay=0;//延时计数器归零
1206   4                              loc_con=0;//分步运行标志位归零
1207   4                          }
1208   3                          break;
1209   3                  }
1210   2                  break;
1211   2              case tfl_cache://运行前冲
1212   2                  switch(loc_con){
1213   3                      case 0://第一步
1214   3                          str_tfl.delay=var_timer+((*(str_tfl.run+1))*10);//延时时间(毫秒)为参数的10
             -
1215   3                          loc_con++;//执行下一步
1216   3                          break;
1217   3                      case 1://第二步
1218   3                          if(str_tfl.delay<=var_timer){//计时时间到
1219   4                              fun_motorsrl(mot_rl,0);//停止电机
1220   4                              str_tfl.run+=2;//指针指向下一组过程
1221   4                              str_tfl.delay=0;//延时计数器归零
1222   4                              loc_con=0;//分步运行标志位归零
1223   4                          }
1224   3                          else{
1225   4                              loc_sdl=loc_sdr=str_tfl.cachespeed;//前冲速度为str_tfl.cachespeed
1226   4                              if(in_ls1&&!in_ls8){//1亮8不亮
1227   5                                  loc_sdl*=0.5;//左减速
1228   5                                  loc_sdr*=1.5;//右加速
1229   5                              }//向左转
1230   4                              if(in_ls8&&!in_ls1){//8亮1不亮
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 21  

1231   5                                  loc_sdl*=1.5;//左加速
1232   5                                  loc_sdr*=0.5;//右减速
1233   5                              }//向右转
1234   4                              if(in_ls2&&!in_ls7){//2亮7不亮
1235   5                                  loc_sdl*=0.7;//左减速
1236   5                                  loc_sdr*=1.3;//右加速
1237   5                              }//向左转
1238   4                              if(in_ls7&&!in_ls2){//7亮2不亮
1239   5                                  loc_sdl*=1.3;//左加速
1240   5                                  loc_sdr*=0.7;//右减速
1241   5                              }//向右转
1242   4                              if(in_ls3&&!in_ls6){//3亮6不亮
1243   5                                  loc_sdl*=0.9;//左减速
1244   5                                  loc_sdr*=1.1;//右加速
1245   5                              }//向左转
1246   4                              if(in_ls6&&!in_ls3){//6亮3不亮
1247   5                                  loc_sdl*=1.1;//左加速
1248   5                                  loc_sdr*=0.9;//右减速
1249   5                              }//向右转
1250   4                              fun_motorsrl(mot_r,loc_sdr);
1251   4                              fun_motorsrl(mot_l,loc_sdl);
1252   4                          }
1253   3                          break;
1254   3                  }
1255   2                  break;
1256   2              case tfl_start://运行带加速的前冲
1257   2      
1258   2                  break;
1259   2              case tfl_end://运行带减速的前冲
1260   2      
1261   2                  break;
1262   2          }
1263   1      }//定时器移动
1264          void fun_folline(uc par_con,uc par_speed){
1265   1          uc loc_con=par_con;//巡线条数标志位
1266   1          uc loc_sdr,loc_sdl;//左右轮速度
1267   1          uc loc_online;//在线标志位
1268   1          while(loc_con){
1269   2              if((in_ls1||in_ls8)&&(in_ls2&&in_ls3&&in_ls4&&in_ls5&in_ls6&&in_ls7)){//如果中间6个灯全亮,
             -左右亮任意一个
1270   3                  loc_online=tf_ture;//标志位记录在线
1271   3                  fun_motors(mot_rl,par_speed);//按照常规速度过线
1272   3              }
1273   2              else if(loc_online==tf_ture){//如果标志位记录在线,而且不符合在线特征
1274   3                  loc_online=tf_false;//标志位记录不在线
1275   3                  loc_con--;//参数值减1,记录已经走了一条线
1276   3              }
1277   2              else{
1278   3                  loc_sdr=loc_sdl=par_speed;
1279   3                  if(in_ls3&&!in_ls6){//3亮6不亮
1280   4                      loc_sdl-=loc_sdl/10;
1281   4                      loc_sdr+=(100-loc_sdr)/10;
1282   4                  }//向左转
1283   3                  if(in_ls6&&!in_ls3){//6亮3不亮
1284   4                      loc_sdl+=(100-loc_sdl)/10;
1285   4                      loc_sdr-=loc_sdr/10;
1286   4                  }//向右转
1287   3                  if(in_ls2&&!in_ls7){//2亮7不亮
1288   4                      loc_sdl-=loc_sdl/10*3;
1289   4                      loc_sdr+=(100-loc_sdr)/10*3;
1290   4                  }//向左转
1291   3                  if(in_ls7&&!in_ls2){//7亮2不亮
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 22  

1292   4                      loc_sdl+=(100-loc_sdl)/10*3;
1293   4                      loc_sdr-=loc_sdr/10*3;
1294   4                  }//向右转
1295   3                  if(in_ls1&&!in_ls8){//1亮8不亮
1296   4                      loc_sdl-=loc_sdl/10*5;
1297   4                      loc_sdr+=(100-loc_sdr)/10*5;
1298   4                  }//向左转
1299   3                  if(in_ls8&&!in_ls1){//8亮1不亮
1300   4                      loc_sdl+=(100-loc_sdl)/10*5;
1301   4                      loc_sdr-=loc_sdr/10*5;
1302   4                  }//向右转
1303   3                  fun_motors(mot_r,loc_sdr);
1304   3                  fun_motors(mot_l,loc_sdl);
1305   3                  fun_delay(1,del_ms);
1306   3              }
1307   2          }//如果巡线条数不为0
1308   1          fun_qc(65,40);
1309   1      }//主函数巡线
1310          void fun_turn(enum varENU_tur par_model,uc par_speed){
1311   1          switch(par_model){//获取参数
1312   2              case tur_r90://右转90
1313   2                  fun_motors(mot_l,par_speed);//左轮向前
1314   2                  fun_motors(mot_r,-par_speed);//右轮向后
1315   2                  fun_delay(str_cod.turn90,del_ms);//计时
1316   2                  break;
1317   2              case tur_l90://左转90
1318   2                  fun_motors(mot_l,-par_speed);//左轮向后
1319   2                  fun_motors(mot_r,par_speed);//右轮向前
1320   2                  fun_delay(str_cod.turn90,del_ms);//计时
1321   2                  break;
1322   2              case tur_r180://右转180
1323   2                  fun_motors(mot_l,par_speed);//左轮向前
1324   2                  fun_motors(mot_r,-par_speed);//右轮向后
1325   2                  fun_delay(str_cod.turn180,del_ms);//计时
1326   2                  break;
1327   2              case tur_l180://左转180
1328   2                  fun_motors(mot_l,-par_speed);//左轮向后
1329   2                  fun_motors(mot_r,par_speed);//左轮向前
1330   2                  fun_delay(str_cod.turn180,del_ms);//计时
1331   2                  break;
1332   2          }
1333   1          while(!in_ls4||!in_ls5);
1334   1          fun_motors(mot_rl,0);//停止电机
1335   1      }//主函数转弯
1336          void fun_qc(uc par_time,uc par_speed){
1337   1          uc loc_sdr,loc_sdl;//左右轮速度
1338   1          str_tfl.delay=var_timer+par_time*10;//延时时间(毫秒)为参数的10倍
1339   1          while(str_tfl.delay>var_timer){
1340   2              loc_sdr=loc_sdl=par_speed;
1341   2              if(in_ls1&&!in_ls8){//1亮8不亮
1342   3                  loc_sdl*=0.7;//左减速
1343   3                  loc_sdr*=1.3;//右加速
1344   3              }//向左转
1345   2              if(in_ls8&&!in_ls1){//8亮1不亮
1346   3                  loc_sdl*=1.3;//左加速
1347   3                  loc_sdr*=0.7;//右减速
1348   3              }//向右转
1349   2              if(in_ls2&&!in_ls7){//2亮7不亮
1350   3                  loc_sdl*=0.8;//左减速
1351   3                  loc_sdr*=1.2;//右加速
1352   3              }//向左转
1353   2              if(in_ls7&&!in_ls2){//7亮2不亮
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 23  

1354   3                  loc_sdl*=1.2;//左加速
1355   3                  loc_sdr*=0.8;//右减速
1356   3              }//向右转
1357   2              if(in_ls3&&!in_ls6){//3亮6不亮
1358   3                  loc_sdl*=0.9;//左减速
1359   3                  loc_sdr*=1.1;//右加速
1360   3              }//向左转
1361   2              if(in_ls6&&!in_ls3){//6亮3不亮
1362   3                  loc_sdl*=1.1;//左加速
1363   3                  loc_sdr*=0.9;//右减速
1364   3              }//向右转
1365   2              fun_motors(mot_r,loc_sdr);
1366   2              fun_motors(mot_l,loc_sdl);
1367   2              fun_delay(1,del_ms);
1368   2          }
1369   1          fun_motors(mot_rl,0);//停止电机
1370   1      }//主函数前冲
1371          void fun_stope2prom(){
1372   1          IAP_CONTR = 0;                  //关闭IAP功能
1373   1          IAP_CMD = 0;                    //清除命令
1374   1          IAP_TRIG = 0;                   //清除触发寄存器
1375   1          IAP_ADDRH = 0x80;               //数据指针指向非EEPROM区
1376   1          IAP_ADDRL = 0;                  //清除IAP地址
1377   1      }//关闭EEPROM功能(IapIdle)
1378          uc fun_reade2prom(ui par_add){
1379   1          uc loc_dat;                     //数据缓冲区
1380   1          IAP_CONTR = 0x83;               //打开EEPROM功能,设置等待时间
1381   1          IAP_CMD = 1;                    //设置EEPROM读命令
1382   1          IAP_ADDRL = par_add;            //设置EEPROM地址低八位
1383   1          IAP_ADDRH = par_add >> 8;       //设置EEPROM地址高八位
1384   1          IAP_TRIG = 0x5a;                //触发
1385   1          IAP_TRIG = 0xa5;                //再次触发
1386   1          fun_delay(10,del_us);           //稍等一会儿
1387   1          loc_dat = IAP_DATA;             //读出EEPROM中的数据
1388   1          fun_stope2prom();               //关闭EEPROM功能
1389   1          return loc_dat;                 //返回读取结果
1390   1      }//读取EEPROM数据
1391          void fun_writee2prom(ui par_add,uc par_dat){
1392   1          IAP_CONTR = 0x83;               //打开EEPROM功能,设置等待时间
1393   1          IAP_CMD = 2;                    //设置EEPROM写入命令
1394   1          IAP_ADDRL = par_add;            //设置EEPROM地址低八位
1395   1          IAP_ADDRH = par_add >> 8;       //设置EEPROM地址高八位
1396   1          IAP_DATA = par_dat;             //写入数据
1397   1          IAP_TRIG = 0x5a;                //触发
1398   1          IAP_TRIG = 0xa5;                //再次触发
1399   1          fun_delay(10,del_us);           //稍等一会儿
1400   1          fun_stope2prom();               //关闭EEPROM功能
1401   1      }//写EEPROM数据
1402          void fun_cleane2prom(ui par_add){
1403   1          IAP_CONTR = 0x83;               //打开EEPROM功能,设置等待时间
1404   1          IAP_CMD = 3;                    //设置EEPROM擦除命令
1405   1          IAP_ADDRL = par_add;            //设置EEPROM地址低八位
1406   1          IAP_ADDRH = par_add >> 8;       //设置EEPROM地址高八位
1407   1          IAP_TRIG = 0x5a;                //触发
1408   1          IAP_TRIG = 0xa5;                //再次触发
1409   1          fun_delay(10,del_us);           //稍等一会儿
1410   1          fun_stope2prom();               //关闭EEPROM功能
1411   1      }//清除EEPROM数据
1412          void fun_calibration(){
1413   1          // fun_sj(sjp_1);//升到最上位
1414   1          ul loc_time;
1415   1          fun_py(tra_q);//移动到最前端
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 24  

1416   1          fun_py(tra_h);//移动到最后端
1417   1          loc_time=var_timer;
1418   1          fun_py(tra_q);//移动到前端并计时
1419   1          fun_py(tra_h);//移动到后端
1420   1          loc_time=var_timer-loc_time;
1421   1          loc_time*=0.5;
1422   1          str_cod.py1zh=loc_time*0.5;//从后到中间
1423   1          str_cod.py1qz=loc_time*0.5;//从前到中间
1424   1          str_cod.py1qkh=loc_time*0.75;//从前到靠后
1425   1          str_cod.py1kqh=loc_time*0.564;//从靠前到后
1426   1          str_cod.py1qkq=loc_time*0.34;//从前到靠前
1427   1          str_cod.py1khh=loc_time*0.2701;//从后到靠后
1428   1          str_cod.py1kqz=loc_time*0.189;//从靠前到中间
1429   1          str_cod.py1zkh=loc_time*0.20;//从靠后到中间
1430   1          str_cod.py1kqkh=loc_time*0.5;//从靠前到靠后
1431   1          str_cod.py1khkq=loc_time*0.5;//从靠后到靠前
1432   1      }//自动校准平移参数
1433          void fun_port(){
1434   1          //19200bps@12.000MHz
1435   1          PCON |= 0x80;       //使能波特率倍速位SMOD
1436   1          SCON = 0x50;        //8位数据,可变波特率
1437   1          AUXR |= 0x04;       //独立波特率发生器时钟为Fosc,即1T
1438   1          BRT = 0xD9;         //设定独立波特率发生器重装值
1439   1          AUXR |= 0x01;       //串口1选择独立波特率发生器为波特率发生器
1440   1          AUXR |= 0x10;       //启动独立波特率发生器
1441   1      }//串口初始化
1442          void fun_test(){
1443   1          fun_sz(han_j);
1444   1          fun_delay(1,del_s);
1445   1          fun_sz(han_s);
1446   1          fun_delay(1,del_s);
1447   1          fun_sz(han_j);
1448   1          fun_delay(1,del_s);
1449   1          fun_sz(han_s);
1450   1          fun_delay(1,del_s);
1451   1      
1452   1          str_begin.pywz=tra_h;
1453   1          fun_py(tra_q);
1454   1          fun_delay(1,del_s);
1455   1          fun_py(tra_h);
1456   1          fun_delay(1,del_s);
1457   1          fun_py(tra_q);
1458   1          fun_delay(1,del_s);
1459   1          fun_py(tra_h);
1460   1          fun_delay(1,del_s);
1461   1      
1462   1          fun_sj(sjp_1);
1463   1          fun_delay(1,del_s);
1464   1          fun_sj(sjp_2);
1465   1          fun_delay(1,del_s);
1466   1          fun_sj(sjp_3);
1467   1          fun_delay(1,del_s);
1468   1          fun_sj(sjp_4);
1469   1          fun_delay(1,del_s);
1470   1          fun_sj(sjp_5);
1471   1          fun_delay(1,del_s);
1472   1          fun_sj(sjp_4);
1473   1          fun_delay(1,del_s);
1474   1          fun_sj(sjp_3);
1475   1          fun_delay(1,del_s);
1476   1          fun_sj(sjp_2);
1477   1          fun_delay(1,del_s);
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 25  

1478   1          fun_sj(sjp_1);
1479   1      
1480   1          str_now.hzfx=str_begin.hzfx;
1481   1          str_begin.hzfx=dir_up;
1482   1          fun_hz(dir_right);
1483   1          fun_delay(1,del_s);
1484   1          fun_hz(dir_up);
1485   1          fun_delay(1,del_s);
1486   1          fun_hz(dir_right);
1487   1          fun_delay(1,del_s);
1488   1          fun_hz(dir_up);
1489   1          fun_delay(1,del_s);
1490   1          str_begin.hzfx=str_now.hzfx;
1491   1      
1492   1          fun_motors(mot_rl,60);
1493   1          fun_delay(1,del_s);
1494   1          fun_motors(mot_rl,0);
1495   1          fun_delay(1,del_s);
1496   1      
1497   1          fun_motors(mot_rl,-60);
1498   1          fun_delay(1,del_s);
1499   1          fun_motors(mot_rl,0);
1500   1          fun_delay(1,del_s);
1501   1      
1502   1          fun_motors(mot_r,40);
1503   1          fun_motors(mot_l,-40);
1504   1          fun_delay(1,del_s);
1505   1          fun_motors(mot_rl,0);
1506   1          fun_delay(1,del_s);
1507   1      
1508   1          fun_motors(mot_r,-40);
1509   1          fun_motors(mot_l,40);
1510   1          fun_delay(1,del_s);
1511   1          fun_motors(mot_rl,0);
1512   1      }//测试程序
1513          uc fun_min(uc par_num,...){
1514   1          va_list loc_argp;//保存参数结构
1515   1          uc loc_min=par_num;//现在的最小值就是第一个
1516   1          uc loc_shu;//当前参数
1517   1          va_start(loc_argp,par_num);//loc_argp指向传入的第一个可选参数，par_num是最后一个确
             -的参数
1518   1          loc_shu=va_arg(loc_argp,uc);//取出下一个参数
1519   1          do{
1520   2              if(loc_shu<loc_min)
1521   2                  loc_min=loc_shu;
1522   2              loc_shu=va_arg(loc_argp,uc);//取出下一个参数
1523   2          }while(loc_shu!=def_end);
1524   1          va_end(loc_argp);//结束
1525   1          return loc_min;//退出
1526   1      }//求最小值
1527          void fun_coordinate(){
1528   1          
1529   1      }//自动巡线之坐标
1530          void fun_zdzj(ul par_04,ul par_37){//ul型数据,一次输入所有结果,无需等待
1531   1          xdata struct str_zdzj str_pass,str_end;//str_zdzj(自动抓件)的结构体:现在的数据和结束
             -得到的结果
1532   1          xdata char loc_high[8];         //每摞工件的高度
1533   1          xdata uc loc_xh1;             //第一个循环
1534   1      
1535   1          memset(str_pass.jx,0,sizeof(str_pass.jx));//清空现在件序
1536   1          memset(str_end.jx,0,sizeof(str_end.jx)); //清空想要的件序
1537   1          memset(loc_high,5,sizeof(loc_high));     //每组高度置5(没有件)
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 26  

1538   1      
1539   1          //起始区件号
1540   1          str_pass.jx[0][1]=(par_04/10000000)%10;  //传入现在件序:区0的第1号件件号(最高位)
1541   1          str_pass.jx[0][2]=(par_04/1000000)%10;   //传入现在件序:区0的第2号件件号
1542   1          str_pass.jx[0][3]=(par_04/100000)%10;    //传入现在件序:区0的第3号件件号
1543   1          str_pass.jx[0][4]=(par_04/10000)%10;     //传入现在件序:区0的第4号件件号(最低位)
1544   1          str_pass.jx[4][1]=(par_04/1000)%10;      //传入现在件序:区4的第1号件件号(最高位)
1545   1          str_pass.jx[4][2]=(par_04/100)%10;       //传入现在件序:区4的第2号件件号
1546   1          str_pass.jx[4][3]=(par_04/10)%10;        //传入现在件序:区4的第3号件件号
1547   1          str_pass.jx[4][4]=par_04%10;             //传入现在件序:区4的第4号件件号(最低位)
1548   1          //目的区件号
1549   1          str_pass.jx[3][1]=(par_37/10000000)%10;  //传入现在件序:区0的第1号件件号(最高位)
1550   1          str_pass.jx[3][2]=(par_37/1000000)%10;   //传入现在件序:区0的第2号件件号
1551   1          str_pass.jx[3][3]=(par_37/100000)%10;    //传入现在件序:区0的第3号件件号
1552   1          str_pass.jx[3][4]=(par_37/10000)%10;     //传入现在件序:区0的第4号件件号(最低位)
1553   1          str_pass.jx[7][1]=(par_37/1000)%10;      //传入现在件序:区4的第1号件件号(最高位)
1554   1          str_pass.jx[7][2]=(par_37/100)%10;       //传入现在件序:区4的第2号件件号
1555   1          str_pass.jx[7][3]=(par_37/10)%10;        //传入现在件序:区4的第3号件件号
1556   1          str_pass.jx[7][4]=par_37%10;             //传入现在件序:区4的第4号件件号(最低位)
1557   1          //目的次序
1558   1          str_end.jx[3][1]=1;                      //标准目标次序:区3的第1号目的次序号(最高位)
1559   1          str_end.jx[3][2]=2;                      //标准目标次序:区3的第2号目的次序号
1560   1          str_end.jx[3][3]=3;                      //标准目标次序:区3的第3号目的次序号
1561   1          str_end.jx[3][4]=4;                      //标准目标次序:区3的第4号目的次序号(最低位)
1562   1          str_end.jx[7][1]=5;                      //标准目标次序:区7的第1号目的次序号(最高位)
1563   1          str_end.jx[7][2]=6;                      //标准目标次序:区7的第2号目的次序号
1564   1          str_end.jx[7][3]=7;                      //标准目标次序:区7的第3号目的次序号
1565   1          str_end.jx[7][4]=8;                      //标准目标次序:区7的第4号目的次序号(最低位)
1566   1      
1567   1          for(loc_xh1=1;loc_xh1<=4;loc_xh1++){
1568   2              if((str_pass.jx[0][loc_xh1]==str_pass.jx[3][1])&&(str_pass.jx[0][loc_xh1]!=0))
1569   2                  str_end.jx[0][loc_xh1]=str_end.jx[3][1];
1570   2              else if((str_pass.jx[0][loc_xh1]==str_pass.jx[3][2])&&(str_pass.jx[0][loc_xh1]!=0))
1571   2                  str_end.jx[0][loc_xh1]=str_end.jx[3][2];
1572   2              else if((str_pass.jx[0][loc_xh1]==str_pass.jx[3][3])&&(str_pass.jx[0][loc_xh1]!=0))
1573   2                  str_end.jx[0][loc_xh1]=str_end.jx[3][3];
1574   2              else if((str_pass.jx[0][loc_xh1]==str_pass.jx[3][4])&&(str_pass.jx[0][loc_xh1]!=0))
1575   2                  str_end.jx[0][loc_xh1]=str_end.jx[3][4];
1576   2              else if((str_pass.jx[0][loc_xh1]==str_pass.jx[7][1])&&(str_pass.jx[0][loc_xh1]!=0))
1577   2                  str_end.jx[0][loc_xh1]=str_end.jx[7][1];
1578   2              else if((str_pass.jx[0][loc_xh1]==str_pass.jx[7][2])&&(str_pass.jx[0][loc_xh1]!=0))
1579   2                  str_end.jx[0][loc_xh1]=str_end.jx[7][2];
1580   2              else if((str_pass.jx[0][loc_xh1]==str_pass.jx[7][3])&&(str_pass.jx[0][loc_xh1]!=0))
1581   2                  str_end.jx[0][loc_xh1]=str_end.jx[7][3];
1582   2              else if((str_pass.jx[0][loc_xh1]==str_pass.jx[7][4])&&(str_pass.jx[0][loc_xh1]!=0))
1583   2                  str_end.jx[0][loc_xh1]=str_end.jx[7][4];
1584   2      
1585   2              if((str_pass.jx[4][loc_xh1]==str_pass.jx[3][1])&&(str_pass.jx[4][loc_xh1]!=0))
1586   2                  str_end.jx[4][loc_xh1]=str_end.jx[3][1];
1587   2              else if((str_pass.jx[4][loc_xh1]==str_pass.jx[3][2])&&(str_pass.jx[4][loc_xh1]!=0))
1588   2                  str_end.jx[4][loc_xh1]=str_end.jx[3][2];
1589   2              else if((str_pass.jx[4][loc_xh1]==str_pass.jx[3][3])&&(str_pass.jx[4][loc_xh1]!=0))
1590   2                  str_end.jx[4][loc_xh1]=str_end.jx[3][3];
1591   2              else if((str_pass.jx[4][loc_xh1]==str_pass.jx[3][4])&&(str_pass.jx[4][loc_xh1]!=0))
1592   2                  str_end.jx[4][loc_xh1]=str_end.jx[3][4];
1593   2              else if((str_pass.jx[4][loc_xh1]==str_pass.jx[7][1])&&(str_pass.jx[4][loc_xh1]!=0))
1594   2                  str_end.jx[4][loc_xh1]=str_end.jx[7][1];
1595   2              else if((str_pass.jx[4][loc_xh1]==str_pass.jx[7][2])&&(str_pass.jx[4][loc_xh1]!=0))
1596   2                  str_end.jx[4][loc_xh1]=str_end.jx[7][2];
1597   2              else if((str_pass.jx[4][loc_xh1]==str_pass.jx[7][3])&&(str_pass.jx[4][loc_xh1]!=0))
1598   2                  str_end.jx[4][loc_xh1]=str_end.jx[7][3];
1599   2              else if((str_pass.jx[4][loc_xh1]==str_pass.jx[7][4])&&(str_pass.jx[4][loc_xh1]!=0))
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 27  

1600   2                  str_end.jx[4][loc_xh1]=str_end.jx[7][4];
1601   2          }//通过实际件序获得编号
1602   1      
1603   1          memset(str_pass.jx,0,sizeof(str_pass.jx));//清空现在实际件序
1604   1          for(loc_xh1=1;loc_xh1<=4;loc_xh1++){
1605   2              str_pass.jx[0][loc_xh1]=str_end.jx[0][loc_xh1];
1606   2              str_pass.jx[4][loc_xh1]=str_end.jx[4][loc_xh1];
1607   2          }//将现在的件序从str_end.jx中拿到str_pass.jx
1608   1          for(loc_xh1=1;loc_xh1<=4;loc_xh1++){
1609   2              str_end.jx[0][loc_xh1]=0;
1610   2              str_end.jx[4][loc_xh1]=0;
1611   2          }//删除str_end.jx中现在的件序
1612   1          loc_high[0]=loc_high[4]=1;//只有0号和4号放满了件
1613   1          loc_xh1=0;//循环标志位归零
1614   1      
1615   1          /*
1616   1              到目前为止准备工作结束,现在的数组中没有实际件序,
1617   1              现在的编号在str_pass.jx中,
1618   1              想要得到的结果件序编号在str_end.jx中
1619   1          */
1620   1          while(1){
1621   2              //退出条件
1622   2              if((str_pass.jx[3][1]==str_end.jx[3][1])&&
1623   2              (str_pass.jx[3][2]==str_end.jx[3][2])&&
1624   2              (str_pass.jx[3][3]==str_end.jx[3][3])&&
1625   2              (str_pass.jx[3][4]==str_end.jx[3][4])&&
1626   2              (str_pass.jx[7][1]==str_end.jx[7][1])&&
1627   2              (str_pass.jx[7][2]==str_end.jx[7][2])&&
1628   2              (str_pass.jx[7][3]==str_end.jx[7][3])&&
1629   2              (str_pass.jx[7][4]==str_end.jx[7][4])){
1630   3                  if(str_begin.hzfx==dir_left){
1631   4                      fun_sz(han_s);                 //手抓松
1632   4                      fun_sj(sjp_1);                 //升降到最高位
1633   4                      fun_zjzt(mot_pyhz,7);           //平面位置7
1634   4                      fun_zjzt(mot_sj,loc_high[7]);   //升降到7的最高位
1635   4                      fun_sz(han_j);                 //手抓紧
1636   4                  }//如果停在左边
1637   3                  return;
1638   3              }//如果小车一方的实际件序和想要达到的件序相等
1639   2              if(str_begin.hzfx==dir_left){
1640   3                  //转向条件
1641   3                  loc_xh1++;//标志位+1
1642   3                  if(loc_xh1>=100){
1643   4                      loc_xh1=0;
1644   4                      fun_zjzt(mot_sj,fun_min(loc_high[0],loc_high[1],loc_high[2],loc_high[3],loc_high[4],loc_hi
             -gh[5],loc_high[6],loc_high[7],def_end)-1);
1645   4                      fun_hz(dir_right);
1646   4                  }
1647   3                  //可以一次拿走,不需要中间位的
1648   3                  if(loc_high[1]<5){
1649   4                      if(str_pass.jx[1][loc_high[1]]==str_end.jx[3][loc_high[3]-1]){
1650   5                          fun_najian(1,3,loc_high,str_pass.jx);//1-->3
1651   5                          continue;
1652   5                      }
1653   4                  }//如果区1有件
1654   3                  if(loc_high[2]<5){
1655   4                      if(str_pass.jx[2][loc_high[2]]==str_end.jx[3][loc_high[3]-1]){
1656   5                          fun_najian(2,3,loc_high,str_pass.jx);//2-->3
1657   5                          continue;
1658   5                      }
1659   4                  }//如果区2有件
1660   3                  if(loc_high[0]<5){
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 28  

1661   4                      if(str_pass.jx[0][loc_high[0]]==str_end.jx[3][loc_high[3]-1]){
1662   5                          fun_najian(0,3,loc_high,str_pass.jx);//0-->3
1663   5                          continue;
1664   5                      }
1665   4                      if(str_pass.jx[0][loc_high[0]]==str_end.jx[7][loc_high[7]-1]){
1666   5                          fun_najian(0,7,loc_high,str_pass.jx);//0-->7
1667   5                          continue;
1668   5                      }
1669   4                  }//如果区0有件
1670   3      
1671   3                  //不可以一次拿走,需要中间位的
1672   3                  if(loc_high[0]<5){
1673   4                      if((str_pass.jx[0][loc_high[0]]==str_end.jx[3][1])||
1674   4                      (str_pass.jx[0][loc_high[0]]==str_end.jx[3][2])||
1675   4                      (str_pass.jx[0][loc_high[0]]==str_end.jx[3][3])||
1676   4                      (str_pass.jx[0][loc_high[0]]==str_end.jx[3][4])){
1677   5                          if(((loc_high[1]==5)||//如果1区没放东西或者
1678   5                          (str_pass.jx[0][loc_high[0]]>str_pass.jx[1][loc_high[1]]))&&//0区的件编号大于1
             -的编号并且
1679   5                          (loc_high[1]>2)){//1区不能放超过2个件
1680   6                              fun_najian(0,1,loc_high,str_pass.jx);//0-->1
1681   6                              continue;
1682   6                          }
1683   5                          if(((loc_high[2]==5)||//如果2区没放东西或者
1684   5                          (str_pass.jx[0][loc_high[0]]>str_pass.jx[2][loc_high[2]]))&&//0区的件编号大于2
             -的编号并且
1685   5                          (loc_high[2]>2)){//2区不能放超过2个件
1686   6                              fun_najian(0,2,loc_high,str_pass.jx);//0-->2
1687   6                              continue;
1688   6                          }
1689   5                      }//如果要放在3上,但目前不能放
1690   4                      if((str_pass.jx[0][loc_high[0]]==str_end.jx[7][1])||
1691   4                      (str_pass.jx[0][loc_high[0]]==str_end.jx[7][2])||
1692   4                      (str_pass.jx[0][loc_high[0]]==str_end.jx[7][3])||
1693   4                      (str_pass.jx[0][loc_high[0]]==str_end.jx[7][4])){
1694   5                          if(((loc_high[5]==5)||//如果5区没东西放或者
1695   5                          (str_pass.jx[0][loc_high[0]]>str_pass.jx[5][loc_high[5]]))&&//0区的件编号大于5
             -的编号并且
1696   5                          (loc_high[5]>2)){//5区不能放超过2个件
1697   6                              fun_najian(0,5,loc_high,str_pass.jx);//0-->5
1698   6                              continue;
1699   6                          }
1700   5                          if(((loc_high[6]==5)||//如果6区没东西放或者
1701   5                          (str_pass.jx[0][loc_high[0]]>str_pass.jx[6][loc_high[6]]))&&//0区的件编号大于6
             -的编号并且
1702   5                          (loc_high[6]>2)){//6区不能放超过2个件
1703   6                              fun_najian(0,6,loc_high,str_pass.jx);//0-->6
1704   6                              continue;
1705   6                          }
1706   5                      }//如果要放在7上,但目前不能放
1707   4                  }//如果区0有件
1708   3      
1709   3                  //中间两个位置也不能一次搞定的
1710   3                  if((loc_high[1]<5)&&(loc_high[2]<5)){
1711   4                      if((str_pass.jx[1][loc_high[1]]>str_pass.jx[2][loc_high[2]])&&(loc_high[2]>1)){
1712   5                          fun_najian(1,2,loc_high,str_pass.jx);//1-->2
1713   5                          continue;
1714   5                      }//1的件比2的件大且区2放了不到3个件
1715   4                      if((str_pass.jx[2][loc_high[2]]>str_pass.jx[1][loc_high[1]])&&(loc_high[1]>1)){
1716   5                          fun_najian(2,1,loc_high,str_pass.jx);//2-->1
1717   5                          continue;
1718   5                      }//2的件比1的件大且区1放了不到3个件
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 29  

1719   4                  }//如果区1和区2都有件
1720   3      
1721   3                  //中间两个位置怎么也搞不定的
1722   3                  if((loc_high[1]<5)&&(loc_high[2]<5)){
1723   4                      if((loc_high[0]>1)&&(str_pass.jx[1][loc_high[1]]>str_pass.jx[0][loc_high[0]])){
1724   5                          fun_najian(1,0,loc_high,str_pass.jx);//1-->0
1725   5                          continue;
1726   5                      }//1区的件比0区的大且0区放了不到3个件
1727   4                      if((loc_high[0]>1)&&(str_pass.jx[2][loc_high[2]]>str_pass.jx[0][loc_high[0]])){
1728   5                          fun_najian(2,0,loc_high,str_pass.jx);//2-->0
1729   5                          continue;
1730   5                      }//2区的件比0区的大且0区放了不到3个件
1731   4                  }
1732   3              }//如果回转在左边 
1733   2              if(str_begin.hzfx==dir_right){
1734   3                  //转向条件
1735   3                  loc_xh1++;//标志位+1
1736   3                  if(loc_xh1>=100){
1737   4                      loc_xh1=0;
1738   4                      fun_zjzt(mot_sj,fun_min(loc_high[0],loc_high[1],loc_high[2],loc_high[3],loc_high[4],loc_hi
             -gh[5],loc_high[6],loc_high[7],def_end)-1);
1739   4                      fun_hz(dir_left);
1740   4                  }
1741   3                  //可以一次拿走,不需要中间位的
1742   3                  if(loc_high[5]<5){
1743   4                      if(str_pass.jx[5][loc_high[5]]==str_end.jx[7][loc_high[7]-1]){
1744   5                          fun_najian(5,7,loc_high,str_pass.jx);//5-->7
1745   5                          continue;
1746   5                      }//5-->7
1747   4                  }//如果区5有件
1748   3                  if(loc_high[6]<5){
1749   4                      if(str_pass.jx[6][loc_high[6]]==str_end.jx[7][loc_high[7]-1]){
1750   5                          fun_najian(6,7,loc_high,str_pass.jx);//6-->7
1751   5                          continue;
1752   5                      }//6-->7
1753   4                  }//如果区6有件
1754   3                  if(loc_high[4]<5){
1755   4                      if(str_pass.jx[4][loc_high[4]]==str_end.jx[7][loc_high[7]-1]){
1756   5                          fun_najian(4,7,loc_high,str_pass.jx);//4-->7
1757   5                          continue;
1758   5                      }//4-->7
1759   4                      if(str_pass.jx[4][loc_high[4]]==str_end.jx[3][loc_high[3]-1]){
1760   5                          fun_najian(4,3,loc_high,str_pass.jx);//4-->3
1761   5                          continue;
1762   5                      }//4-->3
1763   4                  }//如果区4有件
1764   3      
1765   3                  //不可以一次拿走,需要中间位的
1766   3                  if(loc_high[4]<5){
1767   4                      if((str_pass.jx[4][loc_high[4]]==str_end.jx[7][1])||
1768   4                      (str_pass.jx[4][loc_high[4]]==str_end.jx[7][2])||
1769   4                      (str_pass.jx[4][loc_high[4]]==str_end.jx[7][3])||
1770   4                      (str_pass.jx[4][loc_high[4]]==str_end.jx[7][4])){
1771   5                          if(((loc_high[5]==5)||//如果5区没东西放或者
1772   5                          (str_pass.jx[4][loc_high[4]]>str_pass.jx[5][loc_high[5]]))&&//4区的件编号大于5
             -的编号并且
1773   5                          (loc_high[5]>2)){//5区不能放超过2个件
1774   6                              fun_najian(4,5,loc_high,str_pass.jx);//4-->5
1775   6                              continue;
1776   6                          }
1777   5                          if(((loc_high[6]==5)||//如果6区没东西放或者
1778   5                          (str_pass.jx[4][loc_high[4]]>str_pass.jx[6][loc_high[6]]))&&//4区的件编号大于6
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 30  

             -的编号并且
1779   5                          (loc_high[6]>2)){//6区不能放超过2个件
1780   6                              fun_najian(4,6,loc_high,str_pass.jx);//4-->6
1781   6                              continue;
1782   6                          }
1783   5                      }//如果要放在7上,但目前不能放
1784   4                      if((str_pass.jx[4][loc_high[4]]==str_end.jx[3][1])||
1785   4                      (str_pass.jx[4][loc_high[4]]==str_end.jx[3][2])||
1786   4                      (str_pass.jx[4][loc_high[4]]==str_end.jx[3][3])||
1787   4                      (str_pass.jx[4][loc_high[4]]==str_end.jx[3][4])){
1788   5                          if(((loc_high[1]==5)||//如果1区没放东西或者
1789   5                          (str_pass.jx[4][loc_high[4]]>str_pass.jx[1][loc_high[1]]))&&//4区的件编号大于1
             -的编号并且
1790   5                          (loc_high[1]>2)){//1区不能放超过2个件
1791   6                              fun_najian(4,1,loc_high,str_pass.jx);//4-->1
1792   6                              continue;
1793   6                          }
1794   5                          if(((loc_high[2]==5)||//如果2区没放东西或者
1795   5                              (str_pass.jx[4][loc_high[4]]>str_pass.jx[2][loc_high[2]]))&&//4区的件编号大
             -2区的编号并且
1796   5                              (loc_high[2]>2)){//2区不能放超过2个件
1797   6                              fun_najian(4,2,loc_high,str_pass.jx);//4-->2
1798   6                              continue;
1799   6                          }
1800   5                      }//如果要放在3上,但目前不能放
1801   4                  }//如果区4有件
1802   3      
1803   3                  //中间两个位置也不能一次搞定的
1804   3                  if((loc_high[5]<5)&&(loc_high[6]<5)){
1805   4                      if((str_pass.jx[5][loc_high[5]]>str_pass.jx[6][loc_high[6]])&&(loc_high[6]>1)){
1806   5                          fun_najian(5,6,loc_high,str_pass.jx);//5-->6
1807   5                          continue;
1808   5                      }//5的件比6的件大且区6放了不到3个件
1809   4                      if((str_pass.jx[6][loc_high[6]]>str_pass.jx[5][loc_high[5]])&&(loc_high[5]>1)){
1810   5                          fun_najian(6,5,loc_high,str_pass.jx);//6-->5
1811   5                          continue;
1812   5                      }//6的件比5的件大且区5放了不到3个件
1813   4                  }//如果区5和区6都有件
1814   3      
1815   3                  //中间两个位置怎么也搞不定的
1816   3                  if((loc_high[5]<5)&&(loc_high[6]<5)){
1817   4                      if((loc_high[4]>1)&&(str_pass.jx[5][loc_high[5]]>str_pass.jx[4][loc_high[4]])){
1818   5                          fun_najian(5,4,loc_high,str_pass.jx);//5-->4
1819   5                          continue;
1820   5                      }//5区的件比4区的大且4区放了不到3个件
1821   4                      if((loc_high[4]>1)&&(str_pass.jx[6][loc_high[6]]>str_pass.jx[4][loc_high[4]])){
1822   5                          fun_najian(6,4,loc_high,str_pass.jx);//6-->4
1823   5                          continue;
1824   5                      }//6区的件比4区的大且4区放了不到3个件
1825   4                  }
1826   3              }//如果回转在右边
1827   2          }    
1828   1      }//自动抓件
1829          void fun_zjzt(uc par_motor,char par_model){
1830   1          if(par_motor==mot_pyhz){
1831   2              switch(par_model){
1832   3                  case 0:
1833   3                      if((str_begin.pywz==tra_h)&&(str_begin.hzfx==dir_left))
1834   3                          break;
1835   3                      if(str_begin.hzfx==dir_right)
1836   3                          fun_pyhz(tra_z,dir_left);
1837   3                      fun_py(tra_h);
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 31  

1838   3                      break;
1839   3                  case 1:
1840   3                      if((str_begin.pywz==tra_kh)&&(str_begin.hzfx==dir_left))
1841   3                          break;
1842   3                      if(str_begin.hzfx==dir_right)
1843   3                          fun_pyhz(tra_z,dir_left);
1844   3                      fun_py(tra_kh);
1845   3                      break;
1846   3                  case 2:
1847   3                      if((str_begin.pywz==tra_kq)&&(str_begin.hzfx==dir_left))
1848   3                          break;
1849   3                      if(str_begin.hzfx==dir_right)
1850   3                          fun_pyhz(tra_z,dir_left);
1851   3                      fun_py(tra_kq);
1852   3                      break;
1853   3                  case 3:
1854   3                      if((str_begin.pywz==tra_q)&&(str_begin.hzfx==dir_left))
1855   3                          break;
1856   3                      if(str_begin.hzfx==dir_right)
1857   3                          fun_pyhz(tra_z,dir_left);
1858   3                      fun_py(tra_q);
1859   3                      break;
1860   3                  case 4:
1861   3                      if((str_begin.pywz==tra_q)&&(str_begin.hzfx==dir_right))
1862   3                          break;
1863   3                      if(str_begin.hzfx==dir_left)
1864   3                          fun_pyhz(tra_z,dir_right);
1865   3                      fun_py(tra_q);
1866   3                      break;
1867   3                  case 5:
1868   3                      if((str_begin.pywz==tra_kq)&&(str_begin.hzfx==dir_right))
1869   3                          break;
1870   3                      if(str_begin.hzfx==dir_left)
1871   3                          fun_pyhz(tra_z,dir_right);
1872   3                      fun_py(tra_kq);
1873   3                      break;
1874   3                  case 6:
1875   3                      if((str_begin.pywz==tra_kh)&&(str_begin.hzfx==dir_right))
1876   3                          break;
1877   3                      if(str_begin.hzfx==dir_left)
1878   3                          fun_pyhz(tra_z,dir_right);
1879   3                      fun_py(tra_kh);
1880   3                      break;
1881   3                  case 7:
1882   3                      if((str_begin.pywz==tra_h)&&(str_begin.hzfx==dir_right))
1883   3                          break;
1884   3                      if(str_begin.hzfx==dir_left)
1885   3                          fun_pyhz(tra_z,dir_right);
1886   3                      fun_py(tra_h);
1887   3                      break;
1888   3                  default:
1889   3                      break;
1890   3              }
1891   2          }
1892   1          else if(par_motor==mot_sj){
1893   2              switch(par_model){
1894   3                  case 0:
1895   3                      fun_sj(sjp_1);
1896   3                      break;
1897   3                  case 1:
1898   3                      fun_sj(sjp_2);
1899   3                      break;
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 32  

1900   3                  case 2:
1901   3                      fun_sj(sjp_3);
1902   3                      break;
1903   3                  case 3:
1904   3                      fun_sj(sjp_4);
1905   3                      break;
1906   3                  case 4:
1907   3                      fun_sj(sjp_5);
1908   3                      break;
1909   3                  default:
1910   3                      if(par_model<0)
1911   3                          fun_sj(sjp_1);
1912   3                      else if(par_model>5)
1913   3                          fun_sj(sjp_5);
1914   3                      break;
1915   3              }
1916   2          }
1917   1      }//抓件状态,0为左上位,3为左下位,4为右上位,7为右下位
1918          void fun_najian(uc par_now,uc par_next,char par_high[8],uc par_data[8][5]){
1919   1          #ifdef Debug
                      printf("%d --> %d\n",(ui)par_now,(ui)par_next);
                  #else
1922   1              //取各位置的最高位
1923   1              xdata uc loc_high=fun_min(par_high[0],par_high[1],par_high[2],par_high[3],par_high[4],par_high[5],
             -par_high[6],par_high[7],def_end);
1924   1              //升起
1925   1              if(par_now==0||par_now==1||par_now==2||par_now==3){
1926   2                  if(str_begin.hzfx==dir_left)
1927   2                      fun_zjzt(mot_sj,fun_min(par_high[0],par_high[1],par_high[2],par_high[3],def_end)-1);
1928   2                  else if(str_begin.hzfx==dir_right)
1929   2                      fun_zjzt(mot_sj,fun_min(par_high[0],par_high[1],par_high[2],par_high[3],par_high[4],par_hi
             -gh[5],par_high[6],par_high[7],def_end)-1);            
1930   2              }
1931   1              else if(par_now==4||par_now==5||par_now==6||par_now==7){
1932   2                  if(str_begin.hzfx==dir_right)
1933   2                      fun_zjzt(mot_sj,fun_min(par_high[4],par_high[5],par_high[6],par_high[7],def_end)-1);
1934   2                  else if(str_begin.hzfx==dir_left)
1935   2                      fun_zjzt(mot_sj,fun_min(par_high[0],par_high[1],par_high[2],par_high[3],par_high[4],par_hi
             -gh[5],par_high[6],par_high[7],def_end)-1);            
1936   2              }
1937   1              //平移回转到需要的地方
1938   1              fun_zjzt(mot_pyhz,par_now);
1939   1              //下降到工件的位置
1940   1              fun_zjzt(mot_sj,par_high[par_now]);
1941   1              //抓紧工件
1942   1              fun_sz(han_j);
1943   1              //上升到正确的最高位
1944   1              switch(par_now){
1945   2                  case 0:
1946   2                      switch(par_next){
1947   3                          case 1:
1948   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[par_next],def_end)
             --2);
1949   3                              break;
1950   3                          case 2:
1951   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[1],par_high[par_ne
             -xt],def_end)-2);
1952   3                              break;
1953   3                          case 3:
1954   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[1],par_high[2],par
             -_high[par_next],def_end)-2);
1955   3                              break;
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 33  

1956   3                          case 4:
1957   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[1],par_high[5],par
             -_high[par_next],def_end)-2);
1958   3                              break;
1959   3                          case 5:
1960   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[1],par_high[par_ne
             -xt],def_end)-2);
1961   3                              break;
1962   3                          case 6:
1963   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[1],par_high[par_ne
             -xt],def_end)-2);
1964   3                              break;
1965   3                          case 7:
1966   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[1],par_high[6],par
             -_high[par_next],def_end)-2);
1967   3                              break;
1968   3                          default:
1969   3                              break;
1970   3                      }
1971   2                      break;
1972   2                  case 1:
1973   2                      switch(par_next){
1974   3                          case 0:
1975   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[par_next],def_end)
             --2);
1976   3                              break;
1977   3                          case 2:
1978   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[par_next],def_end)
             --2);
1979   3                              break;
1980   3                          case 3:
1981   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[2],par_high[par_ne
             -xt],def_end)-2);
1982   3                              break;
1983   3                          case 4:
1984   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[5],par_high[par_ne
             -xt],def_end)-2);
1985   3                              break;
1986   3                          case 5:
1987   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[par_next],def_end)
             --2);
1988   3                              break;
1989   3                          case 6:
1990   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[par_next],def_end)
             --2);
1991   3                              break;
1992   3                          case 7:
1993   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[6],par_high[par_ne
             -xt],def_end)-2);
1994   3                              break;
1995   3                          default:
1996   3                              break;
1997   3                      }
1998   2                      break;
1999   2                  case 2:
2000   2                      switch(par_next){
2001   3                          case 0:
2002   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[1],par_high[par_ne
             -xt],def_end)-2);
2003   3                              break;
2004   3                          case 1:
2005   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[par_next],def_end)
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 34  

             --2);
2006   3                              break;
2007   3                          case 3:
2008   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[par_next],def_end)
             --2);
2009   3                              break;
2010   3                          case 4:
2011   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[5],par_high[par_ne
             -xt],def_end)-2);
2012   3                              break;
2013   3                          case 5:
2014   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[par_next],def_end)
             --2);
2015   3                              break;
2016   3                          case 6:
2017   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[par_next],def_end)
             --2);
2018   3                              break;
2019   3                          case 7:
2020   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[6],par_high[par_ne
             -xt],def_end)-2);
2021   3                              break;
2022   3                          default:
2023   3                              break;
2024   3                      }
2025   2                      break;
2026   2                  case 3:
2027   2                      switch(par_next){
2028   3                          case 0:
2029   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[2],par_high[1],par
             -_high[par_next],def_end)-2);
2030   3                              break;
2031   3                          case 1:
2032   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[2],par_high[par_ne
             -xt],def_end)-2);
2033   3                              break;
2034   3                          case 2:
2035   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[par_next],def_end)
             --2);
2036   3                              break;
2037   3                          case 4:
2038   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[2],par_high[5],par
             -_high[par_next],def_end)-2);
2039   3                              break;
2040   3                          case 5:
2041   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[2],par_high[par_ne
             -xt],def_end)-2);
2042   3                              break;
2043   3                          case 6:
2044   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[2],par_high[par_ne
             -xt],def_end)-2);
2045   3                              break;
2046   3                          case 7:
2047   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[2],par_high[6],par
             -_high[par_next],def_end)-2);
2048   3                              break;
2049   3                          default:
2050   3                              break;
2051   3                      }
2052   2                      break;
2053   2                  case 4:
2054   2                      switch(par_next){
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 35  

2055   3                          case 0:
2056   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[5],par_high[1],par
             -_high[par_next],def_end)-2);
2057   3                              break;
2058   3                          case 1:
2059   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[5],par_high[par_ne
             -xt],def_end)-2);
2060   3                              break;
2061   3                          case 2:
2062   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[5],par_high[par_ne
             -xt],def_end)-2);
2063   3                              break;
2064   3                          case 3:
2065   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[5],par_high[2],par
             -_high[par_next],def_end)-2);
2066   3                              break;
2067   3                          case 5:
2068   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[par_next],def_end)
             --2);
2069   3                              break;
2070   3                          case 6:
2071   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[5],par_high[par_ne
             -xt],def_end)-2);
2072   3                              break;
2073   3                          case 7:
2074   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[5],par_high[6],par
             -_high[par_next],def_end)-2);
2075   3                              break;
2076   3                          default:
2077   3                              break;
2078   3                      }
2079   2                      break;
2080   2                  case 5:
2081   2                      switch(par_next){
2082   3                          case 0:
2083   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[1],par_high[par_ne
             -xt],def_end)-2);
2084   3                              break;
2085   3                          case 1:
2086   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[par_next],def_end)
             --2);
2087   3                              break;
2088   3                          case 2:
2089   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[par_next],def_end)
             --2);
2090   3                              break;
2091   3                          case 3:
2092   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[2],par_high[par_ne
             -xt],def_end)-2);
2093   3                              break;
2094   3                          case 4:
2095   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[par_next],def_end)
             --2);
2096   3                              break;
2097   3                          case 6:
2098   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[par_next],def_end)
             --2);
2099   3                              break;
2100   3                          case 7:
2101   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[6],par_high[par_ne
             -xt],def_end)-2);
2102   3                              break;
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 36  

2103   3                          default:
2104   3                              break;
2105   3                      }
2106   2                      break;
2107   2                  case 6:
2108   2                      switch(par_next){
2109   3                          case 0:
2110   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[1],par_high[par_ne
             -xt],def_end)-2);
2111   3                              break;
2112   3                          case 1:
2113   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[par_next],def_end)
             --2);
2114   3                              break;
2115   3                          case 2:
2116   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[par_next],def_end)
             --2);
2117   3                              break;
2118   3                          case 3:
2119   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[2],par_high[par_ne
             -xt],def_end)-2);
2120   3                              break;
2121   3                          case 4:
2122   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[5],par_high[par_ne
             -xt],def_end)-2);
2123   3                              break;
2124   3                          case 5:
2125   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[par_next],def_end)
             --2);
2126   3                              break;
2127   3                          case 7:
2128   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[par_next],def_end)
             --2);
2129   3                              break;
2130   3                          default:
2131   3                              break;
2132   3                      }
2133   2                      break;
2134   2                  case 7:
2135   2                      switch(par_next){
2136   3                          case 0:
2137   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[6],par_high[1],par
             -_high[par_next],def_end)-2);
2138   3                              break;
2139   3                          case 1:
2140   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[6],par_high[par_ne
             -xt],def_end)-2);
2141   3                              break;
2142   3                          case 2:
2143   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[6],par_high[par_ne
             -xt],def_end)-2);
2144   3                              break;
2145   3                          case 3:
2146   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[6],par_high[2],par
             -_high[par_next],def_end)-2);
2147   3                              break;
2148   3                          case 4:
2149   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[5],par_high[6],par
             -_high[par_next],def_end)-2);
2150   3                              break;
2151   3                          case 5:
2152   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[6],par_high[par_ne
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 37  

             -xt],def_end)-2);
2153   3                              break;
2154   3                          case 6:
2155   3                              fun_zjzt(mot_sj,fun_min(loc_high+2,par_high[par_now]+1,par_high[par_next],def_end)
             --2);
2156   3                              break;
2157   3                          default:
2158   3                              break;
2159   3                      }
2160   2                      break;
2161   2                  default:
2162   2                      break;
2163   2              }
2164   1              //平移回转至放件处
2165   1              fun_zjzt(mot_pyhz,par_next);
2166   1              //下降到要放下的位置
2167   1              fun_zjzt(mot_sj,par_high[par_next]-1);
2168   1              //松开手抓
2169   1              fun_sz(han_s);
2170   1          #endif
2171   1      
2172   1          //更新参数
2173   1          par_data[par_next][par_high[par_next]-1]=par_data[par_now][par_high[par_now]];
2174   1          par_data[par_now][par_high[par_now]]=0;
2175   1          par_high[par_now]++;
2176   1          par_high[par_next]--;
2177   1      }//拿件(配合自动抓件使用)
2178          void fun_zhuajian(){
2179   1          fun_sz(han_s);                 //手抓松
2180   1          fun_sj(sjp_1);                 //上升到最高位
2181   1          fun_py(tra_q);                 //平移到前端
2182   1          if(str_begin.hzfx!=dir_right)   //如果不在右边
2183   1              fun_hz(dir_right);         //就平移到右边
2184   1      
2185   1          fun_folline(2,60);
2186   1          fun_turn(tur_l90,40);
2187   1          fun_folline(1,60);
2188   1          fun_qc(100,40);
2189   1          while((!in_ls4||!in_ls5)||(in_ls1||in_ls2||in_ls3||in_ls6||in_ls7||in_ls8)){
2190   2              if(in_ls1||in_ls2||in_ls3||!in_ls5){
2191   3                  fun_motors(mot_rl,-30);
2192   3                  fun_delay(300,del_ms);
2193   3                  fun_motors(mot_r,-20);
2194   3                  fun_motors(mot_l,-30);
2195   3                  fun_delay(300,del_ms);
2196   3                  fun_motors(mot_rl,-30);
2197   3                  fun_delay(300,del_ms);
2198   3              }//3亮或5不亮
2199   2              else if(in_ls6||in_ls7||in_ls8||!in_ls4){
2200   3                  fun_motors(mot_rl,-30);
2201   3                  fun_delay(300,del_ms);
2202   3                  fun_motors(mot_r,-30);
2203   3                  fun_motors(mot_l,-29);
2204   3                  fun_delay(300,del_ms);
2205   3                  fun_motors(mot_rl,-30);
2206   3                  fun_delay(300,del_ms);
2207   3              }//6亮或4不亮
2208   2              fun_qc(128,40);//重新进行前冲
2209   2          }
2210   1          fun_motors(mot_rl,0);
2211   1      }//从起始区走到抓件区
2212          void fun_back(){
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 38  

2213   1          fun_motors(mot_rl,-30);
2214   1          fun_delay(1,del_s);
2215   1      
2216   1          fun_motors(mot_r,-50);
2217   1          fun_motors(mot_l,-20);
2218   1          fun_delay(3,del_s);    
2219   1      
2220   1          fun_motors(mot_rl,-35);
2221   1          fun_delay(1,del_s);
2222   1      }//从抓件区回到起始区
2223          void fun_start(char par_x,char par_y,enum varENU_dir par_ctfx,enum varENU_han par_szzt,enum varENU_sjp par
             -_sjwz,enum varENU_tra par_pywz,enum varENU_dir par_hzfx){
2224   1          CLK_DIV=0x00;             //不分频
2225   1          P0M1=0xff;                //P0用于输入
2226   1          P0M0=0x00;                //P0不能输出
2227   1          P1M1=0x00;                //P1口0-1双向
2228   1          P1M0=0xfc;                //P1口2-7输出
2229   1          P2M1=0xf0;                //P2口4-7输入
2230   1          P2M0=0x0f;                //P2口0-3输出
2231   1      
2232   1          out_en1=1;                //电机1/3使能
2233   1          out_en2=1;                //电机2/4使能
2234   1          CR=0;                     //PAC计数器归零
2235   1          out_motorselect=0;        //电机片选为0
2236   1      
2237   1          #ifdef Debug              //如果是调试模式
                      fun_port();           //初始化串口
                      TI=1;                 //打开串口传输功能        
                  #endif
2241   1          fun_pwminit();            //PWM的初始化
2242   1          fun_timer0init();         //初始化定时器0
2243   1          fun_timer1init();         //初始化定时器1
2244   1      
2245   1          str_begin.x=par_x;        //X坐标
2246   1          str_begin.y=par_y;        //Y坐标
2247   1          str_begin.ctfx=par_ctfx;  //车头方向
2248   1          str_begin.szzt=par_szzt;  //手抓状态
2249   1          str_begin.sjwz=par_sjwz;  //升降位置
2250   1          str_begin.pywz=par_pywz;  //平移位置
2251   1          str_begin.hzfx=par_hzfx;  //回转方向
2252   1      
2253   1          str_tfl.gospeed=0;        //速度归零
2254   1          fun_motors(mot_sz,0);     //手抓速度归零
2255   1          fun_motors(mot_py,0);     //平移速度归零
2256   1          fun_motors(mot_sj,0);     //手抓速度归零
2257   1          fun_motors(mot_hz,0);     //手抓速度归零
2258   1          fun_motors(mot_rl,0);     //左右速度归零
2259   1      
2260   1          TR0=1;                    //打开定时器0
2261   1          TR1=1;                    //打开定时器1
2262   1          in_start=1;               //按键置1
2263   1          #ifdef Debug              //如果开启调试模式
                      fun_delay(5,del_s);
                      MSG("Ready!")         //输出Ready!
                  #else
2267   1              fun_wait();           //等待按键
2268   1          #endif
2269   1      }//初始化函数
2270          void fun_stop(){
2271   1          EA=0;                   //关总中断
2272   1          str_tfl.gospeed=0;      //速度归零
2273   1          fun_motors(mot_sz,0);   //手抓速度归零
C51 COMPILER V9.54   8023                                                                  09/30/2015 11:18:20 PAGE 39  

2274   1          fun_motors(mot_py,0);   //平移速度归零
2275   1          fun_motors(mot_sj,0);   //手抓速度归零
2276   1          fun_motors(mot_hz,0);   //手抓速度归零
2277   1          fun_motors(mot_rl,0);   //左右速度归零
2278   1          MSG("End!")             //输出End!
2279   1          while(1);               //死循环
2280   1      }//结束函数


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  12455    ----
   CONSTANT SIZE    =      9    ----
   XDATA SIZE       =    150      90
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5      72
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
